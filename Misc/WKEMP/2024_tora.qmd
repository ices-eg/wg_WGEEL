---
title: "WKEMP4"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
documentclass: report
execute:
  echo: false
  warning: false
  message: false
  error: false
format:
  docx:
    fig_caption: yes
    reference-doc: "../../R/quarto/ICES_template.docx"
params:
  image_path: "2024/image"
  quarto_path: "../../R/quarto/"
  data_path: "2024/data"
lang: fr
bibliography: "../../R/quarto/ICES.bib"
csl: "../../R/quarto/ices-journal-of-marine-science.csl"
crossref:
  chapters: true
  fig-prefix: ''
  tbl-prefix: ''
  eq-prefix: ''
  ref-hyperlink: true
link-citations: true
link-bibliography: true
---


```{r }
#| label: qmdhelper
#| eval: FALSE
# this is only necessary in eclipse, VScodium outside quarto render
#  Rstudio or vscodium quarto render should have param ready
# so you just need to launch this manually to make your code work

params <- list(image_path = "2024/image",
  quarto_path = "../../R/quarto/",
  data_path = "2024/data")
setwd(dirname(.vsc$rstudioapi_env$getSourceEditorContext()$path))
#setwd("c:/workspace/wg_WGEEL/Misc/WKEMP")
```


```{r }
#| label: setup

source(file.path(params$quarto_path,"quarto_utilities.R"))
library(RPostgres)
library(sf)
library(getPass)
library(ggforce)
library(ggplot2)
library(flextable)
library(tidyverse)
library(yaml)
cred <- read_yaml("../../credentials.yml")
con <- dbConnect(Postgres(), dbname = cred$dbname, host = cred$host, port = cred$port, user = cred$user, password = cred$password)
load("../../R/shiny_data_visualisation/shiny_dv/data/maps_for_shiny.Rdata")
load("../../R/shiny_data_visualisation/shiny_dv/data/ref_and_eel_data.Rdata")
eu_cou_codes <- c("AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE", "FI", "FR", "DE", "GR", "HU", "IE", "IT", "LV", "LT", "LU", "MT", "NL", "PL", "PT", "RO", "SK", "SI", "ES", "SE")
country_ref <- dbGetQuery(con, "select cou_code from ref.tr_country_cou")
values <- c(
  RColorBrewer::brewer.pal(12, "Set3"),
  RColorBrewer::brewer.pal(12, "Paired"),
  RColorBrewer::brewer.pal(8, "Accent"),
  RColorBrewer::brewer.pal(8, "Dark2")
)
color_countries <- setNames(values, country_ref$cou_code)
```


```{r }
#| label: download
biomass <- dbGetQuery(con, "select e.* from datawg.t_eelstock_eel e
  where eel_qal_id in (0,1,2,3,4) and eel_typ_id in (13,14,15,34)")

mortality <- dbGetQuery(con, "select e.* from datawg.t_eelstock_eel e
where eel_qal_id in (0,1,2,3,4) and eel_typ_id in (17,18,19)")

nb_country_emu <- dbGetQuery(con, "select count(distinct eel_cou_code),
                             count(distinct(eel_emu_nameshort))
                             from datawg.t_eelstock_eel
                             where eel_typ_id in (13, 14, 15, 17, 18, 19,34)
                             and eel_datasource='dc_2021'")
avgindicator <- dbGetQuery(con, "select eel_cou_code,eel_emu_nameshort, avg(b0)b0,avg(bbest)bbest,
avg(bcurrent)bcurrent, avg(bcurrent_without_stocking)bcurrentw, 
avg(suma)suma,avg(sumf)sumf,avg(sumh) sumh from datawg.precodata_emu where eel_year>=2020 group by eel_cou_code,eel_emu_nameshort") |>
  mutate(eel_emu_nameshort = ifelse(eel_cou_code == "NL", "NL_Neth", eel_emu_nameshort))
avgindicator <- merge(emu_c, avgindicator, by.x = "emu_nameshort", by.y = "eel_emu_nameshort", all.x = TRUE)
avgindicator <- st_transform(avgindicator, crs = 3035)
avgindicator$x <- st_coordinates(avgindicator)[, 1]
avgindicator$y <- st_coordinates(avgindicator)[, 2]
avgindicator$btarget <- .4 * avgindicator$b0
avgindicator$bscaled <- avgindicator$bcurrent / avgindicator$b0
avgindicator$sumfsuma <- avgindicator$sumf / avgindicator$suma
avgindicator$sumhsuma <- avgindicator$sumh / avgindicator$suma
prettyscale <- pretty(range(avgindicator$bcurrent, na.rm = TRUE), n = 2)
prettyscale_scaled <- scales::rescale(prettyscale, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrent, na.rm = TRUE)))
scalesb <- data.frame(b = prettyscale, bscale = prettyscale_scaled)
# avgindicator$btarget <- scales::rescale(avgindicator$btarget,to=c(40190.79,200000.00),from=c(661,10400000))
avgindicator$bcurrent <- scales::rescale(avgindicator$bcurrent, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrent, na.rm = TRUE)))
# avgindicator$bbest <- scales::rescale(avgindicator$bbest,to=c(40190.79,200000.00),from=c(661,10400000))
# avgindicator$b0 <- scales::rescale(avgindicator$b0,to=c(40190.79,200000.00),from=c(661,10400000))

avgindicator$bcurrentwscaled <- avgindicator$bcurrentw / avgindicator$b0
prettyscale_norestock <- pretty(range(avgindicator$bcurrentw, na.rm = TRUE), n = 2)
prettyscale_norestock_scaled <- scales::rescale(prettyscale_norestock, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrentw, na.rm = TRUE)))
scalesb_norestock <- data.frame(b = prettyscale_norestock, bscale = prettyscale_norestock_scaled)
avgindicator$bcurrentw <- scales::rescale(avgindicator$bcurrentw, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrentw, na.rm = TRUE)))

# avgindicator$bcurrent <- log(avgindicator$bcurrent)/log(max(avgindicator$b0,na.rm=TRUE))*100000
# avgindicator$bbest <- log(avgindicator$bbest)/log(max(avgindicator$b0,na.rm=TRUE))*100000
# avgindicator$b0 <- log(avgindicator$b0)/log(max(avgindicator$b0,na.rm=TRUE))*100000
avgindicator$suma <- avgindicator$suma / .92 * 20000
avgindicator$sumf <- avgindicator$sumf / .92 * 20000
avgindicator$sumh <- avgindicator$sumh / .92 * 20000

avgindicator$x[avgindicator$eel_cou_code == "NO"] <- 4172612.3
avgindicator$y[avgindicator$eel_cou_code == "NO"] <- 4111023.3

indicator <- dbGetQuery(con, "select eel_year,eel_cou_code,eel_emu_nameshort, b0,bbest,bcurrent, bcurrent_without_stocking as bcurrentw, suma,sumf, sumh from datawg.precodata_emu")
indicator2 <- indicator
# indicator <- indicator |>
#   mutate(eel_cou_code = ifelse(eel_cou_code == substr(eel_emu_nameshort, 1, 2),
#     eel_cou_code,
#     "ES_Minh"
#   ))

```

# Importance of non reported data

Checks were done to see which countries have reported and what corresponds to the lastest value in the database.

## Countries without report

The following countries have not responded to the DATA call annexes 10- to 11 reporting biomass or mortality indicators:

Non-EU countries (Atlantic):

-   Ã…land Islands (AX)
-   Iceland (IS)
-   Russia (RU)

EU countries (Atlantic):

-   Luxembourg (LU)
-   Czech republic (CZ)

Non-EU countries (Mediterranean):

-   Albania (AL)
-   Bosnia and Herzegovina (BA)
-   Algeria (DZ)
-   Egypt (EG)
-   Lenbanon (LB)
-   Israel (IL)
-   Libya (LY)
-   Morocco (MA)
-   Montenegro (ME)
-   Syria (SY)
-   Tunisia (TN)
-   Turkey (TR)

EU countries (Mediterranean):

-   Cyprus (CY) (exempted)
-   Croatia (HR)
-   Italy (IT)
-   Malta (MT) (exempted)
-   Slovenia (SI)

Non EU countries from the GFCM have not provided biomass or mortality indicators.

Non EU countries from the GFCM have not provided biomass or mortality indicators.
***This lack of evaluation hampers the evaluation at stock level.***
Cyprus and Malta are exempted from providing a management plan. Romania, Austria and Slovakia are in the Black Sea region and also exempted by the commission from providing a management plan. Italy did not report data for biomass and mortality. Italy reported indicators in the past, but those indicators have been removed from the wgeel database, alongside all data prior to the 2021 datacall (the format of the data was changed in 2021 and all biomass and mortality data were replaced). From 2019 onwards no new assessment estimates have been made, so indicator values from 2019 onwards should be NR.

```{r }
#| label: not_reported




not_reported <- country_p$cou_code[!country_p$cou_code %in% c(biomass$eel_cou_code, mortality$eel_cou_code)] # countries with no reported data on biomass or mortality for any EMU for any year

# sprintf("Countries not reporting (outside EU) : %s.", paste(sort(not_reported[!not_reported %in% eu_cou_codes]), collapse =', '))

# Same, but only EU countries, who are mandated to report biomass and mortality indicators
not_reported_EU <- not_reported[not_reported %in% eu_cou_codes]

# sprintf("Countries not reporting in the EU : %s.", paste(sort(not_reported_EU), collapse =', '))
```

## Importance of landings for non reporting countries


```{r }
#| label: tbl-tableit
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Landings reported in Italy and elsewhere in Europe and outside from European countries since 2010"
knitr::kable(data.frame())
```

```{r }
#| label: flextableit
landings <- dbGetQuery(con, paste0(
  "select eel_value,eel_cou_code,eel_lfs_code,eel_year from datawg.t_eelstock_eel where eel_cou_code in ('",
  paste(not_reported_EU, collapse = "','"),
  "') and eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2010"
)) |>
  # First, calculate total landings per country per lifestage per year
  group_by(eel_year, eel_lfs_code, eel_cou_code) |>
  summarize(eel_value = sum(eel_value, na.rm = TRUE)) |>
  # Then, from there, calculate mean landings per country per lifestage since 2010
  group_by(eel_cou_code, eel_lfs_code) |>
  summarize(landings = mean(eel_value, na.rm = TRUE) / 1e3) |>
  pivot_wider(names_from = eel_lfs_code, values_from = landings)

# Get total landings reported per year to compare with
tot_landings_EU <- dbGetQuery(con, paste0("select eel_value,eel_lfs_code,eel_year, eel_cou_code from datawg.t_eelstock_eel where eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2010")) |>
  filter(eel_cou_code %in% eu_cou_codes) |>
  group_by(eel_year, eel_lfs_code) |>
  summarize(eel_value = sum(eel_value, na.rm = TRUE)) |>
  group_by(eel_lfs_code) |>
  summarize(landings = mean(eel_value, na.rm = TRUE) / 1e3) |>
  mutate(eel_cou_code = "OVERALL TOTAL EU") |>
  pivot_wider(names_from = eel_lfs_code, values_from = landings)

tot_landings <- dbGetQuery(con, paste0("select eel_value,eel_lfs_code,eel_year from datawg.t_eelstock_eel where eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2010")) |>
  group_by(eel_year, eel_lfs_code) |>
  summarize(eel_value = sum(eel_value, na.rm = TRUE)) |>
  group_by(eel_lfs_code) |>
  summarize(landings = mean(eel_value, na.rm = TRUE) / 1e3) |>
  mutate(eel_cou_code = "OVERALL TOTAL") |>
  pivot_wider(names_from = eel_lfs_code, values_from = landings)

# First, a table for all countries that did not report indicators
# flextable(landings |>
#   bind_rows(tot_landings) |>
#   select(eel_cou_code, G, Y, YS, S)) |>
#   colformat_double(digits = 1)

# Then, a table for all EU countries that did not report indicators
tableit <- landings |>
  filter(eel_cou_code %in% eu_cou_codes) |>
  bind_rows(tot_landings_EU) |>
  bind_rows(tot_landings) |>
  select(eel_cou_code, G, Y, YS, S)

flextable(tableit) |>
  colformat_double(digits = 1) |>
  flextable2ICES()
```

After 2020 on average, total reported landings from yellow and silver eel fisheries across all countries amounted to `r round(sum(tableit[tableit$eel_cou_code=="OVERALL TOTAL",c(3:5)]))` tons. In comparison, Italy reported average landings for 5 years reached `r round(sum(tableit[tableit$eel_cou_code=='IT',c(3:5)], na.rm =TRUE))` tons, contributing approximately for `r round(100*sum(tableit[tableit$eel_cou_code=='IT',c(3:5)], na.rm =TRUE)/sum(tableit[tableit$eel_cou_code=='OVERALL TOTAL',c(3:5)]),1)` of the total landings (Table @tbl-tableit).

The importance of landings in missing countries from EU, that have reported landings otherwise is illustrated in Figure @fig-landingsnoreport. Landings in Slovenia (Sl) are almost inexistent.

```{r }
#| label: fig-landingsnoreport
#| fig-height: 6.3
#| fig-width: 6.3
#| fig-cap: "Trends in landings (commercial + recreational) per emu for EU countries which did not report stock indicators."
landings <- dbGetQuery(con, paste0(
  "select sum(eel_value) eel_value,eel_cou_code,eel_lfs_code,eel_year from datawg.t_eelstock_eel
                      where eel_cou_code in ('",
  paste(not_reported[not_reported %in% eu_cou_codes], collapse = "','"),
  "')
                      and eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2010
                      group by eel_cou_code,eel_lfs_code,eel_year"
))
g1 <- ggplot(landings, aes(x = eel_year, y = eel_value/1000)) +
  geom_line(show.legend = FALSE) +
  facet_grid(eel_lfs_code ~ eel_cou_code, scale="free") +
  ylab("landings (t)") +
  xlab("") +
  theme_bw() 

ggsave(g1, filename = file.path(params$image_path,"landings.png"), height = 16 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"landings.png"))
```


## Indicators reports




## Data availability


The following table (Table @tbl-lastreportbiom) provide checks for the latest reported value per EMU, values in grey in column country and emu indicate that probably values where not reported for that EMU. 

```{r }
#| label: tbl-lastreportbiom
#| tbl-cap: "Table showing when the biomass indicator was last reported, emus for which bcurrent was not reported during this datacall are in grey, the absence of date indicates that the data was reported as NP or NC"

knitr::kable(data.frame())
```

```{r }
#| label: flextablelastreportsuma
biomass |>
    filter(eel_typ_id %in% c(14, 15, 34)) |>
    filter(!is.na(eel_value)) |>
    select(-eel_value) |>
    group_by(eel_cou_code, eel_emu_nameshort, eel_typ_id) |>
    summarise(eel_year = max(eel_year))|> 
     ungroup() |>    
    mutate(eel_typ_id = case_match(
      eel_typ_id,
      15 ~ "bcurrent",
      14 ~ "bbest",
      34 ~ "bcurrentw"    
    )) |>
  select(eel_cou_code, eel_year, eel_emu_nameshort, eel_typ_id)|> 
  pivot_wider(names_from = eel_typ_id, values_from = eel_year)|>
  rename("country"="eel_cou_code", "emu"="eel_emu_nameshort") |>
  select(country,emu, bcurrent, bcurrentw, bbest) |>
  flextable() |>
  flextable2ICES() |>
  flextable::colformat_num(j = c( "bcurrent", "bcurrentw", "bbest"), big.mark = "")|>
  bg(i=~`bcurrent`<=2020, j= c("country", "emu"),bg="grey") 
  
```


The following figures summarize the mortality and biomass indicators that were provided as a response to the ICES data call. Maps showings data availability. The symbol indicates whether the country have provided estimates for at least one (whatever year), two , three distinct indicators. There is a high variability among the indicators reported by the countries (Figure XX):

-   North African countries (Morocco, Algeria, Tunisia, Libya) and the Middle East have mostly no indicators
-   The highest concentration of points with multiple indicators (2-4) is in Western and Central Europe.
-   The United Kingdom and some EMUs of Spain and France show a high share with 4 indicators.
-   There is a mixed distribution in Italy and the Balkans, with areas having between 1 and 3 indicators
-   The Nordic and Baltic countries also show a varied participation.





```{r }
#| label: fig-bcurrent
#| fig-height: 6
#| fig-width: 9
#| fig-cap : "Availability of $B_{current}$ reports indicators from 2006 to 2023"

indicator_vis <- expand.grid(eel_emu_nameshort = unique(indicator$eel_emu_nameshort),
                             eel_year = seq(2006, 2023, by = 1)) |>
                                        left_join(indicator |> select(eel_emu_nameshort, sumh, sumf, suma, bcurrent, bcurrentw, bbest, b0, eel_year), by = c("eel_emu_nameshort" = "eel_emu_nameshort", "eel_year" = "eel_year"))


indicator_vis <- indicator_vis |> left_join(
  indicator_vis |> 
select(eel_emu_nameshort) |>
distinct() |>
mutate(firstletter = substring(eel_emu_nameshort,1,1),
       rank=rank(firstletter),
       istable1=rank/max(rank)<=0.5) |> 
       select(eel_emu_nameshort,istable1)
       ) 

g2 <- ggplot(indicator_vis |> 
  filter(istable1) |>
  select(eel_emu_nameshort, eel_year, bcurrent) |> 
  mutate(bcurrent = ifelse(is.na(bcurrent), "absent", "present")), 
  aes(eel_emu_nameshort, eel_year, fill = bcurrent))+
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression("B"["current"]))
ggsave(g2, , filename = file.path(params$image_path,"bcurrent_part1.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"bcurrent_part1.png"))  
g2 <- ggplot(indicator_vis |> 
  filter(!istable1) |>
  select(eel_emu_nameshort, eel_year, bcurrent) |> 
  mutate(bcurrent = ifelse(is.na(bcurrent), "absent", "present")), 
  aes(eel_emu_nameshort, eel_year, fill = bcurrent))+
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression("B"["current"]))
ggsave(g2, , filename = file.path(params$image_path,"bcurrent_part2.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"bcurrent_part2.png"))  
```

```{r }
#| label: fig-bcurrentw
#| fig-cap : "Availability of $B_{currentw}$ reports indicators from 2006 to 2023"

g3 <- ggplot(indicator_vis |>
  filter(istable1) |>
  select(eel_emu_nameshort, eel_year, bcurrentw) |>
  mutate(bcurrentw = ifelse(is.na(bcurrentw), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = bcurrentw)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste("B"["current without restocking"])))
ggsave(g3, filename = file.path(params$image_path,"bcurrentw_part1.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"bcurrentw_part1.png"))  

g3 <- ggplot(indicator_vis |>
  filter(!istable1) |>
  select(eel_emu_nameshort, eel_year, bcurrentw) |>
  mutate(bcurrentw = ifelse(is.na(bcurrentw), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = bcurrentw)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste("B"["current without restocking"])))
ggsave(g3, filename = file.path(params$image_path,"bcurrentw_part2.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"bcurrentw_part2.png"))  
```

```{r }
#| label: fig-bbest
#| fig-cap: "Availability of $B_{best}$ reports indicators from 2006 to 2023"
g4 <- ggplot(indicator_vis |>
 filter(istable1) |>
 select(eel_emu_nameshort, eel_year, bbest) |>
  mutate(bbest = ifelse(is.na(bbest), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = bbest)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste("B"["best"])))
ggsave(g4, filename = file.path(params$image_path,"bbest_part1.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"bbest_part1.png"))  

g4 <- ggplot(indicator_vis |>
 filter(!istable1) |>
 select(eel_emu_nameshort, eel_year, bbest) |>
  mutate(bbest = ifelse(is.na(bbest), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = bbest)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste("B"["best"])))
ggsave(g4, filename = file.path(params$image_path,"bbest_part2.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"bbest_part2.png")) 
```

```{r }
#| label: fig-suma
#| fig-cap : "$\\sum{A}$ availability from 2006 to 2023"
g5 <- ggplot(indicator_vis |> 
     filter(istable1) |> 
   select(eel_emu_nameshort, eel_year, suma) |>
  mutate(suma = ifelse(is.na(suma), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = suma)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste(Sigma," A")))
ggsave(g5, filename = file.path(params$image_path,"suma_part1.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"suma_part1.png")) 

g5 <- ggplot(indicator_vis |> 
     filter(!istable1) |> 
   select(eel_emu_nameshort, eel_year, suma) |>
  mutate(suma = ifelse(is.na(suma), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = suma)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste(Sigma," A")))
ggsave(g5, filename = file.path(params$image_path,"suma_part2.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"suma_part2.png"))  
```

```{r }
#| label: fig-sumf
#| fig-cap :  "$\\sum{F}$ availability per EMU from 2006 to 2023"

g6 <- ggplot(indicator_vis |> 
  filter(istable1) |> 
  select(eel_emu_nameshort, eel_year, sumf) |>
  mutate(sumf = ifelse(is.na(sumf), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = sumf)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste(Sigma," F")))
ggsave(g6, filename = file.path(params$image_path,"sumf_part1.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"sumf_part1.png"))
g6 <- ggplot(indicator_vis |> 
  filter(!istable1) |> 
  select(eel_emu_nameshort, eel_year, sumf) |>
  mutate(sumf = ifelse(is.na(sumf), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = sumf)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste(Sigma," F")))
ggsave(g6, filename = file.path(params$image_path,"sumf_part2.png"), height = 10 / 2.54, width = 16 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"sumf_part2.png"))   
```

```{r }
#| label: fig-sumh
#| fig-cap : "$\\sum{A}$ availability per EMU from 2006 to 2023"
g7 <- ggplot(indicator_vis |> 
  filter(istable1) |> 
  select(eel_emu_nameshort, eel_year, sumh) |>
  mutate(sumh = ifelse(is.na(sumh), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = sumh)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
    ggtitle(expression(paste(Sigma," H")))
ggsave(g7, filename = file.path(params$image_path,"sumh_part1.png"), height = 10 / 2.54, width = 20 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"sumh_part1.png"))

g7 <- ggplot(indicator_vis |> 
  filter(!istable1) |> 
  select(eel_emu_nameshort, eel_year, sumh) |>
  mutate(sumh = ifelse(is.na(sumh), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = sumh)) +
  geom_tile() +
  scale_fill_manual(values=c("black", "#b7d1c3"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
    ggtitle(expression(paste(Sigma," H")))
ggsave(g7, filename = file.path(params$image_path,"sumh_part2.png"), height = 10 / 2.54, width = 20 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"sumh_part2.png"))


```



```{r }
#| label: fig-mapbiomassavail
#| fig-height: 8
#| fig-width: 8
#| fig-cap: "Biomass indicators ($B_{current}$, $B_{best}$, $B_0$) provided in each EMU. The colour of the points indicates the number of distinct indicators for which estimates were provided (for at least for one year out of all reported years). Where countries report mortality as non-pertinent (NP), this is treated as a reported indicator of zero."
data_avail <- rbind.data.frame(mortality, biomass) |>
  filter(!(is.na(eel_value) & eel_missvaluequal != "NP")) |>
  group_by(eel_emu_nameshort) |>
  summarize(
    b0 = sum(eel_typ_id == 13) > 0,
    bbest = sum(eel_typ_id == 14) > 0,
    bcurrent = sum(eel_typ_id == 15) > 0,
    bcurrentw = sum(eel_typ_id == 34) > 0,
    suma = sum(eel_typ_id == 17) > 0,
    sumf = sum(eel_typ_id == 18) > 0,
    sumh = sum(eel_typ_id == 19) > 0
  ) |>
  mutate(eel_emu_nameshort = ifelse(eel_emu_nameshort == "NL_total", "NL_Neth", eel_emu_nameshort))
data_avail <- merge(emu_c, data_avail, by.x = "emu_nameshort", by.y = "eel_emu_nameshort", all.x = TRUE)
data_avail <- st_transform(data_avail, crs = 3035)
data_avail$x <- st_coordinates(data_avail)[, 1]
data_avail$y <- st_coordinates(data_avail)[, 2]
data_avail$x[data_avail$emu_cou_code == "NO"] <- 4172612.3
data_avail$y[data_avail$emu_cou_code == "NO"] <- 4111023.3
data_avail <- data_avail |>
  mutate(
    bsummary = coalesce(b0 + bbest + bcurrent + bcurrentw, 0),
    mortsummary = coalesce(suma + sumf + sumh, 0),
    Reported = ifelse(is.na(bsummary) & is.na(mortsummary), FALSE, TRUE)
  )


g8 <- ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail, aes(x = x, y = y, fill = as.factor(bsummary)), shape = 21, cex=2.5) +
  scale_fill_manual("Biomass indicators", 
                    labels = c("none", "one", "two", "three", "four"), 
                    values = c("grey", "yellow","orange","red","purple")) +
  xlab("") +
  ylab("") +
  theme(legend.position = "bottom")
ggsave(g8, filename = file.path(params$image_path,"biom.png"), height = 14 / 2.54, width = 14 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"biom.png"))
```


```{r }
#| label: fig-mapbiomassdetail
#| fig-height: 10
#| fig-width: 10
#| fig-cap: "Review of biomass indicators that have been reported per EMUS: $B_0$ (top left; $B_{best}$ (top right); $B_{current}$ (bottom left) and $B_{current without stocking}$ (bottom right). Blue: TRUE (Reported), red: FALSE (Not Reported) EMU where no indicators have been reported are not plotted"
# Each biomass indicator:
data_avail_ind <- data_avail |>
  gather(Bindicator, Reported, 5:8) |>
  filter(!is.na(Reported))

## Biomass

g9 <- ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail_ind, aes(x = x, y = y, fill = Reported),  shape = 21, cex=2.5) +
  scale_fill_manual("Reported", labels = c("FALSE", "TRUE", "NA"), values = c("red", "blue", "grey")) +
  xlab("") +
  ylab("") +
  facet_wrap(~Bindicator) +
  theme(legend.position = "bottom")
ggsave(g9, filename = file.path(params$image_path,"biom_avail.png"), height = 14 / 2.54, width = 14 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"biom_avail.png"))
```

## Map comparing the ratio between $B_{current}$ and $B_0$

```{r }
#| label: fig-biomassmapbcurrentoverb0
#| fig-cap: "Map of biomass indicators per EMU (average from 2021 to 2023). The size of the circle is proportional to $B_{current}$ while the colour is indicative of the ratio between $B_{current}$ and $B_0$. A cross indicates that no data was reported. When $B_0$ is not available (only $B_{current}$), the circle is grey (e.g. Sweden, the Baltic). Here, reported $B_0$ were used."


g10 <- ggplot(st_transform(country_p, 3035)) +
  geom_sf(fill = NA, size = .1) +
  theme_bw() +
  geom_arc_bar(data = avgindicator, aes(
    x0 = x, y0 = y, r0 = 0, r = bcurrent, start = 0,
    end = 2 * pi, fill = bscaled
  ), col = NA, alpha = 1) +
  xlab("") +
  ylab("") +
  geom_arc_bar(data = scalesb, aes(
    x0 = 3008000, y0 = 4200000, r0 = 0, r = bscale, start = pi,
    end = 2 * pi
  ), fill = NA, col = "black") +
  geom_text(
    data = scalesb, aes(x = 3050000, y = 4200000 + bscale, label = paste0(b / 1e3, "t")),
    size = 2, hjust = "left"
  ) +
  geom_point(
    data = avgindicator |>
      filter(is.na(bcurrent)),
    aes(x = x, y = y), pch = "x"
  ) +
  scale_fill_viridis_c(expression(B[current] / B[0]))
# scale_alpha_manual("",values=c("B0" = 1,
#                        "Bcurrent" = .6,
#                        "Bbest"= .6,
#                        "Btarget" = .6,
#                        "sumF" = 1,
#                        "sumA" = 1))
ggsave(g10, filename = file.path(params$image_path,"biomassmapbcurrentoverb0.png"), height = 14 / 2.54, width = 14 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"biomassmapbcurrentoverb0.png"))

```

```{r }
#| label: fig-bcurrentwithoutstockinmap
#| fig.cap: "Map of mortality indicators per EMU (average from 2021 to 2023). The size of the circle is proportional to $B_{current without stocking}$ while the colour is indicative of the ratio between $B_{current without stocking}$ and $B_0$. A cross indicates that no data was reported. When $B_0$ is not available (only $B_{current}$), the circle is grey (e.g. Sweden, the Baltic). Here, reported B0 were used."

g11 <- ggplot(st_transform(country_p, 3035)) +
  geom_sf(fill = NA, size = .1) +
    theme_bw() +  
  geom_arc_bar(data = avgindicator, aes(
    x0 = x, y0 = y, r0 = 0, r = bcurrentw, start = 0,
    end = 2 * pi, fill = bcurrentwscaled
  ), col = NA, alpha = 1) +
  xlab("") +
  ylab("") +
  geom_arc_bar(data = scalesb_norestock, aes(
    x0 = 3008000, y0 = 4200000, r0 = 0, r = bscale, start = pi,
    end = 2 * pi
  ), fill = NA, col = "black") +
  geom_text(
    data = scalesb_norestock, aes(x = 3050000, y = 4200000 + bscale, label = paste0(b / 1e3, "t")),
    size = 2, hjust = "left"
  ) +
  geom_point(
    data = avgindicator |>
      filter(is.na(bcurrentw)),
    aes(x = x, y = y), pch = "x"
  ) +
  scale_fill_viridis_c(expression(B[currentw] / B[0]))

ggsave(g11, filename = file.path(params$image_path,"maps_biomass_norestock.png"), height = 14 / 2.54, width = 14 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"maps_biomass_norestock.png"))
```




# Mortality



## Data availability

The following table (Table @tbl-lastreportmort) provide checks for the latest reported value per EMU, values in grey in column country and emu indicate that probably values where not reported for that EMU. 
```{r }
#| label: tbl-lastreportmort
#| tbl-cap: "Table showing when the mortality indicator was last reported, emus for which bcurrent was not reported during this datacall are in grey, the absence of date indicates that the data was reported as NP or NC"

knitr::kable(data.frame())
```

```{r }
#| label: flextablelastreportmort
mortality |>
    filter(eel_typ_id %in% c( 17, 18, 19)) |>
    filter(!is.na(eel_value)) |>
    select(-eel_value) |>
    group_by(eel_cou_code, eel_emu_nameshort, eel_typ_id) |>
    summarise(eel_year = max(eel_year))|> 
     ungroup() |>    
    mutate(eel_typ_id = case_match(
      eel_typ_id,      
      17 ~ "sumA",
      18 ~ "sumF",
      19 ~ "sumH"
    )) |>
  select(eel_cou_code, eel_year, eel_emu_nameshort, eel_typ_id)|> 
  pivot_wider(names_from = eel_typ_id, values_from = eel_year)|>
  rename("country"="eel_cou_code", "emu"="eel_emu_nameshort") |>
  select(country,emu, sumF, sumH, sumA) |>
  flextable() |>
  flextable2ICES() |>
  flextable::colformat_num(j = c( "sumA", "sumF", "sumH"), big.mark = "")|>
  bg(i=~`sumF`<=2020, j= c("country", "emu"),bg="grey") 
  
```

```{r }
#| label: fig-indicatorsmapsmortality
#| fig-height: 8
#| fig-width: 12
#| fig-cap: "Review of  Mortality indicators provided in each EMU. $\\sum{A}$: total anthropogenic mortality, $\\sum{F}$: fishery mortality,  $\\sum{H}$: hydropower mortality. Blue: true (Reported), Red: false (Not Reported) Grey NA (Not Available/Not Applicable)."



data_avail_ind <- data_avail |>
  gather(Mindicator, Reported, 9:11) |>
  filter(!is.na(Reported))


g12 <- ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail_ind, aes(x = x, y = y, fill = Reported), shape = 21, cex=2.5) +
  scale_fill_manual("Reported", labels = c("FALSE", "TRUE", "NA"), values = c("red", "blue", "grey")) +
  xlab("") +
  ylab("") +
  facet_wrap(~Mindicator)
ggsave(g12, filename = file.path(params$image_path,"indicatorsmapsmortality.png"), height = 10 / 2.54, width = 20 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"indicatorsmapsmortality.png"))
```


## Map of mortality indicators


```{r }
#| label: fig-mortalitymap
#| fig-cap: "Maps of mortality indicators per EMU (average after 2018). The size of the circle reflects the magnitude of $\\sum{A}$ while the colour illustrates the ratio between $\\sum{F}$ and $\\sum{A}$. A cross indicates that $\\sum{A}$ or both $\\sum{F}$ and $\\sum{A}$ are missing." 

# indicator <- dbGetQuery(con, "select eel_cou_code,eel_emu_nameshort, avg(b0) b0,avg (bbest) bbest,avg(bcurrent) bcurrent, avg(suma) suma,avg(sumf) sumf,avg(sumh) sumh from datawg.precodata_emu where eel_year>=2018 group by eel_cou_code,eel_emu_nameshort") |>
#   mutate(eel_emu_nameshort = ifelse(eel_cou_code == "NL", "NL_Neth", eel_emu_nameshort))
# indicator <- merge(emu_c, indicator, by.x = "emu_nameshort", by.y = "eel_emu_nameshort", all.x = TRUE)
# indicator <- st_transform(indicator, crs = 3035)
# indicator$x <- st_coordinates(indicator)[, 1]
# indicator$y <- st_coordinates(indicator)[, 2]
# indicator$btarget <- .4 * indicator$b0
# indicator$bscaled <- indicator$bcurrent / indicator$b0
# indicator$x[indicator$eel_cou_code == "NO"] <- 4172612.3
# indicator$y[indicator$eel_cou_code == "NO"] <- 4111023.3
# # indicator$bcurrent <- log(indicator$bcurrent)/log(max(indicator$b0,na.rm=TRUE))*100000
# # indicator$bbest <- log(indicator$bbest)/log(max(indicator$b0,na.rm=TRUE))*100000
# # indicator$b0 <- log(indicator$b0)/log(max(indicator$b0,na.rm=TRUE))*100000
# # indicator$suma <- indicator$suma /.92*40000
# # indicator$sumf <- indicator$sumf /.92*40000
# # indicator$sumh <- indicator$sumh /.92*40000
prettyscale <- c(0, .92)
prettyscale_scaled <- scales::rescale(prettyscale, to = c(40000, 200000), 
from = c(0, max(indicator$suma, na.rm = TRUE)))

indicator$sumfsuma <- indicator$sumf / indicator$suma
indicator$suma <- scales::rescale(indicator$suma, to = c(40000, 200000), 
from = c(0, max(indicator$suma, na.rm = TRUE)))

scalesm <- data.frame(m = prettyscale, mscale = prettyscale_scaled, y0 = c(4200000, 4400000))
legend <- data.frame(indicator = c("sumA", "sumF"))

g14 <- ggplot(st_transform(country_p, 3035)) +
  geom_sf(fill = NA, size = .1) +
  theme_bw() +
  geom_arc_bar(data = avgindicator, aes(
    x0 = x, y0 = y, r0 = 0, r = suma, start = 0,
    end = 2 * pi, fill = sumfsuma
  ), size = .2, col = NA) +
  # geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = sumf, start = 0,
  #                  end = 2*pi ),size=.2,fill=NA,col="yellow")+
  xlab("") +
  ylab("") +
  geom_point(
    data = avgindicator |>
      filter(is.na(suma) & is.na(sumf)),
    aes(x = x, y = y), pch = "x"
  ) +
  # geom_arc_bar(data=scalesb,aes(x0 = 3008000, y0 =3800000, r0 = 0, r = 40000, start =0,
  # end = pi),linewidth=.2, fill = NA,col="black")+
  geom_arc_bar(data = scalesm, aes(
    x0 = 3008000, y0 = y0, r0 = 0, r = mscale, start = 0,
    end = pi
  ), fill = NA, col = "black") +
  geom_text(
    data = scalesm, aes(x = 3000000, y = y0 + mscale, label = paste0(m, "~lifetime^{-1}")),
    size = 1, hjust = "right", parse = TRUE
  ) +
  #    geom_rect(data=legend,aes(col=indicator,xmin=0,ymin=0,xmax=0,ymax=0),fill=NA)+

  # scale_color_manual("",values=c("sumF" = "yellow",
  #                      "sumA" = "blue"))
  scale_fill_viridis_c(expression(paste(Sigma, "F") / paste(Sigma, "A")))

ggsave(g14, filename = file.path(params$image_path,"maps_mortality.png"), height = 10 / 2.54, width = 20 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"maps_mortality.png"))

```

```{r }
#| label: fig-mortalitymap2
#| fig-cap: "Maps of mortality indicators per EMU (average after 2018). The size of the circle reflects the magnitude of $\\sum{A}$ while the colour illustrates the ratio between $\\sum{H}$ and $\\sum{A}$. A cross indicates that $\\sum{A}$ or both $\\sum{H}$ and $\\sum{A}$ are missing." 

prettyscale <- c(0, .92)
prettyscale_scaled <- scales::rescale(prettyscale, to = c(40000, 200000), 
from = c(0, max(indicator$suma, na.rm = TRUE)))

indicator$sumhsuma <- indicator$sumh / indicator$suma
indicator$suma <- scales::rescale(indicator$suma, to = c(40000, 200000), 
from = c(0, max(indicator$suma, na.rm = TRUE)))

scalesm <- data.frame(m = prettyscale, mscale = prettyscale_scaled, y0 = c(4200000, 4400000))
legend <- data.frame(indicator = c("sumA", "sumH"))

g14 <- ggplot(st_transform(country_p, 3035)) +
  geom_sf(fill = NA, size = .1) +
  theme_bw() +
  geom_arc_bar(data = avgindicator, aes(
    x0 = x, y0 = y, r0 = 0, r = suma, start = 0,
    end = 2 * pi, fill = sumhsuma
  ), size = .2, col = NA) +
  # geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = sumf, start = 0,
  #                  end = 2*pi ),size=.2,fill=NA,col="yellow")+
  xlab("") +
  ylab("") +
  geom_point(
    data = avgindicator |>
      filter( is.na(sumh)),
    aes(x = x, y = y), pch = "x"
  ) +
  # geom_arc_bar(data=scalesb,aes(x0 = 3008000, y0 =3800000, r0 = 0, r = 40000, start =0,
  # end = pi),linewidth=.2, fill = NA,col="black")+
  geom_arc_bar(data = scalesm, aes(
    x0 = 3008000, y0 = y0, r0 = 0, r = mscale, start = 0,
    end = pi
  ), fill = NA, col = "black") +
  geom_text(
    data = scalesm, aes(x = 3000000, y = y0 + mscale, label = paste0(m, "~lifetime^{-1}")),
    size = 1, hjust = "right", parse = TRUE
  ) +
  #    geom_rect(data=legend,aes(col=indicator,xmin=0,ymin=0,xmax=0,ymax=0),fill=NA)+

  # scale_color_manual("",values=c("sumF" = "yellow",
  #                      "sumA" = "blue"))
  scale_fill_viridis_c(expression(paste(Sigma, "H") / paste(Sigma, "A")))

ggsave(g14, filename = file.path(params$image_path,"maps_mortalityh.png"), height = 10 / 2.54, width = 20 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"maps_mortalityh.png"))

```


# Habitat coverage

Unkile in the previous datacall, when data was collected per habitat, now stock indicators are only reported at the EMU scale, and only apply to Silver eel. However, to convey the importance of different habitats, during the datacall, each EMU reported data on habitat coverage within indicator. For the different habitats, MO marine open, T transitional, C coastal and F Freswater, the amount of habitat covered by indicator (mortality $\sum{F}$, $\sum{H}$, and biomass $B_{current}$, $B_{best}$ ... For all biomass indicators taken together, and for all mortality indicators taken together, the percentage of EMUs whose indicator estimate covers either 0% or 100% of a given habitat type is calculated (Table @tbl-habitatcoverage). This relies on data providers correctly filling in that habitat coverage for a given indicator is `NP/-1` when that habitat is not present in the EMU, and only fill in a cover of 0% when the habitat is present in the EMU, but not assessed.

```{r }
#| label: tbl-habitatcoverage
#| tbl-cap: "Table showing frequency of when an habitat coverage is reported as 0 or 100 % for the different habitats (F Freshwater, C Coastal, T transitional, MO Marine Open)"
knitr::kable(data.frame())
```


```{r }
#| label: flextablehabitatcoverage
biomass <- dbGetQuery(con, "select * from datawg.t_eelstock_eel e  left join datawg.t_eelstock_eel_percent on eel_id=percent_id where eel_qal_id=1 and eel_typ_id in (13,14,15,34)")

mortality <- dbGetQuery(con, "select * from datawg.t_eelstock_eel e left join datawg.t_eelstock_eel_percent on eel_id=percent_id where eel_qal_id=1 and eel_typ_id in (17,18,19)")



biomass_long <- biomass |>
  filter(!is.na(eel_value)) |>
  select(eel_year, eel_typ_id, eel_cou_code, eel_emu_nameshort, perc_mo, perc_f, perc_c, perc_t) |>
  pivot_longer(
    cols = c(perc_mo, perc_f, perc_t, perc_c),
    names_to = "habitat", values_to = "perc"
  ) |>
  mutate(habitat = toupper(gsub("perc_", "", habitat))) |>
  mutate(
    type = "biomass",
    eel_typ_id = case_when(eel_typ_id == 13 ~ "B0", eel_typ_id == 14 ~ "Bbest", eel_typ_id == 15 ~ "Bcurrent", eel_typ_id == 34 ~ "Bcurrentwithoutrestocking")
  )

overview_biom_type_perc <- table(biomass_long$eel_typ_id, biomass_long$perc)
#unique(biomass_long$eel_emu_nameshort)
# filter(biomass_long, str_sub(biomass_long$eel_emu_nameshort, 4, 8)=="total")
# filter(biomass_long, biomass_long$eel_cou_code=="LV")


mortality_long <- mortality |>
  filter(!is.na(eel_value)) |>
  select(eel_year, eel_typ_id, eel_emu_nameshort, perc_mo, perc_f, perc_c, perc_t) |>
  pivot_longer(
    cols = c(perc_mo, perc_f, perc_t, perc_c),
    names_to = "habitat", values_to = "perc"
  ) |>
  mutate(habitat = toupper(gsub("perc_", "", habitat))) |>
  mutate(
    type = "mortality",
    eel_typ_id = case_when(
      eel_typ_id == 17 ~ "sumA",
      eel_typ_id == 18 ~ "sumF",
      eel_typ_id == 19 ~ "sumH"
    )
  )
overview_mortality_long_perc <- table(mortality_long$eel_typ_id, mortality_long$perc)
indicatorflex <- biomass_long |>
  bind_rows(mortality_long) |>
  filter(perc >= 0)

#mortality_long |> filter(perc>0 & perc <100)

flextable(indicatorflex |>
  group_by(type, habitat) |>
  summarize(
    freq100 = round(sum(perc == 100) / n() * 100),
    freq0 = round(sum(perc == 0) / n() * 100)
  ) |>
  pivot_wider(names_from = habitat, values_from = c(freq0, freq100))) |>
   flextable2ICES() 
```
Marine open and coastal waters are rarely accounted for in indicator estimates. Some fresh and transitional waters not accounted for.

Marine open and coastal waters are rarely accounted for an indicator estimates. Some fresh and transitional waters also are not accounted for.

::: {custom-style="Annex heading"}
List of data reported to the datacall
:::


```{r }
#| label: table_report


fn_report_cou <- function(
    eel_typ_id.,
    eel_qal_id. = as.integer(c(1, 2, 4)),
    nameannex.,
    minyear. = 2010) {
    dbGetQuery(
        con,
        glue::glue_sql(
"with ind as (SELECT
eel_cou_code,
{nameannex} AS annex,
2024 AS datacall,
count(*) AS reported,
sum(case when eel_value IS NOT NULL then 1 else 0 end) AS number,
sum(case when eel_missvaluequal= 'NC' then 1 else 0 end) AS NC,
sum(case when eel_missvaluequal= 'NP' then 1 else 0 end) AS NP,
sum(case when eel_missvaluequal= 'NR' then 1 else 0 end) AS NR
FROM datawg.t_eelstock_eel
where eel_typ_id in ({eel_typ_id*})
AND eel_qal_id IN ({eel_qal_id*})
AND eel_year > {minyear}
and eel_datasource = 'dc_2024'
GROUP BY eel_cou_code
UNION
SELECT
eel_cou_code,
{nameannex} AS annex,
2025 AS datacall,
count(*) AS reported,
sum(case when eel_value IS NOT NULL then 1 else 0 end) AS number,
sum(case when eel_missvaluequal= 'NC' then 1 else 0 end) AS NC,
sum(case when eel_missvaluequal= 'NP' then 1 else 0 end) AS NP,
sum(case when eel_missvaluequal= 'NR' then 1 else 0 end) AS NR
FROM datawg.t_eelstock_eel
where eel_typ_id in ({eel_typ_id*})
AND eel_qal_id IN ({eel_qal_id*})
AND eel_year > {minyear}
and eel_datasource = 'wkemp_2025'
GROUP BY eel_cou_code
UNION
SELECT
eel_cou_code,
{nameannex} AS annex,
2021 AS datacall,
count(*) AS reported,
sum(case when eel_value IS NOT NULL then 1 else 0 end) AS number,
sum(case when eel_missvaluequal= 'NC' then 1 else 0 end) AS NC,
sum(case when eel_missvaluequal= 'NP' then 1 else 0 end) AS NP,
sum(case when eel_missvaluequal= 'NR' then 1 else 0 end) AS NR
FROM datawg.t_eelstock_eel
where eel_typ_id in ({eel_typ_id*})
AND eel_qal_id IN ({eel_qal_id*})
AND eel_year > {minyear}
and eel_datasource = 'dc_2021'
GROUP BY eel_cou_code)
SELECT * FROM ind order by eel_cou_code,annex,datacall
",
            eel_typ_id = eel_typ_id.,
            eel_qal_id = eel_qal_id.,
            nameannex = nameannex.,
            minyear = minyear., .con = con
        )
    )
}

fn_report_emu <- function(
    eel_typ_id.,
    eel_qal_id. = as.integer(c(1, 2, 4)),
    nameannex.,
    minyear. = 2010) {
    dbGetQuery(
        con,
        glue::glue_sql(
"with ind as (SELECT
eel_emu_nameshort,
{nameannex} AS annex,
2024 AS datacall,
count(*) AS reported,
sum(case when eel_value IS NOT NULL then 1 else 0 end) AS number,
sum(case when eel_missvaluequal= 'NC' then 1 else 0 end) AS NC,
sum(case when eel_missvaluequal= 'NP' then 1 else 0 end) AS NP,
sum(case when eel_missvaluequal= 'NR' then 1 else 0 end) AS NR
FROM datawg.t_eelstock_eel
where eel_typ_id in ({eel_typ_id*})
AND eel_qal_id IN ({eel_qal_id*})
AND eel_year > {minyear}
and eel_datasource = 'dc_2024'
GROUP BY eel_emu_nameshort
UNION
SELECT
eel_emu_nameshort,
{nameannex} AS annex,
2025 AS datacall,
count(*) AS reported,
sum(case when eel_value IS NOT NULL then 1 else 0 end) AS number,
sum(case when eel_missvaluequal= 'NC' then 1 else 0 end) AS NC,
sum(case when eel_missvaluequal= 'NP' then 1 else 0 end) AS NP,
sum(case when eel_missvaluequal= 'NR' then 1 else 0 end) AS NR
FROM datawg.t_eelstock_eel
where eel_typ_id in ({eel_typ_id*})
AND eel_qal_id IN ({eel_qal_id*})
AND eel_year > {minyear}
and eel_datasource = 'wkemp_2025'
GROUP BY eel_emu_nameshort
UNION
SELECT
eel_emu_nameshort,
{nameannex} AS annex,
2021 AS datacall,
count(*) AS reported,
sum(case when eel_value IS NOT NULL then 1 else 0 end) AS number,
sum(case when eel_missvaluequal= 'NC' then 1 else 0 end) AS NC,
sum(case when eel_missvaluequal= 'NP' then 1 else 0 end) AS NP,
sum(case when eel_missvaluequal= 'NR' then 1 else 0 end) AS NR
FROM datawg.t_eelstock_eel
where eel_typ_id in ({eel_typ_id*})
AND eel_qal_id IN ({eel_qal_id*})
AND eel_year > {minyear}
and eel_datasource = 'dc_2021'
GROUP BY eel_emu_nameshort)
SELECT * FROM ind order by eel_emu_nameshort,annex,datacall
",
            eel_typ_id = eel_typ_id.,
            eel_qal_id = eel_qal_id.,
            nameannex = nameannex.,
            minyear = minyear., .con = con
        )
    )
}



```

```{r }
#| label: tbl-reported_biomass
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Number of biomass indicator reported per country (reported), either with a numeric value (number) or as 'NC' not collected, 'NP' not pertinent, 'NR' not reported. The report is split per annex type (annex) and country."

 knitr::kable(data.frame())
```


```{r}
#| label: flextablereportedbiom
annex. = "biomass"
dc2025cou <- bind_rows(
    fn_report_cou(
        eel_typ_id. = as.integer(c(13, 14, 15, 34)),
        nameannex = "biomass"
    ),
    fn_report_cou(
        eel_typ_id. = as.integer(c(17,18,19)),
        nameannex = "mortality"
    ),    
    fn_report_cou(
        eel_typ_id. = as.integer(c(4,6)),
        nameannex = "landings"
    ),    
    fn_report_cou(
        eel_typ_id. = as.integer(c(8,9,10)),
        nameannex = "restocking"
    )
) |> pivot_wider(id_cols=c("eel_cou_code",annex),
                  names_from="datacall",
                  values_from=c("reported","number","nc","np","nr"),
                  names_sort=TRUE) |>
                  rename(country=eel_cou_code)
write.csv2(dc2025cou, file=file.path(params$data_path, "annex4_11_reported_per_country.csv"))
 
dc2025cou |> filter(annex == annex.)  |>
    flextable() |>
    flextable2ICES()     
```

```{r }
#| label: tbl-reported_mortality
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Number of mortality indicator reported per country (reported), either with a numeric value (number) or as 'NC' not collected, 'NP' not pertinent, 'NR' not reported. The report is split per annex type (annex) and country."

 knitr::kable(data.frame())
```


```{r}
#| label: flextablereportedmort
annex. = "mortality" 
dc2025cou |> filter(annex == annex.)  |>
    flextable() |>
    flextable2ICES()     
```

```{r }
#| label: tbl-reported_landings
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Number of landings indicator reported per country (reported), either with a numeric value (number) or as 'NC' not collected, 'NP' not pertinent, 'NR' not reported. The report is split per annex type (annex) and country."

 knitr::kable(data.frame())
```


```{r}
#| label: flextablereportedland
annex. = "landings" 
dc2025cou |> filter(annex == annex.)  |>
    flextable() |>
    flextable2ICES()     
```

```{r }
#| label: tbl-reported_restocking
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Number of restocking indicator reported per country (reported), either with a numeric value (number) or as 'NC' not collected, 'NP' not pertinent, 'NR' not reported. The report is split per annex type (annex) and country."

 knitr::kable(data.frame())
```


```{r}
#| label: flextablereportedrest
annex. = "restocking" 
dc2025cou |> filter(annex == annex.)  |>
    flextable() |>
    flextable2ICES()     
```


::: {custom-style="Annex heading"}
Data quality check
:::

The data call has been done in two steps. After the first data call, wgeel and wkemp have analysed data and asked for clarifications. This part only reports data after the integration of new data in february 2025.

## $B_{best}$ larger than $B_0$

A first check consisted of comparing $B_{best}$ and $B_0$ (Table 3 2): both indicators refer to the escapement that would occur in the absence of any anthropogenic pressures, but $B_{best}$ corresponds to the escapement with the current recruitment while $B_0$ corresponds to the escapement produced with a pristine recruitment. Given the decrease in recruitment since the early 1980s, $B_{best}$ should be less than $B_0$. In a few situations, $B_{best}$ is greather than $B_0$ (Fig. @fig-Bbestb0): DE_Warn, EE_Narv, EE_total, ES_Minh, GB_Neag, GB_Scot, GR_CeAe, GR_WePe, PL_Oder, SE_Inla (table @tbl-tabbestb0). For SE_Inla, $B_{best}$ estimates are greater than $B_0$ during the late 80s / early 90s, suggesting that $B_0$ might be based on historical data from the 1980s (an option suggested in the Regulation) rather than to a truly pristine situation. In Estonia, it was indicated that $B_{best}$ was entirely dependent on $B_0$. Then the calculation of $B_{best}$ remains wrong and should be 0.



In the other EMUs, an underestimation of $B_0$ is probably the reason. For instance, in SE_Inla, this is likely related to using a $B_{0}$ that is coming from the late 80s situation.

Normally, $B_{best}$ (that does not include restocking) stands for the best escapment that can occur in the absence of anthropogenic influence give the current recruitment. Since recruitment has collapsed, $B_{best}$ is supposed to be smaller than $B_0$ which is the escapment that would occur in the absence of any anthropogenic influence, including a pristine recruitment, and is generally estimated using pre-1980s data.

```{r }
#| label: fig-Bbestb0
#| fig-cap: "Histogram showing the frequency distribution of the $B_{best}/B_0$ ratio."

# A histogram showing frequency distribution of the bbest/b0 ratio

g15 <- ggplot(indicator, aes(x = bbest / b0)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[best] / B[0])) +
  scale_x_log10() +
  ylab("frequency") 
ggsave(g15, filename = file.path(params$image_path,"plotBbestb0.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"plotBbestb0.png"))
```


```{r }
#| label: tbl-tabbestb0
#| tbl-cap: "Occurrence of $B_{best}$ values larger than $B_0$. Either detail of years, or range and number of values if too long..."
knitr::kable(data.frame())
```

```{r tabbestb0}
#| label: flextabbestb0
indicator |>
    filter(bbest > b0) |>
    select(eel_emu_nameshort, eel_year, bbest, b0) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        years = ifelse(n() < 5,
            paste0(eel_year, collapse = "|"),
            sprintf(
                "range:%s-%s, Number occurences %s",
                min(eel_year),
                max(eel_year),
                n()
            )
        ),
        mean_bbest_b0 = round(mean(bbest / b0), 2)
    ) |>
    arrange(eel_emu_nameshort) |>
    flextable() |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 12, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bbest/B0"
        )
    )

check_these_emusbbestb0 <- indicator |>
    filter(bbest > b0) |>
    select(eel_emu_nameshort) |>
    unique() |>
    pull()
```

For some EMUs like SE_Inla, this is likely related to using a B_{0} that is coming from the late 80s situation. For EE, it seems rather due to the inclusion of restocking in $B_{best}$ (i.e. overestimation of $B_{best}$). For others, $B_0$ is likely underestimated.



## $B_{best}$ less than $B_{current}$

A second check consisted of comparing $B_{best}$ and $B_{current}$ (Table @tbl-bcurrentbbest, Figure @fig-bcurrentBbest): in the absence of significant re-stocking, $B_{current}$ should be less than $B_{best}$. The analysis of the ratio $B_{current}/B_{best}$ clearly shows the large effect of restocking in Germany, in Poland (PL_Oder) and in Sweden (SE_Inla). The very large value for DE_Rhei also illustrates a specific issue raised by transboundary EMU: DE_Rhein has no direct access to the sea so that young eels have to migrate through the Netherlands to reach DE_Rhein while in the other direction, silver eels also have to migrate through NL to reach the sea. $B_{best}$ is almost impossible to estimate in such EMUs: it would require estimating the number of eels that would migrate to DE_Rhei given the current recruitment in the absence of any anthropogenic barriers in the Netherlands. The large $B_{current}/B_{best}$ values indicate that $B_{best}$ is likely underestimated and that currently, the â€œnatural recruitmentâ€ is almost insignificant compared to restocking in those EMUs. In some Irish EMUs, $B_{best}$ is equal to $B_{current}$, these results are consistent with the very small anthropogenic mortality estimated in recent years for those EMUs. In countries without (or with limited) restocking, $B_{current}$ should be less than $B_{best}$. In Poland $B_{best}$ was calculated using geometric average recruitment from years 2010-2014 and only natural mortality to get estimate of SSB and it has been assumed the same for all years. In some previous reports two options of Bbest were used as it was not clear from the guidelines how Bbest should be calculated: 1. Bbest1 is based on current recruitment (e.g. from years 2021-2023), 2. Bbest2 is based on recruitment from those year-classes, which form current escapement of silver eel to spawn.

```{r }
#| label: fig-bcurrentBbest
#| fig-cap: "Histogram showing the frequency distribution of the $B_{current}/B_{best}$ ratio. Values higher than 1 indicate that $B_{current}$ is higher than $B_{best}$ which can happen in the case of restocking."
g16 <- ggplot(indicator, aes(x = bcurrent / bbest)) +
    geom_histogram() +
    geom_vline(xintercept = 1, slope = 1, lty = 2) +
    xlab(expression(B[current] / B[best])) +
    scale_x_log10() +
    ylab("frequency")
ggsave(g16, filename = file.path(params$image_path, "bcurrentBbest.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path, "bcurrentBbest.png"))
```

```{r }
#| label: tbl-bcurrentbbest
#| tbl-cap: "Table showing ratio of Bcurrent over Bbest for those EMUs and years where Bcurrent larger than Bbest. EMU from SE, NL, PL, DE excluded as obviously, in this case this is caused by restocking."
knitr::kable(data.frame())
```

```{r }
#| label: flextablebcurrentbbest

indicator |>
    filter(bbest < bcurrent) |>
    select(eel_emu_nameshort, eel_year, bcurrent, bbest) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        Years = ifelse(n() < 5,
            paste0(eel_year, collapse = "|"),
            sprintf(
                "range:%s-%s, Number occurences %s",
                min(eel_year),
                max(eel_year),
                n()
            )
        ),
        Ratio = round(mean(bcurrent / bbest), 2)
    ) |>
    rename(EMU = eel_emu_nameshort) |>
    arrange(desc(Ratio)) |>
    flextable() |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 10, 2.5), unit = "cm") |> 
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrent/Bbest"
        )
    )


check_these_emusbcurrentbbest <-
    indicator |>
    filter(bbest < bcurrent & !eel_cou_code %in% c("SE", "PL", "DE")) |>
    select(eel_emu_nameshort) |>
    unique() |>
    pull()    
```

For German EMUs, this shows the massive effect of restocking which is also visible in Sweden or in Poland. For Ireland, the anthropogenic mortality is so low in recent years that $B_{current}$ and $B_{best}$ can be very similar. Results are more doubtful in ES_Anda.

## Only $B_{current without restocking}$ reported

Before looking at EMUs where $B_{current without restocking}$ exceeds either $B_{best}$ or $B_0$, it is worthwhile to look at countries that have only reported $B_{current without restocking}$, and no $B_{current}$ which may or may not include restocking.

```{r }
#| label: tbl-onlybcurrent_without_restocking
#| tbl-cap: "Table with $B_{current without restocking}$ larger than $B_{best}and $B_{current}$ is not reported."
knitr::kable(data.frame())
```

```{r }
#| label: flextableonlybcurrent
indicator |>
  filter(
    !is.na(bcurrentw),
    is.na(bcurrent)
  ) |>
  select(eel_emu_nameshort, eel_year, bcurrentw, bbest) |>
  group_by(eel_emu_nameshort) |>
  summarize(
    years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s, Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())
    ),
    mean_bcurrentw_bbest = 
      round(mean(bcurrentw / bbest, na.rm = T),2)
  ) |>
  arrange(desc(mean_bcurrentw_bbest)) |>
  flextable() |>
  flextable2ICES() |>
  width(j = c(1,2,3), width = c(2.5,10,3), unit = "cm") |>
  set_header_labels(
  values = c(
    "EMU",
    "Years",
    "Bcurrent wr/Bbest")
    )
  


```

It is mostly French EMUs that have reported an estimate of $B_{current without restocking}$ (TABLE @tbl-onlybcurrent_without_restocking), while not having reported on regular Bcurrent. The reason is that the latest report is only based on regions where restocking didn't occur (so as not to biase EDA outputs....) so it was not provided. Theoretically another model could have been used to provide those estimates (e.g A model estimating the production for segments of rivers affected by restocking).

## $B_{current without restocking}$ higher than $B_{best}$

All estimates of $B_{current without restocking}$ are now lower than $B_{best}$. Two values were corrected and now the table only shows a rounding problem for IE_SouW (Fig @fig-bcurrentwbbest, Table @tbl-bcurrentwbbest).

```{r }
#| label: fig-bcurrentwbbest
#| fig-cap: "Histogram showing the frequency distribution of the $B_{current without restocking}/B_best$ ratio. Values higher than 1 indicate that $B_{current without restocking}$ is higher than $B_best$ which should not happen."
g17 <- ggplot(indicator, aes(x = bcurrentw / bbest)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[currentw] / B[best])) +
  scale_x_log10() +
  ylab("frequency")
ggsave(g17, filename = file.path(params$image_path,"bcurrentwbbest.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"bcurrentwbbest.png"))
```

```{r }
#| label: tbl-bcurrentwbbest
#| tbl-cap: Table showing years and EMU where $B_{current without restocking}$ is higher than $B_{best}$. There is only one and it's a rounding problem that can be saferly ignored.
knitr::kable(data.frame())
```

```{r }
#| label: flextablebcurrentwbbest
indicator |>
    filter(bbest < bcurrentw) |>
    select(eel_emu_nameshort, eel_year, bcurrentw, bbest) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        years = ifelse(n() < 5,
            paste0(eel_year, collapse = "|"),
            sprintf(
                "range:%s-%s, Number occurences %s",
                min(eel_year),
                max(eel_year),
                n()
            )
        ),
        mean_bcurrent_without_restocking_bbest = round(mean(bcurrentw / bbest), 2)
    ) |>
    arrange(desc(mean_bcurrent_without_restocking_bbest)) |>
    flextable() |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 10, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrent wr/Bbest"
        )
    )

check_these_emusbcurrentbbest_without_restocking <-
    indicator |>
    filter(bbest < bcurrentw) |>
    select(eel_emu_nameshort) |>
    unique() |>
    pull()
```

## $B_{current}$ higher than $B_{best}$ while $B_{current without restocking}$ is not reported.

$B_{best}$ calculation should not include restocking. So when $B_{current}$ is larger than $B_{best}$ we expect that there is restocking. If $B_{current without restocking}$ is not reported, then data are missing. Table @tbl-currentbbestnorestockestimate summarize those data. Poland has reported missing values from 2011 so that is good, and only older estimates are missing (before 2010). Germany failed to report those data in time due to technical problem with the model (not being able to do such calculations). The problem identified for Greece also remains.

For GR_CeAe, indicators are strange. Sometimes $B_{current}$ is larger or equal to $B_{best}$, but at the same time $\sum{A}$ is also high. Sometimes, $B_{best}$ and $B_{current}$ are 0, but $\sum{A}$ is also 0. I double-checked with the data provider, and all years with 0 values for biomass indicator estimates should be NC instead, since these are years with no landings (so $\sum{A}$ is 0). It remained unclear why $B_{best}$ and $B_{current}$ were higher than b0 for years with an estimate. Advise to remove this series from WKEMP analysis until the methods for deriving these estimates are better looked at.

```{r}
#| label: tbl-currentbbestnorestockestimate
#| tbl-cap : "EMU and years for which $B_{current}$ is larger than $B_{best}$ and $B_{current without stocking}$ is not reported."
knitr::kable(data.frame())
```
```{r}
#| label: flexcurrentbbestnorestockestimate
flextable(indicator |>
    filter(
        bbest < bcurrent,
        is.na(bcurrentw)
    ) |>
    select(eel_emu_nameshort, eel_year, bcurrent, bbest) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        years = paste0(sort(eel_year), collapse = "/"),
        mean_bcurrent_bbest = round(mean(bcurrent / bbest), 2)
    ) |>
    arrange(desc(mean_bcurrent_bbest))) |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 10, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrent/Bbest"
        )
    )
```

## $B_0$ less than $B_{current}$
In countries without (or with limited) restocking, $B_{current}$ should be less than $B_0$

```{r}
#| label: fig-bcurrentb0
#| fig-cap: "Histogram showing frequency distribution of the $B_{current}$/$B_0$. Values >1 would indicate a problems"
g18 <- ggplot(indicator, aes(x = bcurrent / b0)) +
    geom_histogram() +
    geom_vline(xintercept = 1, slope = 1, lty = 2) +
    xlab(expression(B[current] / B[0])) +
    scale_x_log10() +
    ylab("frequency")
ggsave(g18, filename = file.path(params$image_path, "bcurrentb0.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path, "bcurrentb0.png"))
```

```{r }
#| label: tbl-bcurrentb0
#| tbl-cap: "Situations in which $B_{current}$ is reported as greater than $B_{0}$."
knitr::kable(data.frame())
```

```{r }
#| label: flextablebcurrentb0
indicator |>
    filter(b0 < bcurrent) |>
    select(eel_emu_nameshort, eel_year, bcurrent, b0) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        years = ifelse(n() < 5,
            paste0(eel_year, collapse = "|"),
            sprintf(
                "range:%s-%s, Number occurences %s",
                min(eel_year),
                max(eel_year),
                n()
            )
        ),
        mean_bcurrent_b0 = round(mean(bcurrent / b0), 2)
    ) |>
    arrange(desc(mean_bcurrent_b0)) |>
    flextable() |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 10, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrent/B0"
        )
    )

check_these_emusb0lessthanbcurrent <-
    indicator |>
    filter(b0 < bcurrent & !eel_cou_code %in% c("SE", "PL", "DE")) |>
    select(eel_emu_nameshort) |>
    unique() |>
    pull()

```

## $B_{current}$ without restocking higher than $B_0$

There is only one case in wich with $B_{current}$ without restocking was reported as greater than $B_0$ (Fig @fig-bcurrentb0, Table @tbl-bcurrentb0). As already mentioned above, without any restocking effects, $B_{current}$ for GB_Scot is still estimated as higher than b0. This indicates an underestimate of $B_0$ which is confirmed by the data provider.

```{r }
#| label: fig-bcurrentnorestockb0
#| fig-cap: "Histogram showing frequency distribution of the $B_{current}/B_0$. Values higher than 1 indicate a problem"

g19 <- ggplot(indicator, aes(x = bcurrentw / b0)) +
    geom_histogram() +
    geom_vline(xintercept = 1, slope = 1, lty = 2) +
    xlab(expression(B[current_norestock] / B[0])) +
    scale_x_log10() +
    ylab("frequency")
ggsave(g19, filename = file.path(params$image_path, "bcurrentnorestockb0.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path, "bcurrentnorestockb0.png"))
```

```{r }
#| label: tbl-bcurrentnorestockb0
#| tbl-cap: "Situations in which $B_{current}$ without restocking was reported as greater than $B_0$."
knitr::kable(data.frame())
```

```{r }
#| label: flextablebcurrentnorestockb0
indicator |>
    filter(b0 < bcurrentw) |>
    select(eel_emu_nameshort, eel_year, bcurrentw, b0) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        years = paste0(sort(eel_year), collapse = "/"),
        mean_bcurrentnorestock_b0 = mean(bcurrentw / b0)
    ) |>
    arrange(desc(mean_bcurrentnorestock_b0)) |>
    flextable() |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 10, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrentw/B0"
        )
    )

check_these_emusb0lessthanbcurrentwithout <-
    indicator |>
    filter(b0 < bcurrent & !eel_cou_code %in% c("SE", "PL", "DE")) |>
    select(eel_emu_nameshort) |>
    unique() |>
    pull()
```

## Check irregularities in combinations of $B_{current}$, $B_{best}$, and $\sum{A}$

If there is no restocking, $B_{current}$ should roughly correspond to $B_{best}*\sum{A}$ (Fig @fig-highindicators , table @tbl-bcurrentbcurrentestimated). Only EMUs from Germany, Greece have a $B_{current}$ that differs from more than 10% from the expected $B_{current}$. For Germany, this is likely the result of restocking. For Greece, it might be restocking. $B_{current_without_restocking}$ estimates are consistent with $B_{best}*\sum{A}$. For this reason Table @tbl-bcurrentbcurrentestimated has no value.

```{r }
#| label: fig-highindicators
#| fig-cap: "Histogram showing frequency distribution of $B_{current}/ B_{best}*\\sum{A}$ while $B_{current without restocking}$ is not reported. Values higher than 1 indicate a possible problem."

# note I don't know when but I'm messing with sumA so I load a clean
# version of indicator (saved at the beginning for those plots and tables)

g20 <- indicator2 |>
    filter(is.na(bcurrentw)) |>
    mutate(
        bcurrent_expected = bbest * exp(-suma),
        b_bexpect = bcurrent / bcurrent_expected
    ) |>
    ggplot(aes(x = b_bexpect)) +
    geom_histogram() +
    geom_vline(xintercept = 1, slope = 1, lty = 2) +
    xlab(expression(B[current] / B[best]*sum(A))) +
    scale_x_log10() +
    ylab("frequency")
ggsave(g20, filename = file.path(params$image_path, "highindicators.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path, "highindicators.png"))
```

```{r }
#| label: fig-highindicators2
#| fig-cap: "Comparison of $B_{current Without Restocking}$ and $B_{currentExpected}$ calculated as $B_{best}*exp[-\\sum{A}]$"


g21 <- indicator2 |>
  mutate(
    bcurrent_expected = bbest * exp(-suma),
    b_bexpect = bcurrentw / bcurrent_expected
  ) |>
   ggplot(aes(x = b_bexpect)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current_norestock] / B[current_expected])) +
  scale_x_log10() +
  ylab("frequency")
ggsave(g21, filename = file.path(params$image_path,"highindicators2.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path,"highindicators2.png"))
```

```{r }
#| label: tbl-bcurrentbcurrentestimated
#| tbl-cap: "Comparison of $B_{current}$ and $B_{current expected}= B_{best} exp(-\\sum{A})$ for all series with no estimate for $B_{current without restocking}$."
knitr::kable(data.frame())
```

```{r}
#| label: flextablebcurrentbcurrentestimated
indicator2 |>
    filter(is.na(bcurrentw)) |>
    mutate(
        bcurrent_expected = bbest * exp(-suma),
        b_bexpect = bcurrent / bcurrent_expected
    ) |>
    filter(abs(b_bexpect) > 1.1) |>
    select(eel_emu_nameshort, eel_year, b_bexpect) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        years = ifelse(n() < 5,
            paste0(eel_year, collapse = "|"),
            sprintf(
                "range:%s-%s, Number occurences %s",
                min(eel_year),
                max(eel_year),
                n()
            )
        ),
        mean_b_bexpect = mean(b_bexpect)
    ) |>
    arrange(eel_emu_nameshort) |>
    flextable() |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 10, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrent/Bcurrent expected"
        )
    )
```

```{r }
#| label: tbl-bcurrentbcurrentwestimated
#| tbl-cap: Comparison $B_{current without restocking}$ to $B_{current expected}= B_{best} exp(-\\sum{A})$ for all series with no estimate for $B_{current without restocking}$."
knitr::kable(data.frame())
```

```{r }
#| label: flextablebcurrentbcurrentwestimated
indicator2 |>
    mutate(
        bcurrent_expected = bbest * exp(-suma),
        b_bexpect = bcurrentw / bcurrent_expected
    ) |>
    filter(abs(b_bexpect) > 1.1) |>
    select(eel_emu_nameshort, eel_year, b_bexpect) |>
    group_by(eel_emu_nameshort) |>
    summarize(
        years = paste0(sort(eel_year), collapse = "/"),
        mean_b_bexpect = mean(b_bexpect)
    ) |>
    arrange(eel_emu_nameshort) |>
    flextable() |>
    flextable2ICES() |>
    width(j = c(1, 2, 3), width = c(2.5, 10, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrent wr/Bcurrent expected"
        )
    )

```

## Difference between $B_{current without restocking}$ and $B_{current}$

$B_{current without restocking}$ should always be lower than $B_{current}$. Exceptions in Ireland are rounding issues. We have two cases where the calculation is dubious (Table @tbl-checkingdiffbcurrenttable, Figure @fig-checkingdiffbcurrent).

```{r }
#| label: fig-checkingdiffbcurrent
#| fig-cap: "Histogram showing frequency distribution of the $B_{current}$/$B_{current without stocking}$. Values lower than 1 indicate a problem."

g22 <- ggplot(indicator, aes(x = bcurrent / bcurrentw)) +
    geom_histogram() +
    geom_vline(xintercept = 1, slope = 1, lty = 2) +
    xlab(expression(B[current] / B[currentw])) +
    scale_x_log10() +
    ylab("frequency")
ggsave(g22, filename = file.path(params$image_path, "checkingdiffbcurrent.png"), height = 12 / 2.54, width = 12 / 2.54, dpi = 300)
knitr::include_graphics(file.path(params$image_path, "checkingdiffbcurrent.png"))
```

```{r }
#| label: tbl-checkingdiffbcurrenttable
#| tbl-cap: "Years and EMU for which $B_{current without restocking}$ is reported as greater than $B_{current}$."
knitr::kable(data.frame())
```

```{r }
#| label: flextablecheckingdiffbcurrenttable
indicator |>
    filter(bcurrentw > bcurrent) |>
    mutate(
        ratio = bcurrentw / bcurrent,
        years = ifelse(n() < 5,
            paste0(eel_year, collapse = "|"),
            sprintf(
                "range:%s-%s, Number occurences %s",
                min(eel_year),
                max(eel_year),
                n()
            )
        ),
    ) |>
    select(eel_emu_nameshort, years, ratio) |>
    arrange(desc(ratio)) |>
    flextable() |>
    flextable2ICES() |>
   width(j = c(1, 2, 3), width = c(2.5, 10, 3), unit = "cm") |>
    set_header_labels(
        values = c(
            "EMU",
            "Years",
            "Bcurrent wr/Bcurrent"
        )
    )


check_these_emusbcurrentlessthancurrentwithout <-
    indicator |>
    filter(bcurrentw > bcurrent) |>
    select(eel_emu_nameshort) |>
    unique() |>
    pull()
```





## Comparing $B_0$ with an adjusted estimate
The EU regulation states that Member States should implement management measures to achieve an escapement equal to 40 % of the pristine escapement. However, the pristine situation is difficult to define and therefore, $B_0$ is difficult to estimate. Some countries have used observations of past productivity in some water bodies, multiplied by the total water surface to extrapolate pristine escapement as suggested in the Eel Regulation. However, the availability of historical data does not go back far enough in time, rarely before the 1980s, to be considered as pristine. Other countries have used the current escapement, corrected for anthropogenic mortality (i.e.Â Bbest) and used this to extrapolate B0. However, the extrapolation methods vary among countries, especially regarding the integration of density dependence (accounting for density dependent mortality leads to smaller B0 since it postulates that natural mortality increases with abundance). These difficulties impair the comparison among B0 estimates, and subsequently, the status of EMUs with respect to the EU regulation target. To avoid those inconsistencies, lasted WKEMP [@ices2022] proposed an alternative indicator based on $B_{best}$ and current level of recruitment: 

$$
B_{0_{adj}}=\frac{R_0}{R_{current}} \cdot {B_{best}}
$$

As explained in the latest report, this adjusted indicator does not account for any modification of natural mortality resulting from density-dependance [@bevacqua2011] and requires some extra-assumption regarding lifespan per region and current levels of recruitment. We applied the exact same methods as in 2022 and use this adjusted indicator to check the consistency among countries and EMUs.

```{r}
#| echo: false
#| warning: false
#| results: 'hide'
#| label: calculate_b0_adj


indicator <- dbGetQuery(con, "select eel_year,eel_cou_code,eel_emu_nameshort, b0,bbest,bcurrent, bcurrent_without_stocking,suma,sumf, sumh from datawg.precodata_emu")
dbDisconnect(con)
indicator <- indicator %>%
  mutate(eel_cou_code = ifelse(eel_cou_code == substr(eel_emu_nameshort, 1, 2),
    eel_cou_code,
    "INT"
  )) %>%
  filter(eel_cou_code %in% eu_cou_codes)
# source("readingAnnex13.R") run this if you don't have Rdata below
load(file = file.path(getwd(), "data_dependencies", "annex13.Rdata")) # annexes13_method,annexes13_traceability,annexes13_management,

eu_cou_codes <- c("AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE", "FI", "FR", "DE", "GR", "HU", "IE", "IT", "LV", "LT", "LU", "MT", "NL", "PL", "PT", "RO", "SK", "SI", "ES", "SE")

emu_sea <- emu_p %>%
  filter(emu_cou_code %in% eu_cou_codes) %>%
  mutate(rec_zone = ifelse(emu_cou_code %in% c("NL", "DK", "NO", "BE", "LU", "CZ", "SK") |
    emu_nameshort %in% c(
      "FR_Rhin", "FR_Meus", "GB_Tham", "GB_Angl", "GB_Humb", "GB_Nort", "GB_Solw",
      "DE_Ems", "DE_Wese", "DE_Elbe", "DE_Rhei", "DE_Eide", "DE_Maas"
    ),
  "NS",
  ifelse(emu_cou_code %in% c("EE", "FI", "SE", "LV", "LT", "AX", "PL", "DE"),
    "BA",
    "EE"
  )
  ))


mor_wise <- annexes13_method %>% select(emu_nameshort, mortality_wise)
mor_wise <- merge(emu_sea %>% st_drop_geometry(), mor_wise)
mor_wise <- mor_wise %>% mutate(cohort_wise = grepl("ohort", mortality_wise))
load("../../R/shiny_data_visualisation/shiny_dv/data/recruitment/dat_ge.Rdata")
load("../../R/shiny_data_visualisation/shiny_dv/data/recruitment/dat_ye.Rdata")



estimate_b0 <- function(emu, year, mor_wise, precodata, correctM = FALSE) {
  mod <- switch(unique(mor_wise$rec_zone[mor_wise$emu_nameshort == emu]),
    "EE" = dat_ge %>% filter(area == "Elsewhere Europe"),
    "NS" = dat_ge %>% filter(area == "North Sea"),
    "BA" = dat_ye
  )
  if ("value_std_1960_1979" %in% names(mod)) {
    Rcurrent <- mean(mod$value_std_1960_1979[mod$year %in% ((year - 4):year)])
  } else {
    Rcurrent <- mean(mod$p_std_1960_1979[mod$year %in% ((year - 4):year)])
  }
  if (unique(mor_wise$cohort_wise[mor_wise$emu_nameshort == emu])) {
    Rcurrent <- switch(mor_wise$rec_zone[mor_wise$emu_nameshort == emu],
      "EE" = mean(mod$p_std_1960_1979[mod$year %in% ((year - 12):(year - 7))]),
      "NS" = mean(mod$p_std_1960_1979[mod$year %in% ((year - 17):(year - 12))]),
      "BA" = mean(mod$value_std_1960_1979[mod$year %in% ((year - 22):(year - 17))])
    )
  }
  if (!correctM) {
    return(precodata$bbest[precodata$eel_emu_nameshort == emu & precodata$eel_year == year] / Rcurrent)
  }
}

indicator <- indicator %>% left_join(
  emu_sea %>%
    st_drop_geometry() %>%
    select(emu_nameshort, rec_zone) %>%
    rename(eel_emu_nameshort = emu_nameshort)
)


indicator_sub <- indicator %>%
  filter(eel_emu_nameshort %in% unique(mor_wise$emu_nameshort))
indicator_sub$b0_adj <- mapply(estimate_b0, indicator_sub$eel_emu_nameshort, indicator_sub$eel_year,
  MoreArgs = list(mor_wise = mor_wise, precodata = indicator_sub)
)

options(scipen = 999)
indicator <- indicator %>% left_join(indicator_sub %>% select(eel_year, eel_emu_nameshort, b0_adj), by = c("eel_year", "eel_emu_nameshort"))
```

$B_{0_{adj}}$ takes current level of recruitment expressed a a fraction of pre-80s values (from WGEEL indices, considering that pre-80s is close to $R_0$), and use $B_{best}$ (escapement that would have occurred given current recruitment in the absence of anthropogenic mortality) to estimate a theoretical $B_0$. This could be repeated for every year for which $B_{best}$ and recruitment indices are available. In the absence of any density dependent natural mortality, those adjusted $B_{0_{adj}}$ are expected to be stable through time. In period of declining recruitment, natural mortality is expected to decrease and consequently, $B_{0_{adj}}$ to increase. On the contrary, $B_{0_{adj}}$ is expected to decrease in periods of decreasing recruitment. In the last years, recruitment have been rather stable, so $B_{0_{adj}}$ were expected to be rather stable, but interestingly, we observe significant and contrasted trends depending on countries (Figure @fig-plotB0adj). This is likely related to heterogeneities in the methods to compute indicators.

```{r}
#| echo: false
#| label: fig-plotB0adj
#| fig-height: 6.3
#| fig-width: 6.3
#| fig-cap: "Trends in $B_{0_{adj}}$ per EMU. Each line stands for an EMU"


b0trend <- ggplot(indicator %>% filter(!is.na(b0_adj)), aes(x = eel_year, y = b0_adj / 1000000)) +
  geom_hline(yintercept = .4, col = "red") +
  geom_line(aes(col = eel_cou_code, group = eel_emu_nameshort)) +
  #  scale_y_log10()+
  scale_color_manual("country", values = color_countries[names(color_countries) %in% unique(indicator$eel_cou_code)], ) +
  guides(lty = FALSE, col = FALSE) + # geom_hline(yintercept=1)+
  #  scale_y_sqrt()+
  theme_bw() +
  ylab(expression(B[0[adj]] ~ "in 1000t")) +
  xlab("") +
  xlim(2007, 2020) +
  facet_wrap(~eel_cou_code, drop = TRUE, scales = "free_y")
ggsave(b0trend, file = "2024/image/b0_trend.png", height = 16 / 2.54, width = 16 / 2.54)
knitr::include_graphics("2024/image/b0_trend.png")
```

<br>
In the absence of density dependence $B_{0_{adj}}$/$B_0$ is expected to be close to 1. In the presence of density dependent mortality, given the current recruitment decline, $B_{0_{adj}}$/$B_0$ might be higher than 1. 



In Elsewhere Europe area (Figure @fig-B0adjoverB0EE), most of the ratio are between 1 and 10, the order of magnitudes appear to be roughly constant among countries. The only exception is ES_Anda that display a very low ratio. This would suggest either very strong values of $B_0$ or very pessimistic values of $B_{best}$. In this EMU, pristine escapement is estimated using current estimate of production per hectare corrected for recruitment loss without accounting for any density-dependance, and postulating multiplying it by the surface in pristine conditions. Ireland appears to have larger values than other countries, this is likely related to their difficulties in extrapolating $B_0$ mentioned in their annex 13.

```{r}
#| echo: false
#| warning: false
#| error: false
#| label: fig-B0adjoverB0EE
#| fig-height: 6.3
#| fig-width: 6.3
#| fig-cap: "Ratio of $B_{0_{adj}}$/$B_0$ per EMU. Each bar stands for a year from Elsewhere Europe. Only EMUs for which it was possible to estimate $B_{0_{adj}}$ are plotted."
g <- ggplot(indicator %>%
  filter(eel_cou_code %in% eu_cou_codes & rec_zone == "EE" & !is.na(b0_adj)), aes(x = b0_adj / b0)) +
  geom_histogram(aes(fill = eel_emu_nameshort), show.legend = FALSE) +
  geom_vline(aes(xintercept = 1), lty = 3) +
  facet_wrap(~eel_emu_nameshort) +
  scale_x_log10() +
  xlab(expression(B[0[adj]] / B[0])) +
  ylab("") +
  theme_bw()

ggsave(g, file = "2024/image/B0adjoverB0EE.png", height = 16 / 2.54, width = 16 / 2.54)
knitr::include_graphics("2024/image/B0adjoverB0EE.png")
```
<br>

EMUs connected to the North Sea display very high values of ratios compared to what is observed in Elsewhere Europe (Figure @fig-B0adjoverB0NS). This is surprising since recruitment (and consequently density dependent natural mortality) is supposed to be lower in this area. A possible reason is the WGEEL North Sea index that might be overpessimistic, indicating overly low current recruitment and leading to overestimated $B_{0_{adj}$ as discussed in WGEEL 2024. However, the level of variations among countries, and among EMUs withing countries is still rather large.

```{r}
#| echo: false
#| warning: false
#| error: false
#| label: fig-B0adjoverB0NS
#| fig-height: 6.3
#| fig-width: 6.3
#| fig-cap: "Ratio of $B_{0_{adj}}$/$B_0$ per EMU. Each bar stands for a year from North Sea. Only EMUs for which it was possible to estimate $B_{0_{adj}}$ are plotted."
g <- ggplot(indicator %>%
  filter(eel_cou_code %in% eu_cou_codes & rec_zone == "NS" & !is.na(b0_adj)), aes(x = b0_adj / b0)) +
  geom_histogram(aes(fill = eel_emu_nameshort), show.legend = FALSE) +
  geom_vline(aes(xintercept = 1), lty = 3) +
  facet_wrap(~eel_emu_nameshort) +
  scale_x_log10() +
  xlab(expression(B[0[adj]] / B[0])) +
  ylab("") +
  theme_bw()

ggsave(g, file = "2024/image/B0adjoverB0NS.png", height = 16 / 2.54, width = 16 / 2.54)
knitr::include_graphics("2024/image/B0adjoverB0NS.png")
```
<br>

In the Baltic region (Figure @fig-B0adjoverB0BA), the situation is similar to Elsewhere Europe. Here, two EMUs display negative ratio that could be surprising: DE_Oder and SE_Inla, questioning a possible overestimation of $B_0$.

```{r B0adjoverB0BA}
#| echo: false
#| warning: false
#| error: false
#| label: fig-B0adjoverB0BA
#| fig-height: 6.3
#| fig-width: 6.3
#| fig-cap: "Ratio of $B_{0_{adj}}$/$B_0$ per EMU. Each bar stands for a year from the Baltic area. Only EMUs for which it was possible to estimate $B_{0_{adj}}$ are plotted."
g <- ggplot(indicator %>%
  filter(eel_cou_code %in% eu_cou_codes & rec_zone == "BA"& !is.na(b0_adj)), aes(x = b0_adj / b0)) +
  geom_histogram(aes(fill = eel_emu_nameshort), show.legend = FALSE) +
  geom_vline(aes(xintercept = 1), lty = 3) +
  facet_wrap(~eel_emu_nameshort) +
  scale_x_log10() +
  xlab(expression(B[0[adj]] / B[0])) +
  ylab("") +
  theme_bw()

ggsave(g, file = "2024/image/B0adjoverB0BA.png", height = 16 / 2.54, width = 16 / 2.54)
knitr::include_graphics("2024/image/B0adjoverB0BA.png")
```
<br>

### Conclusion
The aim of this exercise was not to check the validity of $B_0$ nor to say that $B_{0_{adj}}$ is a better indicator. It rather aims to detect differences in $B_0$ estimates that could be due to highlight differences in methods and in assumptions regarding natural mortality. Such differences affecting $B_0$ will mechanically affect the estimate of $B_{current}/B_0$ and consequently, the assessment of the achievement of the Eel Regulation target.
