
---
title: "WKEMP4_measures_summary"
author: "none (contact Jani H for questions)"
date: "`r Sys.Date()`"

output:
  html_document: default
  #word_document: default

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# define libraries needed
libs <- c("readxl", "dplyr", "tidyr", "flextable", "knitr", "kableExtra", "officer", "readr", "tibble", "ggplot2", "viridis") 

#define libraries already installed
installed_libs <- libs %in% rownames(installed.packages())

# install libraries that are not installed already
if (any(installed_libs == F)) {
  install.packages(libs[!installed_libs])
}

# load libraries needed
invisible(lapply(libs, library, character.only = T))

# Function to replace underscores with spaces and capitalize the first letter of each word
clean_names <- function(name) {
  if (!is.na(name)) {
    name <- gsub("_", " ", name)
    name <- tools::toTitleCase(name)
  }
  return(name)
}

```


```{r Import_files, echo=FALSE}

### The folder where all the excel files are in. CHANGE IF NEEDED
load("./output/measures_all_cleaned_EMP.RData")
load("./output/removed_non_EMP.RData")
load("./output/measures_all.RData")

#measures_all = read.csv2("measures_all_cleaned_EMP.csv")

standards <- read_excel("standards.xlsx")
all_emus = read.csv2("all_emus.csv")

```

```{r Filter_EMUOnly, include=FALSE}

## Filter the data frame for EMU only and drop Great_Britain
#measures_all <- measures_all %>%
#  filter(measure_planned %in% c("EMP", "EMP_amended")) %>%
#  filter(country != "Great_Britain") %>%
#  filter(delete != "Yes") %>%
#  filter(delete != "delete")

```



```{r MeasuresPlannedPerCountry, echo=FALSE}

# Create the new data frame with country and measure_planned
ImpactByCountry <- measures_all %>%
  select(country, measure_planned)

# Combine NA and specific text to "Other"
ImpactByCountry <- ImpactByCountry %>%
  mutate(measure_planned = ifelse(is.na(measure_planned) | 
                                  measure_planned == "The EMU has not reported any information for that sub measure", 
                                  "Other", 
                                  measure_planned))

# Clean NAs (if any remain)
ImpactByCountry$measure_planned[is.na(ImpactByCountry$measure_planned)] <- "N/A"

ImpactByCountry <- ImpactByCountry %>%
  mutate(country = as.character(country),
         country = trimws(country),
         country = ifelse(is.na(country) | 
                          country == "The EMU has not reported any information for that sub measure" | 
                          country == "The EMU has not reported any information", 
                          "NA", 
                          country))

# Summarise the count of measures planned for each country and measure_planned
ImpactByCountry <- ImpactByCountry %>%
  group_by(country, measure_planned) %>%
  summarise(count = n()) %>%
  ungroup()

# Create the stacked bar chart
ggplot(ImpactByCountry, aes(x = factor(country), y = count, fill = factor(measure_planned))) +
  geom_bar(stat = "identity") +
  labs(x = "Country", y = "Number of measures planned", title = "", fill = "Measure Planned") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()

#SHould we divide by number of EMUs? 
#Do we use all data measures_all?

```
```{r MeasuresPlannedPerCountryBversion, echo=FALSE}

clean_names <- function(name) {
  if (!is.na(name)) {
    name <- gsub("_", " ", name)
    name <- tools::toTitleCase(name)
  }
  return(name)
}

# Create the new data frame with country, measure_planned, and emu_name_short
ImpactByCountry <- measures_all %>%
  select(country, measure_planned, emu_name_short)

# Combine NA and specific text to "Other"
ImpactByCountry <- ImpactByCountry %>%
  mutate(measure_planned = ifelse(is.na(measure_planned) | 
                                  measure_planned == "The EMU has not reported any information for that sub measure", 
                                  "Other", 
                                  measure_planned))

# Count the number of EMUs for each country
EMUCountByCountry <- ImpactByCountry %>%
  group_by(country) %>%
  summarise(emu_count = n_distinct(emu_name_short))

# Merge the EMU count back into the main data frame
ImpactByCountry <- ImpactByCountry %>%
  left_join(EMUCountByCountry, by = "country")

# Clean NAs (if any remain)
ImpactByCountry$measure_planned[is.na(ImpactByCountry$measure_planned)] <- "N/A"

ImpactByCountry <- ImpactByCountry %>%
  mutate(country = as.character(country),
         country = trimws(country),
         country = ifelse(is.na(country) | 
                          country == "The EMU has not reported any information for that sub measure" | 
                          country == "The EMU has not reported any information", 
                          "NA", 
                          country))

# Summarise the count of measures planned for each country and measure_planned
ImpactByCountry <- ImpactByCountry %>%
  group_by(country, measure_planned, emu_count) %>%
  summarise(count = n()) %>%
  ungroup()

# Assuming ImpactByCountry is your data frame
ImpactByCountry <- ImpactByCountry[ImpactByCountry$country != "Great_Britain", ]

# Apply the function to the measure_planned column
ImpactByCountry$measure_planned <- sapply(ImpactByCountry$measure_planned, clean_names)
# Apply the function to the measure_planned column
ImpactByCountry$country <- sapply(ImpactByCountry$country, clean_names)

# Add a column for the original counts before normalizing
ImpactByCountry <- ImpactByCountry %>%
  mutate(original_count = count)

# Divide each country's values by the number of EMUs
ImpactByCountry <- ImpactByCountry %>%
  mutate(count = count / emu_count)

# Calculate the total count for each country
ImpactByCountry <- ImpactByCountry %>%
  group_by(country) %>%
  mutate(total_count = sum(original_count)) %>%
  ungroup()

# Create the stacked bar chart with total counts as part of the X-axis labels
ImpactByCountry$country_label <- paste(ImpactByCountry$country, " (n=", ImpactByCountry$total_count, ")", sep = "")

ggplot(ImpactByCountry, aes(x = factor(country_label), y = count, fill = factor(measure_planned))) +
  geom_bar(stat = "identity") +
  labs(x = "Country", y = "Number of measures planned (normalised*)", title = "", fill = "Measure Planned") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()

```

```{r Impact_nonEMP_only, echo=FALSE}
# Function to replace underscores with spaces and capitalize the first letter of each word
clean_names <- function(name) {
  if (!is.na(name)) {
    name <- gsub("_", " ", name)
    name <- tools::toTitleCase(name)
  }
  return(name)
}

# Apply the function to the impact column
removed_non_EMP$impact <- sapply(removed_non_EMP$impact, clean_names)

# Apply the function to the measure_type column
removed_non_EMP$measure_type <- sapply(removed_non_EMP$measure_type, clean_names)

# Replace values in the impact column
removed_non_EMP$impact <- gsub("Indirect", "Not direct", removed_non_EMP$impact)

# Create a contingency table that has only the needed data
ImpactCountTable <- table(removed_non_EMP$measure_type, removed_non_EMP$impact)

# Convert the table to a data frame
ImpactCountTable <- as.data.frame.matrix(ImpactCountTable)

# Normalize the data to get percentages
ImpactCountTable_percent <- sweep(ImpactCountTable, 1, rowSums(ImpactCountTable), FUN = "/") * 100

# Convert the data frame to long format for ggplot2
ImpactCountTable_long <- as.data.frame(ImpactCountTable_percent)
ImpactCountTable_long$measure_type <- rownames(ImpactCountTable_long)
ImpactCountTable_long <- tidyr::gather(ImpactCountTable_long, key = "impact", value = "percentage", -measure_type)

# Assuming ImpactCountTable contains the original counts
ImpactCountTable_counts_long <- as.data.frame(ImpactCountTable)
ImpactCountTable_counts_long$measure_type <- rownames(ImpactCountTable_counts_long)
ImpactCountTable_counts_long <- tidyr::gather(ImpactCountTable_counts_long, key = "impact", value = "count", -measure_type)

# Calculate the total counts for each measure_type
TotalCounts <- aggregate(count ~ measure_type, data = ImpactCountTable_counts_long, sum)
colnames(TotalCounts)[2] <- "total_count"

# Merge the totals with the percentages
ImpactCountTable_long <- merge(ImpactCountTable_long, TotalCounts, by = "measure_type")

print(unique(removed_non_EMP$measure_planned))

# Create the stacked bar chart with total counts as labels at the top of each bar
ggplot(ImpactCountTable_long, aes(x = measure_type, y = percentage, fill = impact)) +
  geom_bar(stat = "identity") +
  geom_text(data = TotalCounts, aes(x = measure_type, y = 100, label = paste0("n = ", total_count)), 
            vjust = -0.2, size = 3, inherit.aes = FALSE) +
  labs(x = "Measure Type", y = "Percentage", title = "", fill = "Impact") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()



```
```{r Impact_nonEMP_only__COUNTRIES, echo=FALSE}

# Apply the function to the impact and measure_type columns
removed_non_EMP$impact <- sapply(removed_non_EMP$impact, clean_names)
removed_non_EMP$measure_type <- sapply(removed_non_EMP$measure_type, clean_names)

# Replace values in the impact column
removed_non_EMP$impact <- gsub("Indirect", "Not direct", removed_non_EMP$impact)

# Filter out rows where country is NA
removed_non_EMP <- subset(removed_non_EMP, !is.na(country))

# Create a contingency table that has only the needed data
ImpactCountTable <- table(removed_non_EMP$measure_type, removed_non_EMP$impact, removed_non_EMP$country)

# Convert the table to a data frame
ImpactCountTable <- as.data.frame(ImpactCountTable)

# Rename columns for clarity
colnames(ImpactCountTable) <- c("measure_type", "impact", "country", "count")

# Normalize the data to get percentages
ImpactCountTable <- ImpactCountTable %>%
  group_by(measure_type, country) %>%
  mutate(percentage = count / sum(count) * 100)

# Calculate the total counts for each measure_type and country
TotalCounts <- ImpactCountTable %>%
  group_by(measure_type, country) %>%
  summarise(total_count = sum(count))

# Merge the totals with the percentages
ImpactCountTable <- merge(ImpactCountTable, TotalCounts, by = c("measure_type", "country"))

# Create the stacked bar chart with total counts as labels at the top of each bar
p <- ggplot(ImpactCountTable, aes(x = measure_type, y = percentage, fill = impact)) +
  geom_bar(stat = "identity") +
  geom_text(data = TotalCounts, aes(x = measure_type, y = 100, label = paste0("n = ", total_count)), 
            vjust = 0.2, size = 3, inherit.aes = FALSE) +
  labs(x = "Measure Type", y = "Percentage", title = "", fill = "Impact") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d() +
  facet_wrap(~ country, ncol = 2) +  # Change the number of columns here
  theme(strip.text = element_text(face = "bold"))  # Bold the country names

# Save the plot with increased height
ggsave("plot.png", plot = p, width = 11.5, height = 14, units = "in")  # Adjust the height as needed

# Include the saved plot in the RMarkdown document
knitr::include_graphics("plot.png")
```


```{r TableAboutDIrectAndQuantifiable, echo=FALSE}

# Function to create summary tables for each measure_type
create_summary_table <- function(data, measure_type) {
  data %>%
    filter(measure_type == !!measure_type) %>%
    group_by(submeasure_type) %>%
    summarise(
      total = n(),
      Other = paste0(round(sum(replace_na(effectiveness_monitored == "Other", 0)) / total * 100), "%"),
      ΔBcurrent = paste0(round(sum(replace_na(effectiveness_monitored == "ΔBcurrent", 0)) / total * 100), "%"),
      ΔΣH = paste0(round(sum(replace_na(effectiveness_monitored == "ΔΣH", 0)) / total * 100), "%"),
      ΔΣF = paste0(round(sum(replace_na(effectiveness_monitored == "ΔΣF", 0)) / total * 100), "%"),
      ΔΣA = paste0(round(sum(replace_na(effectiveness_monitored == "ΔΣA", 0)) / total * 100), "%"),
      `Not monitored` = paste0(round((total - (sum(replace_na(effectiveness_monitored == "Other", 0)) + sum(replace_na(effectiveness_monitored == "ΔBcurrent", 0)) + sum(replace_na(effectiveness_monitored == "ΔΣH", 0)) + sum(replace_na(effectiveness_monitored == "ΔΣF", 0)) + sum(replace_na(effectiveness_monitored == "ΔΣA", 0)))) / total * 100), "%")
    )
}

# Filter the data frame for quantifiable measures only
measures_quantifiable <- measures_all_cleaned_EMP %>%
  filter(std_quantifiable %in% c("y"))

# Get unique measure types
measure_types <- unique(measures_quantifiable$measure_type)

# Create summary tables for each measure type
quantifiable_tables <- lapply(measure_types, function(mt) {
  create_summary_table(measures_quantifiable, mt)
})

# Print each table using kable
for (i in seq_along(quantifiable_tables)) {
  cat("\n### Measure Type:", measure_types[i], "\n")
  print(kable(quantifiable_tables[[i]], caption = paste("Count of quantifiable measures for", measure_types[i], "and whether they are monitored or not")))
}

# Filter the data frame for direct measures only
measures_direct <- measures_all %>%
  filter(std_direct %in% c("y"))

# Create summary tables for each measure type
direct_tables <- lapply(measure_types, function(mt) {
  create_summary_table(measures_direct, mt)
})

# Print each table using kable
for (i in seq_along(direct_tables)) {
  cat("\n### Measure Type:", measure_types[i], "\n")
  print(kable(direct_tables[[i]], caption = paste("Count of direct measures for", measure_types[i], "and whether they are monitored or not")))
}

```


Graph/Table with no. of measures per type for each EMU
NOTE THAT SOME EMU's are missing - should we link here?


```{r NoOfMeasuresPerEMU, echo=FALSE}

# Create the MeasuresPerTypeEMU to list it in new df
MeasuresPerTypeEMU <- measures_all %>%
  count(country, emu_name_short, measure_type) %>%
  spread(key = measure_type, value = n, fill = 0)

# Print the table using kable
kable(MeasuresPerTypeEMU, caption = "Number of Measures Per Country and EMU")

```


Number of measures per type TOTAL


```{r NoOfMeasuresTOTAL, echo=FALSE}
# Create the total data data frame
TotalData <- measures_all %>%
  count(measure_type) %>%
  spread(key = measure_type, value = n, fill = 0)

# Display the TotalData data frame
print(TotalData)

```

Graph of implementation percentage - stacked bars by measure type (implemented/partially implemented ... etc)


```{r ImplementationPercentage, echo=FALSE}

# Function to replace underscores with spaces and capitalize the first letter of each word
clean_names <- function(name) {
  if (!is.na(name)) {
    name <- gsub("_", " ", name)
    name <- tools::toTitleCase(name)
  }
  return(name)
}

# Apply the function to the progress column
measures_all_cleaned_EMP$progress <- sapply(measures_all_cleaned_EMP$progress, clean_names)
# Apply the function to the measure_type column
measures_all_cleaned_EMP$measure_type <- sapply(measures_all_cleaned_EMP$measure_type, clean_names)

# Replace values in the progress column
measures_all_cleaned_EMP$progress <- gsub("NA", "Not Available / Not Pertinent", measures_all_cleaned_EMP$progress)
measures_all_cleaned_EMP$progress <- gsub("NP", "Not Available / Not Pertinent", measures_all_cleaned_EMP$progress)
# ONE CZ "Other" changed to trap and transport
measures_all_cleaned_EMP$measure_type <- gsub("Other", "Hydropower and Obstacles", measures_all_cleaned_EMP$measure_type)

# Combine NA and "Not Available / Not Pertinent" into one category
measures_all_cleaned_EMP$progress[is.na(measures_all_cleaned_EMP$progress)] <- "Not Available / Not Pertinent"

# Create a contingency table that includes NA values
ProgressCountTable <- table(measures_all_cleaned_EMP$measure_type, measures_all_cleaned_EMP$progress)

# Convert the table to a data frame
ProgressCountTable <- as.data.frame.matrix(ProgressCountTable)

# Normalize the data to get percentages
ProgressCountTable_percent <- sweep(ProgressCountTable, 1, rowSums(ProgressCountTable), FUN = "/") * 100

# Convert the data frame to long format for ggplot2
ProgressCountTable_long <- as.data.frame(ProgressCountTable_percent)
ProgressCountTable_long$measure_type <- rownames(ProgressCountTable_long)
ProgressCountTable_long <- tidyr::gather(ProgressCountTable_long, key = "progress", value = "percentage", -measure_type)

# Assuming ProgressCountTable contains the original counts
ProgressCountTable_counts_long <- as.data.frame(ProgressCountTable)
ProgressCountTable_counts_long$measure_type <- rownames(ProgressCountTable_counts_long)
ProgressCountTable_counts_long <- tidyr::gather(ProgressCountTable_counts_long, key = "progress", value = "count", -measure_type)

# Calculate the total counts for each measure_type
TotalCounts <- aggregate(count ~ measure_type, data = ProgressCountTable_counts_long, sum)
colnames(TotalCounts)[2] <- "total_count"


# Set the levels of the 'progress' factor in the desired order
ProgressCountTable_long$progress <- factor(ProgressCountTable_long$progress, 
                                           levels = c("Fully Implemented", "Partially Implemented", "Stopped", "Not Implemented", "Not Available / not Pertinent"))

# Merge the totals with the percentages
ProgressCountTable_long <- merge(ProgressCountTable_long, TotalCounts, by = "measure_type")

# Create the stacked bar chart with total counts as labels at the top of each bar
ggplot(ProgressCountTable_long, aes(x = measure_type, y = percentage, fill = progress)) +
  geom_bar(stat = "identity") +
  geom_text(data = TotalCounts, aes(x = measure_type, y = 100, label = paste0("n = ", total_count)), 
            vjust = -0.2, size = 3, inherit.aes = FALSE) +
  labs(x = "Measure Type", y = "Percentage", title = "", fill = "Progress") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()





```
```{r ImplementationPercentage_byCountry, echo=FALSE}
# Function to replace underscores with spaces and capitalize the first letter of each word
clean_names <- function(name) {
  if (!is.na(name)) {
    name <- gsub("_", " ", name)
    name <- tools::toTitleCase(name)
  }
  return(name)
}

# Apply the function to the progress column
measures_all_cleaned_EMP$progress <- sapply(measures_all_cleaned_EMP$progress, clean_names)
# Apply the function to the measure_type column
measures_all_cleaned_EMP$measure_type <- sapply(measures_all_cleaned_EMP$measure_type, clean_names)

# Replace values in the progress column
measures_all_cleaned_EMP$progress <- gsub("NA", "Not Available / Not Pertinent", measures_all_cleaned_EMP$progress)
measures_all_cleaned_EMP$progress <- gsub("NP", "Not Available / Not Pertinent", measures_all_cleaned_EMP$progress)
# ONE CZ "Other" changed to trap and transport
measures_all_cleaned_EMP$measure_type <- gsub("Other", "Hydropower and Obstacles", measures_all_cleaned_EMP$measure_type)

# Combine NA and "Not Available / Not Pertinent" into one category
measures_all_cleaned_EMP$progress[is.na(measures_all_cleaned_EMP$progress)] <- "Not Available / Not Pertinent"

# Ensure 'progress' column has all levels
measures_all_cleaned_EMP$progress <- factor(measures_all_cleaned_EMP$progress, 
                                            levels = c("Fully Implemented", "Partially Implemented", "Stopped", "Not Implemented", "Not Available / Not Pertinent"))

# Create a contingency table that includes NA values
ProgressCountTable <- table(measures_all_cleaned_EMP$measure_type, measures_all_cleaned_EMP$progress, measures_all_cleaned_EMP$country)

# Convert the table to a data frame
ProgressCountTable <- as.data.frame(ProgressCountTable)

# Normalize the data to get percentages
ProgressCountTable_percent <- ProgressCountTable %>%
  group_by(Var1, Var3) %>%
  mutate(Freq = Freq / sum(Freq) * 100)

# Rename columns for clarity
colnames(ProgressCountTable_percent) <- c("measure_type", "progress", "country", "percentage")

# Calculate the total counts for each measure_type and country
TotalCounts <- ProgressCountTable %>%
  group_by(Var1, Var3) %>%
  summarise(total_count = sum(Freq))

# Rename columns for clarity
colnames(TotalCounts) <- c("measure_type", "country", "total_count")

# Merge the totals with the percentages
ProgressCountTable_long <- merge(ProgressCountTable_percent, TotalCounts, by = c("measure_type", "country"))

# Set the levels of the 'progress' factor in the desired order
ProgressCountTable_long$progress <- factor(ProgressCountTable_long$progress, 
                                           levels = c("Fully Implemented", "Partially Implemented", "Stopped", "Not Implemented", "Not Available / Not Pertinent"))

# Create the stacked bar chart with total counts as labels at the top of each bar
p2 = ggplot(ProgressCountTable_long, aes(x = measure_type, y = percentage, fill = progress)) +
  geom_bar(stat = "identity") +
  geom_text(aes(x = measure_type, y = 95, label = paste0("n = ", total_count)), 
            vjust = -0.5, size = 3, inherit.aes = FALSE) +
  labs(x = "Measure Type", y = "Percentage", title = "", fill = "Progress") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        strip.text = element_text(face = "bold")) +
  scale_fill_viridis_d() +
  facet_wrap(~ country, ncol = 3)

# Save the plot with increased height
ggsave("plot2.png", plot = p2, width = 11.5, height = 14, units = "in")  # Adjust the height as needed

# Include the saved plot in the RMarkdown document
knitr::include_graphics("plot2.png")
```
```


Graph/Table with no. of measures per type for each country


```{r NoOfMeasuresPerCountry, echo=FALSE}
# Apply the function to clean the columns
measures_all_cleaned_EMP$measure_type <- sapply(measures_all_cleaned_EMP$measure_type, clean_names)

# Create the MeasuresPerType to show data
MeasuresPerType <- measures_all_cleaned_EMP %>%
  count(country, measure_type) %>%
  spread(key = measure_type, value = n, fill = 0)

# Calculate the total measures per country
TotalMeasuresPerCountry <- measures_all_cleaned_EMP %>%
  count(country) %>%
  rename(total = n)

# Merge the total measures with the MeasuresPerType
MeasuresPerType <- MeasuresPerType %>%
  left_join(TotalMeasuresPerCountry, by = "country")

# Calculate the percentage and format the values
MeasuresPerType <- MeasuresPerType %>%
  mutate(across(-c(country, total), ~ paste0(.x, " (", round(.x / total * 100, 1), "%)")))

# Remove the total column as it's no longer needed
MeasuresPerType <- MeasuresPerType %>%
  select(-total)


# Print using kable
kable(MeasuresPerType, caption = "Number of Measures Per Country with Percentages")

```


Graph of effectiveness monitored - stacked bars by measure type (implemented, etc

We may need to check if a value is provided


```{r EffectivenesMonitored, echo=FALSE}
# Replace values in the effectiveness_monitored column
measures_all$effectiveness_monitored <- gsub("Î”Î£F", "ΔΣF", measures_all$effectiveness_monitored)
measures_all$effectiveness_monitored <- gsub("Î”Bcurrent", "ΔBcurrent", measures_all$effectiveness_monitored)
measures_all$effectiveness_monitored <- gsub("%Bcurrent", "ΔBcurrent", measures_all$effectiveness_monitored)
measures_all$effectiveness_monitored <- gsub("Î”Î£H", "ΔΣH", measures_all$effectiveness_monitored)
measures_all$effectiveness_monitored <- gsub("other", "Other", measures_all$effectiveness_monitored)

# Create a contingency table
EffectivenessCountTable <- table(measures_all$measure_type, measures_all$effectiveness_monitored)

# Convert the table to a data frame
EffectivenessCountTable <- as.data.frame.matrix(EffectivenessCountTable)

# Calculate the total counts for each measure type
TotalCounts <- data.frame(
  measure_type = rownames(EffectivenessCountTable),
  total_count = rowSums(EffectivenessCountTable)
)

# Convert the data frame to long format for ggplot2
EffectivenessCountTable_long <- as.data.frame(EffectivenessCountTable)
EffectivenessCountTable_long$measure_type <- rownames(EffectivenessCountTable_long)
EffectivenessCountTable_long <- tidyr::gather(EffectivenessCountTable_long, key = "effectiveness_monitored", value = "count", -measure_type)

# Create the stacked bar chart with total counts as labels at the top of each bar
ggplot(EffectivenessCountTable_long, aes(x = measure_type, y = count, fill = effectiveness_monitored)) +
  geom_bar(stat = "identity") +
  geom_text(data = TotalCounts, aes(x = measure_type, y = total_count, label = paste0("n = ", total_count)), 
            vjust = -0.2, size = 3, inherit.aes = FALSE) +
  labs(x = "Measure Type", y = "Count", title = "", fill = "Effectiveness Monitored") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()

```

By year implemented measures with direct effect - stacked bar (high/medium low impact)
NOTE THE YEAR NA IS DIVIDED BY 10

```{r ByYearImplementedMeasures, echo=FALSE}
# Update the impact column values
measures_all_cleaned_EMP$impact <- gsub("high", "High", measures_all_cleaned_EMP$impact)
measures_all_cleaned_EMP$impact <- gsub("indirect", "Not direct", measures_all_cleaned_EMP$impact)
measures_all_cleaned_EMP$impact <- gsub("none", "None", measures_all_cleaned_EMP$impact)

# Create the new data frame with year_of_full_implementation and impact
ImpactByYear <- measures_all_cleaned_EMP %>%
  select(year_of_full_implementation, impact)

# Clean NAs
ImpactByYear$impact[is.na(ImpactByYear$impact)] <- "N/A"

ImpactByYear <- ImpactByYear %>%
  mutate(year_of_full_implementation = as.character(year_of_full_implementation),
         year_of_full_implementation = trimws(year_of_full_implementation),
         year_of_full_implementation = ifelse(is.na(year_of_full_implementation) | 
                                              year_of_full_implementation == "The EMU has not reported any information for that sub measure" | 
                                              year_of_full_implementation == "The EMU has not reported any information", 
                                              "NA", 
                                              year_of_full_implementation))

# Adjust the count of "NA" entries by dividing by 10 and rename to "NA *"
ImpactByYear <- ImpactByYear %>%
  group_by(year_of_full_implementation, impact) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(year_of_full_implementation = ifelse(year_of_full_implementation == "NA", "NA *", year_of_full_implementation),
         count = ifelse(year_of_full_implementation == "NA *", count / 10, count))

# Create the stacked bar chart
ggplot(ImpactByYear, aes(x = factor(year_of_full_implementation), y = count, fill = factor(impact))) +
  geom_bar(stat = "identity") +
  labs(x = "Year", y = "Number of measures fully implemented", title = "", fill = "Impact") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()
```

```{r ImpactVsMeasure, echo=FALSE}

measures_all$impact <- gsub("high", "High", measures_all$impact)
measures_all$impact <- gsub("indirect", "Not direct", measures_all$impact)
measures_all$impact <- gsub("none", "None", measures_all$impact)


# Create the new data frame with year_of_full_implementation and impact
ImpactByType <- measures_all %>%
  select(measure_type, impact)

#clean NAs
ImpactByType$impact[is.na(ImpactByType$impact)] <- "NA"

ImpactByType <- ImpactByType %>%
  mutate(measure_type = as.character(measure_type),
         measure_type = trimws(measure_type),
         measure_type = ifelse(is.na(measure_type) | 
                                              measure_type == "The EMU has not reported any information for that sub measure" | 
                                              measure_type == "The EMU has not reported any information", 
                                              "NA", 
                                              measure_type))

# Make counts and adjust NAs
ImpactByType <- ImpactByType %>%
  group_by(measure_type, impact) %>%
  summarise(count = n()) %>%
  ungroup()

# Create the stacked bar chart
ggplot(ImpactByType, aes(x = factor(measure_type), y = count, fill = factor(impact))) +
  geom_bar(stat = "identity") +
  labs(x = "Measure Type", y = "Count of Impact", title = "", fill = "Impact") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()

```

```{r OnlyHighImpact, echo=FALSE}

# Filter the data frame for EMU only
measures_HighImpact <- measures_all %>%
  filter(impact %in% c("High", "Intermediate", "Low"))



# Create the new data frame with needed columns
HighImpact <- measures_HighImpact %>%
  select(measure_type, impact, std_direct, effectiveness_monitored)

#clean NAs
HighImpact$impact[is.na(HighImpact$impact)] <- "NA"

HighImpact <- HighImpact %>%
  mutate(measure_type = as.character(measure_type),
         measure_type = trimws(measure_type),
         measure_type = ifelse(is.na(measure_type) | 
                                              measure_type == "The EMU has not reported any information for that sub measure" | 
                                              measure_type == "The EMU has not reported any information", 
                                              "NA", 
                                              measure_type))

#How many are monitored

#combine Na not monitored and other to one group
HighImpact$effectiveness_monitored <- gsub("NA", "No monitoring", HighImpact$effectiveness_monitored)
HighImpact$effectiveness_monitored <- gsub("Other", "No monitoring", HighImpact$effectiveness_monitored)
HighImpact$effectiveness_monitored <- gsub("Not monitored", "No monitoring", HighImpact$effectiveness_monitored)

#clean NAs
HighImpact$effectiveness_monitored[is.na(HighImpact$effectiveness_monitored)] <- "No monitoring"

# Make counts and adjust NAs
HighImpact_count <- HighImpact %>%
  group_by(measure_type, effectiveness_monitored) %>%
  summarise(count = n()) %>%
  ungroup()


# Create the stacked bar chart
ggplot(HighImpact_count, aes(x = factor(measure_type), y = count, fill = factor(effectiveness_monitored))) +
  geom_bar(stat = "identity") +
  labs(x = "Measure Type", y = "Count of Impact", title = "", fill = "Effectiveness monitored") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()



```





```{r DirectEffect, echo=FALSE}

#How many have direct effect

#combine Na not monitored and other to one group
measures_all$std_direct[is.na(measures_all$std_direct)] <- "NA"


# Make counts and adjust NAs
DirectEffect_count <- measures_all %>%
  group_by(measure_type, std_direct) %>%
  summarise(count = n()) %>%
  ungroup()


# Create the stacked bar chart
ggplot(DirectEffect_count, aes(x = factor(measure_type), y = count, fill = factor(std_direct))) +
  geom_bar(stat = "identity") +
  labs(x = "Measure Type", y = "Count of Impact", title = "", fill = "Direct effect") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_viridis_d()

```

No of quantifiable measures vs measures with a set target (by measure type, country?)

```{r QUantifiableMeasures, echo=FALSE}
# Create a new dataframe with relevant columns
measures_summary <- measures_all %>%
  select(country, measure_type, std_quantifiable, target_value)

# Count the number of rows where std_quantifiable is "y" per country
quantifiable_measures <- measures_summary %>%
  filter(std_quantifiable == "y") %>%
  group_by(country, measure_type) %>%
  summarise(count_quantifiable = n())

# Count the number of rows where measures_all$target_value is not in the specified list and is not NA
target_measures <- measures_summary %>%
  filter(!target_value %in% c("ND", "Not monitored", "Not established", "not specified", "NA") & !is.na(target_value)) %>%
  group_by(country, measure_type) %>%
  summarise(count_target = n())

# Merge the two dataframes
measures_summary <- quantifiable_measures %>%
  full_join(target_measures, by = c("country", "measure_type")) %>%
  replace_na(list(count_quantifiable = 0, count_target = 0))

# View the summary dataframe
print(measures_summary)

```

Objective defined vs objective evaluated. UNCLEAR WHICH FIELDS TO USE!!

```{r DefinedVsEvaluatedObjective, echo=FALSE}
# Create a new dataframe with relevant columns
summary_data <- measures_all %>%
  select(country, measure_type, std_objective, objective)

# Count the number of rows where std_objective is "y" per country
quantifiable_summary <- summary_data %>%
  filter(std_objective == "y") %>%
  group_by(country, measure_type) %>%
  summarise(count_std_objective = n())

# Count the number of rows where objective is not in the specified list and is not NA
target_summary <- summary_data %>%
  filter(!objective %in% c("np", "NA", ".NA") & !is.na(objective)) %>%
  group_by(country, measure_type) %>%
  summarise(count_target = n())

# Merge the two dataframes
final_summary <- quantifiable_summary %>%
  full_join(target_summary, by = c("country", "measure_type")) %>%
  replace_na(list(count_std_objective = 0, count_target = 0))

# View the final summary dataframe
print(final_summary)

```

Sthgin with immediate / direct

```{r ImmediateDirect, echo=FALSE}


```







OTHER LIKELY NOT NEEDED STUFF BELOW


Objective there but no feedback in these ones

```{r ObjectiveFeedback, echo=FALSE}
# Create a new data frame for rows where objective is not NA and objective_feedback is NA
missing_feedback <- measures_all %>%
  filter(!is.na(objective) & (is.na(objective_feedback) | objective_feedback %in% c("No", "no", "NO")))
```

These EMUs are missing

```{r MissingEmus, echo=FALSE}

# Filter to show only the emus that are not found in measures_all
emus_not_found <- all_emus %>%
  left_join(measures_all %>% select(emu_name_short), by = character(0)) %>%
  group_by(emu) %>%
  summarise(found = any(emu %in% emu_name_short)) %>%
  filter(!found) %>%
  select(emu) %>%
  ungroup()

# Merge the dataframes on the 'emu' column to add the 'country' column to emus_not_found
emus_not_found <- merge(emus_not_found, all_emus[, c('emu', 'country')], by = 'emu', all.x = TRUE)

# Group by country and create a list of emus for each country
grouped_data <- emus_not_found %>%
  group_by(country) %>%
  summarise(emus = paste(emu, collapse = ', '))

# Print the table in RMarkdown format
cat("### Emus by Country\n")
for (i in 1:nrow(grouped_data)) {
  cat("**", grouped_data$country[i], "**\n\n")
  cat(grouped_data$emus[i], "\n\n")
}

```












###SUMMARY TABLES START FROM HERE, for the report



Function for creating tables

```{r CreatingTypeTables, include=FALSE}
create_measure_tables <- function(measures_data, measure_type) {
  # Filter, summarize, and pivot the data
  table_data <- measures_data %>%
    filter(measure_type == !!measure_type) %>%
    group_by(country, submeasure_type) %>%
    summarise(count = n(), .groups = 'drop') %>%
    pivot_wider(names_from = submeasure_type, values_from = count, values_fill = list(count = 0))
  
  # Calculate the number of unique emu_name_short for each country
  emu_counts <- measures_data %>%
    filter(measure_type == !!measure_type) %>%
    group_by(country) %>%
    summarise(emu_count = n_distinct(emu_name_short), .groups = 'drop')
  
  # Divide the counts by the number of unique emu_name_short
  table_data <- table_data %>%
    left_join(emu_counts, by = "country") %>%
    mutate(across(-country, ~ round(. / emu_count, 1))) %>%
    select(-emu_count)
  
  # Consistency check
  inconsistent_values <- measures_data %>%
    filter(measure_type == !!measure_type) %>%
    group_by(country, emu_name_short, submeasure_type) %>%
    summarise(row_count = n(), .groups = 'drop') %>%
    pivot_wider(names_from = submeasure_type, values_from = row_count, values_fill = list(row_count = 0)) %>%
    pivot_longer(cols = -c(country, emu_name_short), names_to = "submeasure_type", values_to = "row_count") %>%
    group_by(country, submeasure_type) %>%
    summarise(all_same = n_distinct(row_count) == 1, .groups = 'drop') %>%
    filter(!all_same)
  
  inconsistent_details <- measures_data %>%
    filter(measure_type == !!measure_type) %>%
    group_by(country, emu_name_short, submeasure_type) %>%
    summarise(row_count = n(), .groups = 'drop') %>%
    pivot_wider(names_from = submeasure_type, values_from = row_count, values_fill = list(row_count = 0)) %>%
    pivot_longer(cols = -c(country, emu_name_short), names_to = "submeasure_type", values_to = "row_count") %>%
    semi_join(inconsistent_values, by = c("country", "submeasure_type")) %>%
    pivot_wider(names_from = submeasure_type, values_from = row_count, values_fill = list(row_count = 0))
  
  return(list(main_table = table_data, consistency_check = inconsistent_details))
}



```

This table is number of measures per country, put averaged per number of EMUs

```{r Measure_per_country_stocking, echo=FALSE}
# Select usage
measure_type <- "Stocking"
result <- create_measure_tables(measures_all, measure_type)

# Display the results
knitr::kable(result$main_table, caption = paste("Number of Measures by Country and Submeasure Type for", measure_type))

knitr::kable(result$consistency_check, caption = "Inconsistent Values by Country, EMU Name Short, and Submeasure Type")

```

This table is number of measures per country, but averaged per number of EMUs

```{r Measure_per_country_ComFish, echo=FALSE}
# Select usage
#measure_type <- "Commercial_fishery"
#result <- create_measure_tables(measures_all, measure_type)

# Display the results
#knitr::kable(result$main_table, caption = paste("Number of Measures by Country and Submeasure Type for", measure_type))

#knitr::kable(result$consistency_check, caption = "Inconsistent Values by Country, EMU Name Short, and Submeasure Type")

```



#Then we checked the information per country

```{r CountryTables_html, echo=FALSE}

# Function to create and print the table for each country
print_country_tables <- function(data, output_format = "html") {
  # Get all unique measure types to ensure all tables have the same columns
  all_measure_types <- unique(data$measure_type)
  
  countries <- unique(data$country)
  
  for (country in countries) {
    country_data <- data %>%
      filter(country == !!country) %>%
      group_by(emu_name_short, measure_type) %>%
      summarise(count = n(), .groups = 'drop') %>%
      complete(emu_name_short, measure_type = all_measure_types, fill = list(count = 0)) %>%
      pivot_wider(names_from = measure_type, values_from = count, values_fill = list(count = 0))
    
    cat("\n\n# ", country, "\n\n")
    
    # HTML Output: use kable
    if (output_format == "html") {
      print(
        kable(country_data, caption = paste("Count of Measures by EMU Name Short and Measure Type for", country)) %>%
          kable_styling(full_width = FALSE, position = "left")
      )
    }
    
    # Word Output: use flextable
    if (output_format == "word") {
      ft <- flextable(country_data) %>%
        compose(j = colnames(country_data), value = as_paragraph(as_text(country_data[[j]])))
      print(ft)
    }
    
    cat("\\newpage\n")
  }
}


```


```{r CountryTables_htmlprint, results='asis'}
# Call the function with your data for HTML output
print_country_tables(measures_all, output_format = "html")
```



#### Other tasks

measures_all$std_quantifiable

```{r}
# TASK:	Create a summary table/graph with the number of measures in total, the number of quantifiable measures, the number of quantified measures and the number of quantified & evaluated measures – check with 2c) and see what works…  #THIS IS NOT FINISHED!!!

#IS THERE A TARGET VALUE WHEN THERE IS quantifiable measure

# Count all rows
total_rows <- nrow(measures_all)

print(total_rows)
```



```{r TODO, echo=FALSE}


# Task:	Check where quantification is not provided but could have been (if that is feasible; check if we can script this in a meaningful way) and draft a request to countries to provide that information 



```




