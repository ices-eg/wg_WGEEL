---
title: "Analysis of Biomass and Mortality (quality checks)"
author: "WKEMP"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: word_document
---

```{r setup, include=FALSE}
# setwd("C:/workspace/wg_WGEEL/Misc/WKEMP")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(RPostgres)
library(sf)
library(getPass)
library(ggforce)
library(ggplot2)
library(flextable)
set_flextable_defaults("big.mark"=" ")
set_flextable_defaults("big.mark"=" ")
library(tidyverse)
library(yaml)
library(naniar)
cred <- read_yaml("../../credentials.yml")
con <- dbConnect(Postgres(), dbname = cred$dbname, host = cred$host, port = cred$port, user = cred$user, password = cred$password)
load("../../R/shiny_data_visualisation/shiny_dv/data/maps_for_shiny.Rdata")
load("../../R/shiny_data_visualisation/shiny_dv/data/ref_and_eel_data.Rdata")
eu_cou_codes <- c("AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE", "FI", "FR", "DE", "GR", "HU", "IE", "IT", "LV", "LT", "LU", "MT", "NL", "PL", "PT", "RO", "SK", "SI", "ES", "SE")
```

# Downloading data

```{r download}
biomass <- dbGetQuery(con, "select e.* from datawg.t_eelstock_eel e
  where eel_qal_id in (0,1,2,3,4) and eel_typ_id in (13,14,15,34)")

mortality <- dbGetQuery(con, "select e.* from datawg.t_eelstock_eel e
where eel_qal_id in (0,1,2,3,4) and eel_typ_id in (17,18,19)")


nb_country_emu <- dbGetQuery(con, "select count(distinct eel_cou_code),
count(distinct(eel_emu_nameshort))
from datawg.t_eelstock_eel
                             where eel_typ_id in (13, 14, 15, 17, 18, 19,34)
                              and eel_datasource='dc_2021'")
avgindicator <- dbGetQuery(con, "select eel_cou_code,eel_emu_nameshort, avg(b0)b0,avg(bbest)bbest,avg(bcurrent)bcurrent, avg(bcurrent_without_stocking)bcurrent_without_stocking, avg(suma)suma,avg(sumf)sumf,avg(sumh) sumh from datawg.precodata_emu where eel_year>=2020 group by eel_cou_code,eel_emu_nameshort") %>%
  mutate(eel_emu_nameshort = ifelse(eel_cou_code == "NL", "NL_Neth", eel_emu_nameshort))
avgindicator <- merge(emu_c, avgindicator, by.x = "emu_nameshort", by.y = "eel_emu_nameshort", all.x = TRUE)
avgindicator <- st_transform(avgindicator, crs = 3035)
avgindicator$x <- st_coordinates(avgindicator)[, 1]
avgindicator$y <- st_coordinates(avgindicator)[, 2]
avgindicator$btarget <- .4 * avgindicator$b0
avgindicator$bscaled <- avgindicator$bcurrent / avgindicator$b0

prettyscale <- pretty(range(avgindicator$bcurrent, na.rm = TRUE), n = 2)
prettyscale_scaled <- scales::rescale(prettyscale, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrent, na.rm = TRUE)))
scalesb <- data.frame(b = prettyscale, bscale = prettyscale_scaled)
# avgindicator$btarget <- scales::rescale(avgindicator$btarget,to=c(40190.79,200000.00),from=c(661,10400000))
avgindicator$bcurrent <- scales::rescale(avgindicator$bcurrent, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrent, na.rm = TRUE)))
# avgindicator$bbest <- scales::rescale(avgindicator$bbest,to=c(40190.79,200000.00),from=c(661,10400000))
# avgindicator$b0 <- scales::rescale(avgindicator$b0,to=c(40190.79,200000.00),from=c(661,10400000))

avgindicator$bnorestockscaled <- avgindicator$bcurrent_without_stocking / avgindicator$b0
prettyscale_norestock <- pretty(range(avgindicator$bcurrent_without_stocking, na.rm = TRUE), n = 2)
prettyscale_norestock_scaled <- scales::rescale(prettyscale_norestock, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrent_without_stocking, na.rm = TRUE)))
scalesb_norestock <- data.frame(b = prettyscale_norestock, bscale = prettyscale_norestock_scaled)
avgindicator$bcurrent_without_stocking <- scales::rescale(avgindicator$bcurrent_without_stocking, to = c(40190.79, 200000.00), from = c(661, max(avgindicator$bcurrent_without_stocking, na.rm = TRUE)))

# avgindicator$bcurrent <- log(avgindicator$bcurrent)/log(max(avgindicator$b0,na.rm=TRUE))*100000
# avgindicator$bbest <- log(avgindicator$bbest)/log(max(avgindicator$b0,na.rm=TRUE))*100000
# avgindicator$b0 <- log(avgindicator$b0)/log(max(avgindicator$b0,na.rm=TRUE))*100000
avgindicator$suma <- avgindicator$suma / .92 * 20000
avgindicator$sumf <- avgindicator$sumf / .92 * 20000
avgindicator$sumh <- avgindicator$sumh / .92 * 20000

avgindicator$x[avgindicator$eel_cou_code == "NO"] <- 4172612.3
avgindicator$y[avgindicator$eel_cou_code == "NO"] <- 4111023.3

indicator <- dbGetQuery(con, "select eel_year,eel_cou_code,eel_emu_nameshort, b0,bbest,bcurrent, bcurrent_without_stocking, suma,sumf, sumh from datawg.precodata_emu")
# indicator <- indicator %>%
#   mutate(eel_cou_code = ifelse(eel_cou_code == substr(eel_emu_nameshort, 1, 2),
#     eel_cou_code,
#     "ES_Minh"
#   ))

```

# Initial data checks

Checks were done to see which countries have reported and what corresponds to the 
lastest value in the database.

The following countries have not responded to the DATA call annexes x- to X:
Non-EU countries:

*	Albania (AL)
*	Åland Islands (AX)
*	Bosnia and Herzegovina (BA)
*	Algeria (DZ)
*	Egypt (EG)
*	Israel (IL)
*	Iceland (IS)
*	Libya (LY)
*	Morocco (MA)
*	Montenegro (ME)
*	Russia (RU)
*	Syria (SY)
*	Tunisia (TN)
*	Turkey (TR)

EU countries:

*	Cyprus (CY)
*	Czech Republic (CZ)
*	Italy (IT)
*	Luxembourg (LU)
*	Malta (MT)
*	Slovenia (SI)

Cyprus and Malta are exempted from providing a management plan. Romania, Austria and Slovakia are in the Black Sea region and also exempted by the commission from providing a management plan. The only EU country that did not report data for biomass and mortality was Italy. Italy reported indicators in the past, but during the 2024 WGEEL Italy had no indicators with quality ID 1 in the database, as all Italy indicators were deleted prior to the 2021 datacall (the format of the data was changed in 2021 and all biomass and mortality data were replaced). From 2019 onwards no new assessment estimates have been made, so indicator values from 2019 onwards should be NR.

```{r notans}
not_reported <- country_p$cou_code[!country_p$cou_code %in% c(biomass$eel_cou_code, mortality$eel_cou_code)] # countries with no reported data on biomass or mortality for any EMU for any year

sprintf("Countries not reporting (outside EU) : %s.", paste(sort(not_reported[!not_reported %in% eu_cou_codes]), collapse =', '))

# Same, but only EU countries, who are mandated to report biomass and mortality indicators
not_reported_EU <- not_reported[not_reported %in% eu_cou_codes]

sprintf("Countries not reporting in the EU : %s.", paste(sort(not_reported_EU), collapse =', '))
```

## Importance of landings for Italy
Values of reported landings, averaged over 5 last years:

```{r fisheriesmissingEU}
landings <- dbGetQuery(con, paste0(
  "select eel_value,eel_cou_code,eel_lfs_code,eel_year from datawg.t_eelstock_eel where eel_cou_code in ('",
  paste(not_reported, collapse = "','"),
  "') and eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2020"
)) %>%
  # First, calculate total landings per country per lifestage per year
  group_by(eel_year, eel_lfs_code, eel_cou_code) %>%
  summarize(eel_value = sum(eel_value, na.rm = TRUE)) %>%
  # Then, from there, calculate mean landings per country per lifestage over the past 5 years
  group_by(eel_cou_code, eel_lfs_code) %>%
  summarize(landings = mean(eel_value, na.rm = TRUE) / 1e3) %>%
  pivot_wider(names_from = eel_lfs_code, values_from = landings)

# Get total landings reported per year to compare with
tot_landings_EU <- dbGetQuery(con, paste0("select eel_value,eel_lfs_code,eel_year, eel_cou_code from datawg.t_eelstock_eel where eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2020")) %>%
  filter(eel_cou_code %in% eu_cou_codes) %>%
  group_by(eel_year, eel_lfs_code) %>%
  summarize(eel_value = sum(eel_value, na.rm = TRUE)) %>%
  group_by(eel_lfs_code) %>%
  summarize(landings = mean(eel_value, na.rm = TRUE) / 1e3) %>%
  mutate(eel_cou_code = "OVERALL TOTAL EU") %>%
  pivot_wider(names_from = eel_lfs_code, values_from = landings)

tot_landings <- dbGetQuery(con, paste0("select eel_value,eel_lfs_code,eel_year from datawg.t_eelstock_eel where eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2020")) %>%
  group_by(eel_year, eel_lfs_code) %>%
  summarize(eel_value = sum(eel_value, na.rm = TRUE)) %>%
  group_by(eel_lfs_code) %>%
  summarize(landings = mean(eel_value, na.rm = TRUE) / 1e3) %>%
  mutate(eel_cou_code = "OVERALL TOTAL") %>%
  pivot_wider(names_from = eel_lfs_code, values_from = landings)

# First, a table for all countries that did not report indicators
# flextable(landings %>%
#   bind_rows(tot_landings) %>%
#   select(eel_cou_code, G, Y, YS, S)) %>%
#   colformat_double(digits = 1)

# Then, a table for all EU countries that did not report indicators
tableit <- landings %>%
  filter(eel_cou_code %in% eu_cou_codes) %>%
  bind_rows(tot_landings_EU) %>%
  bind_rows(tot_landings) %>%
  select(eel_cou_code, G, Y, YS, S)

flextable(tableit) %>%
  colformat_double(digits = 1)
```

After 2020 on average, total reported landings from yellow and silver eel fisheries across all countries amounted to `r round(sum(tableit[3,c(3:5)]))` tons. In comparison, Italy's reported average landings for 5 years reached `r round(sum(tableit[1,c(3:5)], na.rm =TRUE))` tons, contributing approximately for `r round(100*sum(tableit[1,c(3:5)], na.rm =TRUE)/sum(tableit[3,c(3:5)]),1)` of the total landings.


```{r eval=FALSE}
d.italy <- dbGetQuery(con, "select e.* from datawg.t_eelstock_eel e where eel_typ_id in (13,14,15,34,17,18,19) and eel_cou_code = 'IT'")

# Organise data to send to Italy for double checking
d.italy <- d.italy %>%
  filter(eel_year > 1900) %>%
  mutate(indicator = case_match(
    eel_typ_id,
    13 ~ "b0",
    14 ~ "bbest",
    15 ~ "bcurrent",
    17 ~ "sumA",
    18 ~ "sumF",
    19 ~ "sumH",
    34 ~ "bcurrent_without_restocking"
  )) %>%
  select(
    eel_cou_code,
    eel_emu_nameshort,
    indicator,
    eel_year,
    eel_value,
    eel_missvaluequal,
    eel_lfs_code,
    eel_hty_code,
    eel_comment,
    eel_datelastupdate,
    eel_datasource
  ) %>%
  arrange(
    eel_cou_code,
    eel_emu_nameshort,
    indicator,
    eel_year
  )

# Given that all data was deleted, check for duplicate data.
test_duplicate <- d.italy %>%
  select(
    eel_cou_code,
    eel_emu_nameshort,
    indicator,
    eel_year,
    eel_lfs_code,
    eel_hty_code
  ) %>%
  filter(duplicated(.)) # only retain duplicate rows
```


## Checking importance of landings in missing countries

Since mortality in Italy is fishery dominated, we can have a look to the trends in landings in early years.

```{r landingsfranceita}
landings <- dbGetQuery(con, paste0(
  "select sum(eel_value) eel_value,eel_cou_code,eel_lfs_code,eel_year,eel_emu_nameshort from datawg.t_eelstock_eel
                      where eel_cou_code in ('",
  paste(not_reported[not_reported %in% eu_cou_codes], collapse = "','"),
  "')
                      and eel_typ_id in (4,6) and eel_qal_id in (0,1,4) and eel_year >=2010
                      group by eel_cou_code,eel_lfs_code,eel_year,eel_emu_nameshort"
))

ggplot(landings, aes(x = eel_year, y = eel_value)) +
  geom_line(aes(col = eel_emu_nameshort), show.legend = FALSE) +
  scale_y_log10() +
  facet_grid(eel_lfs_code ~ eel_cou_code) +
  ylab("landings (t)") +
  xlab("")

ggsave("2024/image/landings.png", height = 12 / 2.54, width = 16 / 2.54, dpi = 300)
```

For Italy landings in some EMUs have decreased, or completely stopped. If that is due to management measures, then that could be a positive sign of possible improved escapement.

## When was the last value reported ?

The following table  inspects the indicator data of individual EMUs to check for latest reported value.


```{r indicator_ind}
#| tab.id: bookmark_id
#| tab.cap: "Table showing frequency of when an habitat coverage is reported as 0 or 100 % for the latest year of report, Bcurrentw = Bcurrent without restocking"
# Biomass indicator timeseries per EMU

biomass %>%
    bind_rows(mortality) %>%
    filter(eel_typ_id %in% c(14, 15, 17, 18, 19, 34)) %>%
    # complete(eel_emu_nameshort, eel_typ_id) %>% # Add NAs if info is missing for an EMU
    group_by(eel_cou_code, eel_emu_nameshort, eel_typ_id) %>%
    summarise(max_year = max(eel_year)) %>%
    ungroup() %>%
    mutate(eel_typ_id = case_match(
      eel_typ_id,
      14 ~ "bbest",
      15 ~ "bcurrent",
      34 ~ "bcurrentw",
      17 ~ "sumA",
      18 ~ "sumF",
      19 ~ "sumH"
    )) %>%
    pivot_wider(names_from = eel_typ_id, values_from = max_year)%>%
  rename("country"="eel_cou_code", "emu"="eel_emu_nameshort") %>%
  flextable() 
  


```


# Biomass


## Data availability

The following figures summarize the mortality and biomass indicators that were provided as a response to the ICES data call.
Maps showings data availability. The symbol indicates whether the country have provided estimates for at least one (whatever year), two , three distinct indicators.
There is a high variability among the indicators reported by the countries (Figure XX):

*	North African countries (Morocco, Algeria, Tunisia, Libya) and the Middle East have mostly no indicators 
*	The highest concentration of points with multiple indicators (2-4) is in Western and Central Europe.
*	The United Kingdom and some EMUs of Spain and France show a high share with 4 indicators.
*	There is a mixed distribution in Italy and the Balkans, with areas having between 1 and 3 indicators
*	The Nordic and Baltic countries also show a varied participation.


```{r visualize_datagaps1, fig.cap = "Figure XX Percentage of missing indicators from 2006 to 2023"}


indicator_vis <- expand.grid(eel_emu_nameshort = unique(indicator$eel_emu_nameshort),
                             eel_year = seq(2006, 2023, by = 1)) %>%
                                        left_join(indicator %>% select(eel_emu_nameshort, sumh, sumf, suma, bcurrent, bbest, b0, eel_year), by = c("eel_emu_nameshort" = "eel_emu_nameshort", "eel_year" = "eel_year"))

gg_miss_fct(x = indicator_vis %>% select(-eel_emu_nameshort), fct = eel_year)

ggplot(indicator_vis %>% select(eel_emu_nameshort, eel_year, b0) %>%
  mutate(b0 = ifelse(is.na(b0), "absent", "present")), 
  aes(eel_emu_nameshort, eel_year, fill = b0))+
  geom_tile() +
  scale_fill_manual(values=c("yellow2", "dark blue"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression("B"["0"]))
```
```{r visualize_datagaps2,}
#| fig.cap = "Figure XX $B_{current}$ availability per EMU from 2006 to 2023"
ggplot(indicator_vis %>% select(eel_emu_nameshort, eel_year, bcurrent) %>%
  mutate(bcurrent = ifelse(is.na(bcurrent), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = bcurrent)) +
  geom_tile() +
  scale_fill_manual(values=c("yellow2", "dark blue"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression("B"["current"]))
```
```{r visualize_datagaps3}
#| fig.cap = "Figure XX $\\sumA$ availability per EMU from 2006 to 2023"
ggplot(indicator_vis %>% select(eel_emu_nameshort, eel_year, suma) %>%
  mutate(suma = ifelse(is.na(suma), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = suma)) +
  geom_tile() +
  scale_fill_manual(values=c("yellow2", "dark blue"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste(Sigma," A")))
```
```{r visualize_datagaps4}
#| fig.cap = "Figure XX $\\sumF$ availability per EMU from 2006 to 2023"
ggplot(indicator_vis %>% select(eel_emu_nameshort, eel_year, sumf) %>%
  mutate(sumf = ifelse(is.na(sumf), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = sumf)) +
  geom_tile() +
  scale_fill_manual(values=c("yellow2", "dark blue"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
  ggtitle(expression(paste(Sigma," F")))
```
```{r visualize_datagaps5}
#| fig.cap = "Figure XX $\\sumH$ availability per EMU from 2006 to 2023"
ggplot(indicator_vis %>% select(eel_emu_nameshort, eel_year, suma) %>%
  mutate(suma = ifelse(is.na(suma), "absent", "present")), aes(eel_emu_nameshort, eel_year, fill = suma)) +
  geom_tile() +
  scale_fill_manual(values=c("yellow2", "dark blue"))+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = -0.001)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_blank(), legend.position = "bottom")+
  theme(legend.title = element_blank())+
  labs(x = "EMU", y = "year") +
    ggtitle(expression(paste(Sigma," H")))



```

Tab XX Summary of implementation progress and related effects in all reporting EMUs.

```{r indicatorsmapsbiomassavail, fig.height=8, fig.width=8, fig.cap= "Figure XX Biomass indicators ($B_{current}$, $B_{best}$, $B_0$) provided in each EMU. The colour of the points indicates the number of distinct indicators for which estimates were provided (for at least for one year out of all reported years). Where countries report mortality as non-pertinent (NP), this is treated as a reported indicator of zero."}
data_avail <- rbind.data.frame(mortality, biomass) %>%
  filter(!(is.na(eel_value) & eel_missvaluequal != "NP")) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    b0 = sum(eel_typ_id == 13) > 0,
    bbest = sum(eel_typ_id == 14) > 0,
    bcurrent = sum(eel_typ_id == 15) > 0,
    bcurrent_without_stocking_kg = sum(eel_typ_id == 34) > 0,
    suma = sum(eel_typ_id == 17) > 0,
    sumf = sum(eel_typ_id == 18) > 0,
    sumh = sum(eel_typ_id == 19) > 0
  ) %>%
  mutate(eel_emu_nameshort = ifelse(eel_emu_nameshort == "NL_total", "NL_Neth", eel_emu_nameshort))
data_avail <- merge(emu_c, data_avail, by.x = "emu_nameshort", by.y = "eel_emu_nameshort", all.x = TRUE)
data_avail <- st_transform(data_avail, crs = 3035)
data_avail$x <- st_coordinates(data_avail)[, 1]
data_avail$y <- st_coordinates(data_avail)[, 2]
data_avail$x[data_avail$emu_cou_code == "NO"] <- 4172612.3
data_avail$y[data_avail$emu_cou_code == "NO"] <- 4111023.3
data_avail <- data_avail %>%
  mutate(
    bsummary = coalesce(b0 + bbest + bcurrent + bcurrent_without_stocking_kg, 0),
    mortsummary = coalesce(suma + sumf + sumh, 0),
    responded = ifelse(is.na(bsummary) & is.na(mortsummary), FALSE, TRUE)
  )


ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail, aes(x = x, y = y, fill = as.factor(bsummary)), shape = 21, cex=2.5) +
  scale_fill_manual("Biomass indicators", 
                    labels = c("none", "one", "two", "three", "four"), 
                    values = c("grey", "yellow","orange","red","purple")) +
  xlab("") +
  ylab("") +
  theme(legend.position = "bottom")
ggsave(filename = "2024/image/biom.png", width = 16 / 2.54, height = 10 / 2.54, dpi = 300)

```


```{r indicatorsmapsbiomassdetails,fig.height=10, fig.width=10, fig.cap= "Figure XX Review of biomass indicators that have been reported per EMUS: $B_0$ (top left; $B_{best}$ (top right); $B_{current}$ (bottom left) and $B_{current}$_without_stocking_k (bottom right). Blue: TRUE (Reported), red: FALSE (Not Reported) Grey NA (Not Available/Not Applicable)"}
# Each biomass indicator:
data_avail_ind <- data_avail %>%
  gather(Bindicator, Reported, 5:8)

## Biomass

ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail_ind, aes(x = x, y = y, fill = Reported),  shape = 21, cex=2.5) +
  scale_fill_manual("Reported", labels = c("FALSE", "TRUE", "NA"), values = c("red", "blue", "grey")) +
  xlab("") +
  ylab("") +
  facet_wrap(~Bindicator) +
  theme(legend.position = "bottom")
```

## Map comparing the ratio between $B_{current}$ and $B_0$

```{r biomassmap, fig.cap="Figure x. Map of biomass indicators per EMU (average from 2021 to 2023). The size of the circle is proportional to Bcurrent while the colour is indicative of the ratio between Bcurrent and B0. A cross indicates that no data was reported. When B0 is not available (only Bcurrent), the circle is grey (e.g. Sweden, the Baltic). Here, reported B0 were used."}



# indicator <- indicator %>%
#   select(-sumh) %>%
#   pivot_longer(cols=c(suma,sumf,b0,btarget,bcurrent,bbest),names_to="indicator",values_to="r") %>%
#   mutate(start=ifelse(startsWith(indicator,"b"),pi,0),
#          end=ifelse(startsWith(indicator,"b"),2*pi,pi),
#          fill=case_when(indicator=="b0" ~ "grey",
#                         indicator=="bcurrent" ~ "green",
#                         indicator=="bbest" ~ "orange",
#                         indicator=="btarget" ~ "red",
#                         indicator=="sumf" ~ "yellow",
#                         indicator=="suma" ~ "blue"),
#          alpha=ifelse(indicator %in% c("b0","suma"),
#                       1,
#                       0)) %>%
#   arrange(desc(r))
#
#
#
# indicator <- merge(emu_c, indicator, by.x="emu_nameshort",by.y="eel_emu_nameshort")
# indicator = st_transform(indicator,crs=3035)
# indicator$x <-st_coordinates(indicator)[,1]
# indicator$y <-st_coordinates(indicator)[,2]

ggplot(st_transform(country_p, 3035)) +
  geom_sf(fill = NA, size = .1) +
  theme_bw() +
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = b0, start =pi,
  #                   end = 2*pi), fill = "grey",col=NA,alpha=1)+
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = btarget, start =pi,
  #                   end = 2*pi), fill = "red",col=NA,alpha=.6)+
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = bbest, start = pi,
  #                   end = 2*pi ), fill = "orange",col=NA,alpha=.6)+
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = bcurrent, start = pi,
  #                   end = 2*pi), fill = "green",col=NA,alpha=.6)+
  geom_arc_bar(data = avgindicator, aes(
    x0 = x, y0 = y, r0 = 0, r = bcurrent, start = 0,
    end = 2 * pi, fill = bscaled
  ), col = NA, alpha = 1) +
  xlab("") +
  ylab("") +
  geom_arc_bar(data = scalesb, aes(
    x0 = 3008000, y0 = 4200000, r0 = 0, r = bscale, start = pi,
    end = 2 * pi
  ), fill = NA, col = "black") +
  geom_text(
    data = scalesb, aes(x = 3050000, y = 4200000 + bscale, label = paste0(b / 1e3, "t")),
    size = 2, hjust = "left"
  ) +
  geom_point(
    data = avgindicator %>%
      filter(is.na(bcurrent)),
    aes(x = x, y = y), pch = "x"
  ) +
  scale_fill_viridis_c(expression(B[current] / B[0]))
# scale_alpha_manual("",values=c("B0" = 1,
#                        "Bcurrent" = .6,
#                        "Bbest"= .6,
#                        "Btarget" = .6,
#                        "sumF" = 1,
#                        "sumA" = 1))

ggsave(filename = "2024/image/maps_biomass.png", width = 16 / 2.54, height = 10 / 2.54)

```

```{r bcurrentwithoutstockinmap, fig.cap="Figure x. Map of mortality indicators per EMU (average from 2021 to 2023). The size of the circle is proportional to bcurrent_without_stocking while the colour is indicative of the ratio between Bcurren withoutstocking and B0. A cross indicates that no data was reported. When B0 is not available (only Bcurrent), the circle is grey (e.g. Sweden, the Baltic). Here, reported B0 were used."}

ggplot(st_transform(country_p, 3035)) +
  geom_sf(fill = NA, size = .1) +
  theme_bw() +
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = b0, start =pi,
  #                   end = 2*pi), fill = "grey",col=NA,alpha=1)+
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = btarget, start =pi,
  #                   end = 2*pi), fill = "red",col=NA,alpha=.6)+
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = bbest, start = pi,
  #                   end = 2*pi ), fill = "orange",col=NA,alpha=.6)+
  #  geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = bcurrent, start = pi,
  #                   end = 2*pi), fill = "green",col=NA,alpha=.6)+
  geom_arc_bar(data = indicator, aes(
    x0 = x, y0 = y, r0 = 0, r = bcurrent_without_stocking, start = 0,
    end = 2 * pi, fill = bnorestockscaled
  ), col = NA, alpha = 1) +
  xlab("") +
  ylab("") +
  geom_arc_bar(data = scalesb_norestock, aes(
    x0 = 3008000, y0 = 4200000, r0 = 0, r = bscale, start = pi,
    end = 2 * pi
  ), fill = NA, col = "black") +
  geom_text(
    data = scalesb_norestock, aes(x = 3050000, y = 4200000 + bscale, label = paste0(b / 1e3, "t")),
    size = 2, hjust = "left"
  ) +
  geom_point(
    data = indicator %>%
      filter(is.na(bcurrent_without_stocking)),
    aes(x = x, y = y), pch = "x"
  ) +
  scale_fill_viridis_c(expression(B[current_norestock] / B[0]))
# scale_alpha_manual("",values=c("B0" = 1,
#                        "Bcurrent" = .6,
#                        "Bbest"= .6,
#                        "Btarget" = .6,
#                        "sumF" = 1,
#                        "sumA" = 1))

ggsave(filename = "2024/image/maps_biomass_norestock.png", width = 16 / 2.54, height = 10 / 2.54)
```




# Mortality



## Data availability

```{r indicatorsmapsmortality, fig.height=12, fig.width=12, fig.cap= "Figure XX. Review of  Mortality indicators provided in each EMU. SumA: total anthropogenic mortality, sumf: fishery mortality,  sumh: hydropower mortality. Blue: TRUE (Reported), Red: FALSE (Not Reported) Grey NA (Not Available/Not Applicable)."}
# Mortality

data_avail_ind <- data_avail %>%
  gather(Mindicator, Reported, 9:11)

ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail_ind, aes(x = x, y = y, fill = Reported), shape = 21, cex=2.5) +
  scale_fill_manual("Reported", labels = c("FALSE", "TRUE", "NA"), values = c("red", "blue", "grey")) +
  xlab("") +
  ylab("") +
  facet_wrap(~Mindicator)

```

```{r indicatorsall, eval = FALSE}
## All indicators:

data_avail_ind <- data_avail %>%
  gather(Indicator, Reported, 5:11) %>%
  mutate(Indicator_type = case_when(Indicator %in% c(
    "b0",
    "bbest",
    "bcurrent",
    "bcurrent_without_stocking_kg"
  )
  ~ "Biomass", TRUE ~ "Mortality"))

ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail_ind, aes(x = x, y = y, fill = Reported), shape = 21) +
  scale_fill_manual("Reported", labels = c("FALSE", "TRUE", "NA"), values = c("red", "blue", "grey")) +
  xlab("") +
  ylab("") +
  facet_wrap(~ Indicator_type * Indicator, nrow = 2)

ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail, aes(x = x, y = y, fill = as.factor(mortsummary)), shape = 21) +
  scale_fill_viridis_d("Mortality indicators", labels = c("none", "one", "two", "three")) +
  xlab("") +
  ylab("")
ggsave(filename = "2024/image/mort.png", width = 16 / 2.54, height = 10 / 2.54, dpi = 300)

data_avail <- data_avail %>%
  select(emu_nameshort, x, y, bsummary, responded, mortsummary) %>%
  pivot_longer(cols = ends_with("summary"), names_to = "indicator", values_to = "nb")

ggplot(st_transform(country_p, crs = 3035)) +
  geom_sf(fill = NA) +
  theme_bw() +
  geom_point(data = data_avail, aes(x = x, y = y, fill = as.factor(nb)), shape = 21) +
  scale_fill_viridis_d("Number of indicators", labels = c("none", "one", "two", "three", "four")) +
  xlab("") +
  ylab("") +
  facet_wrap(~indicator)
```



## Map of mortality indicators


```{r mortalitymap,  fig.cap="Figure x Maps of mortality indicators per EMU (average after 2018). The size of the circle reflects the magnitude of ΣA while the colour illustrates the ratio between ΣF and ΣA. A cross indicates that ΣA or both ΣF and ΣA are missing. A grey circle indicates that ΣA was equal to 0 (e.g. Irish EMUs). Due to an error during the data call." }
# indicator <- dbGetQuery(con, "select eel_cou_code,eel_emu_nameshort, avg(b0) b0,avg (bbest) bbest,avg(bcurrent) bcurrent, avg(suma) suma,avg(sumf) sumf,avg(sumh) sumh from datawg.precodata_emu where eel_year>=2018 group by eel_cou_code,eel_emu_nameshort") %>%
#   mutate(eel_emu_nameshort = ifelse(eel_cou_code == "NL", "NL_Neth", eel_emu_nameshort))
# indicator <- merge(emu_c, indicator, by.x = "emu_nameshort", by.y = "eel_emu_nameshort", all.x = TRUE)
# indicator <- st_transform(indicator, crs = 3035)
# indicator$x <- st_coordinates(indicator)[, 1]
# indicator$y <- st_coordinates(indicator)[, 2]
# indicator$btarget <- .4 * indicator$b0
# indicator$bscaled <- indicator$bcurrent / indicator$b0
# indicator$x[indicator$eel_cou_code == "NO"] <- 4172612.3
# indicator$y[indicator$eel_cou_code == "NO"] <- 4111023.3
# # indicator$bcurrent <- log(indicator$bcurrent)/log(max(indicator$b0,na.rm=TRUE))*100000
# # indicator$bbest <- log(indicator$bbest)/log(max(indicator$b0,na.rm=TRUE))*100000
# # indicator$b0 <- log(indicator$b0)/log(max(indicator$b0,na.rm=TRUE))*100000
# # indicator$suma <- indicator$suma /.92*40000
# # indicator$sumf <- indicator$sumf /.92*40000
# # indicator$sumh <- indicator$sumh /.92*40000
 prettyscale <- c(0, .92)
 prettyscale_scaled <- scales::rescale(prettyscale, to = c(40000, 200000), from = c(0, max(indicator$suma, na.rm = TRUE)))


indicator$sumfsuma <- indicator$sumf / indicator$suma
indicator$suma <- scales::rescale(indicator$suma, to = c(40000, 200000), from = c(0, max(indicator$suma, na.rm = TRUE)))

scalesm <- data.frame(m = prettyscale, mscale = prettyscale_scaled, y0 = c(4200000, 4400000))

legend <- data.frame(indicator = c("sumA", "sumF"))

ggplot(st_transform(country_p, 3035)) +
  geom_sf(fill = NA, size = .1) +
  theme_bw() +
  geom_arc_bar(data = indicator, aes(
    x0 = x, y0 = y, r0 = 0, r = suma, start = 0,
    end = 2 * pi, fill = sumfsuma
  ), size = .2, col = NA) +
  # geom_arc_bar(data=indicator,aes(x0 = x, y0 = y, r0 = 0, r = sumf, start = 0,
  #                  end = 2*pi ),size=.2,fill=NA,col="yellow")+
  xlab("") +
  ylab("") +
  geom_point(
    data = indicator %>%
      filter(is.na(suma) & is.na(sumf)),
    aes(x = x, y = y), pch = "x"
  ) +
  # geom_arc_bar(data=scalesb,aes(x0 = 3008000, y0 =3800000, r0 = 0, r = 40000, start =0,
  # end = pi),linewidth=.2, fill = NA,col="black")+
  geom_arc_bar(data = scalesm, aes(
    x0 = 3008000, y0 = y0, r0 = 0, r = mscale, start = 0,
    end = pi
  ), fill = NA, col = "black") +
  geom_text(
    data = scalesm, aes(x = 3000000, y = y0 + mscale, label = paste0(m, "~lifetime^{-1}")),
    size = 1, hjust = "right", parse = TRUE
  ) +
  #    geom_rect(data=legend,aes(col=indicator,xmin=0,ymin=0,xmax=0,ymax=0),fill=NA)+

  # scale_color_manual("",values=c("sumF" = "yellow",
  #                      "sumA" = "blue"))
  scale_fill_viridis_c(expression(paste(Sigma, "F") / paste(Sigma, "A")))


ggsave(filename = "2024/image/maps_mortality.png", width = 16 / 2.54, height = 10 / 2.54)
```


# Habitat coverage
We asked aggregated data at the EMU scale, but asked for habitat coverage within indicator. Here, we look at how well the EMU biomass and mortality indicator estimates cover each habitat type within an EMU. For all biomass indicators taken together, and for all mortality indicators taken together, we calculate the percentage of EMUs whose indicator estimate covers either 0% or 100% of a given habitat type. This relies on data providers correctly filling in that habitat coverage for a given indicator is NP/-1 when that habitat is not present in the EMU, and only fill in a cover of 0% when the habitat is present in the EMU, but not assessed.

```{r habitatcoverage}
#| tab.id: bookmark_id
#| tab.cap: "Table showing frequency of when an habitat coverage is reported as 0 or 100 % for the different habitats (F Freshwater, C Coastal, T transitional, MO Marine Open)"
biomass <- dbGetQuery(con, "select * from datawg.t_eelstock_eel e  left join datawg.t_eelstock_eel_percent on eel_id=percent_id where eel_qal_id=1 and eel_typ_id in (13,14,15,34)")

mortality <- dbGetQuery(con, "select * from datawg.t_eelstock_eel e left join datawg.t_eelstock_eel_percent on eel_id=percent_id where eel_qal_id=1 and eel_typ_id in (17,18,19)")



biomass_long <- biomass %>%
  filter(!is.na(eel_value)) %>%
  select(eel_year, eel_typ_id, eel_cou_code, eel_emu_nameshort, perc_mo, perc_f, perc_c, perc_t) %>%
  pivot_longer(
    cols = c(perc_mo, perc_f, perc_t, perc_c),
    names_to = "habitat", values_to = "perc"
  ) %>%
  mutate(habitat = toupper(gsub("perc_", "", habitat))) %>%
  mutate(
    type = "biomass",
    eel_typ_id = case_when(eel_typ_id == 13 ~ "B0", eel_typ_id == 14 ~ "Bbest", eel_typ_id == 15 ~ "Bcurrent", eel_typ_id == 34 ~ "Bcurrentwithoutrestocking")
  )

overview_biom_type_perc <- table(biomass_long$eel_typ_id, biomass_long$perc)
#unique(biomass_long$eel_emu_nameshort)
# filter(biomass_long, str_sub(biomass_long$eel_emu_nameshort, 4, 8)=="total")
# filter(biomass_long, biomass_long$eel_cou_code=="LV")


mortality_long <- mortality %>%
  filter(!is.na(eel_value)) %>%
  select(eel_year, eel_typ_id, eel_emu_nameshort, perc_mo, perc_f, perc_c, perc_t) %>%
  pivot_longer(
    cols = c(perc_mo, perc_f, perc_t, perc_c),
    names_to = "habitat", values_to = "perc"
  ) %>%
  mutate(habitat = toupper(gsub("perc_", "", habitat))) %>%
  mutate(
    type = "mortality",
    eel_typ_id = case_when(
      eel_typ_id == 17 ~ "sumA",
      eel_typ_id == 18 ~ "sumF",
      eel_typ_id == 19 ~ "sumH"
    )
  )
overview_mortality_long_perc <- table(mortality_long$eel_typ_id, mortality_long$perc)
indicator <- biomass_long %>%
  bind_rows(mortality_long) %>%
  filter(perc >= 0)

#mortality_long %>% filter(perc>0 & perc <100)

flextable(indicator %>%
  group_by(type, habitat) %>%
  summarize(
    freq100 = round(sum(perc == 100) / n() * 100),
    freq0 = round(sum(perc == 0) / n() * 100)
  ) %>%
  pivot_wider(names_from = habitat, values_from = c(freq0, freq100))) 
```
Marine open and coastal waters are rarely accounted for in indicator estimates. Some fresh and transitional waters not accounted for.

* [NOTE] LV is only reporting 40 % of habitats in Freshwater. Since annex 13 EMP was not reported it's difficult to assess why ... see questions ...





# Data quality check



## $B_0$ less than $B_{best}$
A first check consisted of comparing $B_{best}$ and $B_0$ (Table 3 2): both indicators refer to the escapement that would occur in the absence of any anthropogenic pressures, but $B_{best}$ correspond to the escape-ment with the current recruitment while $B_0$ correspond to the escapement produced with a pristine recruitment. Given the decrease in recruitment since the early 1980s, $B_{best}$ should be less than $B_0$. However, this was not consistently the case in the reported data. 
In a few situations, $B_{best}$ is greather than $B_0$ (FIg. x): DE_Warn, EE_Narv, EE_total, ES_Minh, GB_Neag, GB_Scot, GR_CeAe, GR_WePe, PL_Oder, SE_Inla (table x). . For SE_Inla, $B_{best}$ estimates are greater than $B_0$ during the late 80s / early 90s, suggesting that $B_0$ might be based on historical data from the 1980s (an option suggested in the Regulation) rather than to a truly pristine situation. In other EMUs, (DE_Warn, EE_Narv, GB_Neag, GB_Scot), some report-ed Bbest from the 2000s or the 2010s were greater than reported $B_0$. Despite possible variations (due to recruitment variability) of Bbest ($B_0$ is an average value which would be expected to be stable), re-cruitment was probably too low in the 2000s to generate escapements greater than the pristine es-capement. In EE_Narv, we can suspect that restocking was inappropriately integrated into Bbest lead-ing to an overestimation of this indicator. In the other EMUs, an underestimation of $B_0$ is probably the reason.

Normally, Bbest (that does not include restocking) stands for the best escapment that can occur in the absence of anthropogenic influence give the current recruitment. Since recruitment has collapsed, Bbest is supposed to be smaller than $B_0$ which is the escapment that would occur in the absence of any anthropogenic influence, including a pristine recruitment, and is generally estimated using pre-1980s data.

```{r plotBbestb0, fig.cap="Figure XX  Histogram showing the frequency distribution of the $B_{best}/B_0$ ratio. Values higher than 1 indicate that $B_{best}$ is higher than $B_0$"}

# A histogram showing frequency distribution of the bbest/b0 ratio
ggplot(indicator, aes(x = bbest / b0)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[best] / B[0])) +
  scale_x_log10() +
  ylab("frequency") 
```


```{r tabbestb0}
#| tab.id: bookmark_id
#| tab.cap: "Table XX Occurrence of Bbest values larger than B0. Either detail of years, or range and number of values if too long..."
flextable(indicator %>%
  filter(bbest > b0) %>%
  select(eel_emu_nameshort, eel_year, bbest, b0) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s,Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())
    ),
    mean_bbest_b0 = round(mean(bbest / b0),2)
  ) %>% arrange(desc(mean_bbest_b0))) %>%
   set_table_properties(width = 0.8, layout = "autofit")
check_these_emusbbestb0 <- indicator %>%  filter(bbest > b0) %>%  select(eel_emu_nameshort) %>% unique()%>%pull()
```

For some EMUs like SE_Inla, this is likely related to using a B_{0} that is coming from the late 80s situation. For EE, it seems rather due to the inclusion of restocking in $B_{best}$ (i.e. overestimation of $B_{best}$). For others, $B_0$ is likely underestimated.



## $B_{best}$ less than $B_{current}$

A second check consisted of comparing $B_{best}$ and $B_{current}$ (Table xx): in the absence of significant re-stocking, $B_{current}$ should be less than $B_{best}$. The analysis of the ratio Bcurrent/$B_{best}$ clearly shows the large effect of restocking in Germany, in Poland (PL_Oder) and in Sweden (SE_Inla). The very large value for DE_Rhei also illustrates a specific issue raised by transboundary EMU: DE_Rhein has no direct access to the sea so that young eels have to migrate through NL_Neth to reach DE_Rhein while sil-ver eels also have to migrate through NL, but to reach the sea. $B_{best}$ is almost impossible to estimate in such EMU: it would require estimating the number of eels that would migrate to DE_Rhei given the current recruitment in the absence of any anthropogenic barriers in NL_Neth. The large Bcurrent/ $B_{best}$ values indicate that $B_{best}$ is likely underestimated and that currently, the “natural recruitment” is almost insignificant compared to restocking in those EMUs.
In some Irish EMUs, $B_{best}$ is nearly equal to $B_{current}$ for a few years, but this is consistent with the very small anthropogenic mortality estimated in recent years for those EMUsIn countries without (or with limited) restocking, $B_{current}$ should be less than $B_{best}$

```{r plotbcurrentBbest,  fig.cap="Figure XX  Histogram showing the frequency distribution of the $B_{current}/B_best$ ratio. Values higher than 1 indicate that $B_{current}$ is higher than $B_best$ which can happen in the case of restocking."}
ggplot(indicator, aes(x = bcurrent / bbest)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current] / B[best])) +
  scale_x_log10() +
  ylab("frequency")
```

```{r tabbcurrentbbest}
#| tab.id: bookmark_id
#| tab.cap: "Table showing ratio of Bcurrent over Bbest for those EMUs and years where Bcurrent larger than Bbest. EMU from SE, NL, PL, DE excluded as obviously, in this case this is caused by restocking."
indicator %>%
  filter(bbest < bcurrent) %>%
  select(eel_emu_nameshort, eel_year, bcurrent, bbest) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s,Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())
    ),
    ratio = round(mean(bcurrent / bbest),2)
  ) %>%
  arrange(desc(ratio))%>%
  flextable()%>%
   set_table_properties(width = 0.8, layout = "autofit")

check_these_emusbcurrentbbest <- indicator %>%  filter(bbest < bcurrent & !eel_cou_code %in% c('SE', 'PL', 'DE')) %>%  select(eel_emu_nameshort) %>%  unique()%>%pull()
```
For German EMUs, this shows the massive effect of restocking which is also visible in Sweden or in Poland. For Ireland, the anthropogenic mortality is so low in recent years that $B_{current}$ and $B_{best}$ can be very similar. Results are more doubtful in ES_Anda.


## Only $B_{current}$ without restocking reported
Before looking at EMUs where $B_{current}$ without restocking exceeds either $B_{best}$ or B0, it is worthwhile to look at countries that have only reported $B_{current}$ without restocking, and no $B_{current}$ which may or may not include restocking.
It is mostly French EMUs that have reported an estimate of $B_{current}$ without restocking (TABLE x), while not having reported on regular Bcurrent. Is there a hidden additional production of restocked silver eel in French EMUs?
```{r tabonly$B_{current}$_without_restocking}
#| tab.id: bookmark_id
#| tab.cap: "Table showing ratio of Bcurrent_without_restocking over Bbest for those EMUs and years where Bcurrent without restocking larger than Bbest (this theoretically should not happen)."
flextable(indicator %>%
  filter(
    !is.na(bcurrent_without_stocking),
    is.na(bcurrent)
  ) %>%
  select(eel_emu_nameshort, eel_year, bcurrent_without_stocking, bbest) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s,Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())
    ),
    mean_bcurrent_norestock_bbest = 
      round(mean(bcurrent_without_stocking / bbest, na.rm = T),2)
  ) %>%
  arrange(desc(mean_bcurrent_norestock_bbest)))%>%
   set_table_properties(width = 0.8, layout = "autofit")
```
It is mostly French EMUs that have reported an estimate of $B_{current}$ without restocking, while not having reported on regular $B_{current}$. Is there a hidden additional production of restocked silver eel in French EMUs?
The problem is that the latest report is only based on regions where restocking didn't occur (so as not to biase EDA outputs....) so it was not provided. 

## $B_{current}$ without restocking higher than $B_{best}$ 
This year, for the first time, countries were asked to also report $B_{current}$ values without the effect of restocking, if available. Run the above analysis again with $B_{current}$ without restocking, for those countries that have reported this.

$B_{current}$ is defined as the highest observed level under current optimal  conditions; therefore, $B_{current}$ serves as a biological limit that the current biomass is unlikely to exceed without human intervention. Almost all estimates of $B_{current}$ without the effect of restocking show, as expected, that that Bcurrent estimate is lower than $B_{current}$. There are only three EMU exceptions to this (fig; X; TableX): 

- ES_Nava, which shows strong fluctuations in the ratio between $B_{current}$ and bcurrent (both with or without restocking). This warrants further investigation to see how these estimates were derived.

- ES_Vale, Less extreme fluctuations than ES_Nava, the years that bcurrent without stocking is higher than $B_{current}$ are also years in which Bcurrent without stocking is equal to Bcurrent. Same as ES_Nava, closer look is needed to how these estimates are derived. 

- IE_SouW, which seems to be a rounding error, and Bcurrent is equal to $B_{current}$.

```{r plotbcurrentBbest_without_restocking, }
ggplot(indicator, aes(x = bcurrent_without_stocking / bbest)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current_norestock] / B[best])) +
  scale_x_log10() +
  ylab("frequency")
```

```{r tabbcurrentbbest_without_restocking}
# Table showing years where bcurrent without restocking is higher than bbest.
flextable(indicator %>%
  filter(bbest < bcurrent_without_stocking) %>%
  select(eel_emu_nameshort, eel_year, bcurrent_without_stocking, bbest) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s,Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())
    ),
    mean_bcurrent_norestock_bbest = round(mean(bcurrent_without_stocking / bbest),2)
  ) %>%
  arrange(desc(mean_bcurrent_norestock_bbest)))%>%
   set_table_properties(width = 0.8, layout = "autofit")

check_these_emusbcurrentbbest_without_restocking <- indicator %>%  filter(bbest < bcurrent_without_stocking) %>%  select(eel_emu_nameshort) %>%  unique()%>%pull()
```
Almost all estimates of $B_{current}$ without the effect of restocking show, as expected, that that $B_{current}$ estimate is lower than $B_{best}$. There are only three EMU exceptions to this: 

- ES_Nava, which shows strong fluctuations in the ratio between $B_{best}$ and $B_{current}$ (both with or without restocking). This warrants further investigation to see how these estimates were derived.

- ES_Vale, Less extreme fluctuations than ES_Nava, the years that $B_{current}$ without stocking is higher than $B_{best}$ are also years in which $B_{current}$ without stocking is equal to $B_{current}$. Same as ES_Nava, closer look is needed to how these estimates are derived. 

- IE_SouW, which seems to be a rounding error, and $B_{current}$ is equal to $B_{best}$.

Not all countries have reported a $B_{current}$ without restocking. To complete the analysis, we present the years where $B_{current}$ exceeds $B_{current}$ for countries that have not provided an indicator for $B_{current}$ without restocking. If these countries have substantial restocking programs, it is recommended they work toward estimating $B_{current}$ without restocking, if feasible. If restocking is not occurring, further examination of the methods used to estimate $B_{current}$ and $B_{current}$ is warranted.

It is likely that Germany and Poland are affected by restocking. Therefore, it would be beneficial for these countries to explore the possibility of estimating $B_{current}$ without restocking, if feasible.

For GR_CeAe, the indicators show inconsistencies. In some cases, $B_{current}$ is greater than or equal to $B_{current}$, even when sumA is also high. In other cases, both $B_{current}$ and $B_{current}$ are zero, while sumA is also zero. After confirming with the data provider, it was clarified that years with zero biomass indicator estimates should be classified as NC, as they correspond to years with no landings (resulting in a sumA of zero). The reason why $B_{current}$ and $B_{current}$ were higher than b0 for certain years remains unclear. It is advised to exclude this series from the WKEMP analysis until the methods for deriving these estimates are thoroughly reviewed.

 
```{r tabbcurrentbbest_norestockestimate}
caption <-  "table x Situations in which $B_{current}$ without restocking was reported as lower than $B_{best}$. The years in which this occurs are listed in column 2 and the average value of $B_{current}$ without restocking / $B_{best}$ in those years is presented in column 3"
flextable(indicator %>%
  filter(
    bbest < bcurrent,
    is.na(bcurrent_without_stocking)
  ) %>%
  select(eel_emu_nameshort, eel_year, bcurrent, bbest) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = paste0(sort(eel_year), collapse = "/"),
    mean_bcurrent_bbest = round(mean(bcurrent / bbest),2)
  ) %>%
  arrange(desc(mean_bcurrent_bbest)))%>%
  set_caption(caption=caption)%>%
   set_table_properties(width = 0.8, layout = "autofit")

```
Likely that Germany and Poland are effected by restocking, so for these countries it would be good if the possibility exists to work toward an estimate of $B_{current}$ without restocking. 

For GR_CeAe, indicators are strange. Sometimes $B_{current}$ is larger or equal to $B_{best}$, but at the same time $\sum{A}$ is also high. Sometimes, $B_{best}$ and $B_{current}$ are 0, but $\sum{A}$ is also 0. I double-checked with the data provider, and all years with 0 values for biomass indicator estimates should be NC instead, since these are years with no landings (so $\sum{A}$ is 0). It remained unclear why $B_{best}$ and $B_{current}$ were higher than b0 for years with an estimate. Advise to remove this series from WKEMP analysis until the methods for deriving these estimates are better looked at.


## $B_0$ less than $B_{current}$
In countries without (or with limited) restocking, $B_{current}$ should be less than $B_0$


```{r plotbcurrentb0, fig.cap=" Fig. x.  Histogram showing frequency distribution of the $B_{current}$/$B_0$. Values higher than 1 indicate that $B_{current}$ is higher than $B_0$ "}

ggplot(indicator, aes(x = bcurrent / b0)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current] / B[0])) +
  scale_x_log10() +
  ylab("frequency")
```

```{r tabbcurrentb0}
#| tab.id: bookmark_id
#| tab.cap: " table x Situations in which $B_{current}$ without restocking was reported as greater than $B_{best}$. The years in which this occurs are listed in column 2 and the average value of $B_{current}$ without restocking / $B_{best}$ in those years is presented in column 3 "
flextable(indicator %>%
  filter(b0 < bcurrent) %>%
  select(eel_emu_nameshort, eel_year, bcurrent, b0) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s,Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())
    ),
    mean_bcurrent_b0 = round(mean(bcurrent / b0),2)
  ) %>%
  arrange(desc(mean_bcurrent_b0)))
check_these_emusb0lessthanbcurrent <- 
  indicator %>%
  filter(b0 < bcurrent & !eel_cou_code %in% c('SE', 'PL', 'DE')) %>%
  select(eel_emu_nameshort) %>%
  unique()%>%
  pull()

```
## $B_{current}$ without restocking higher than $B_0$ 

This year, for the first time, countries were asked to also report $B_{current}$ values without the effect of restocking, if available. Run the above analysis again with $B_{current}$ without restocking, for those countries that have reported this.
There is only one case in wich with  $B_{current}$ without restocking was reported as greater than $B_0$ (Fig. x, Table  X)As already mentioned above, without any restocking effects, $B_{current}$ for GB_Scot is still estimated as higher than b0. This likely indicates an underestimate of $B_0$.

```{r plotbcurrentnorestockb0, fig.cap=" Figure XX  Histogram showing frequency distribution of the $B_{current}/B_0$. Values higher than 1 indicate that $B_{current}$ is higher than $B_0$ "}
  
ggplot(indicator, aes(x = bcurrent_without_stocking / b0)) +
geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current_norestock] / B[0])) +
  scale_x_log10() +
  ylab("frequency")
```

```{r tabbcurrentnorestockb0}
#| tab.id: bookmark_id
#| tab.cap: "Table XX Situations in which $B_{current}$ without restocking was reported as greater than $B_0$ . The years in which this occurs are listed in column 2 and the average value of $B_{current}$ without restocking / $B_0$ in those years is presented in column 3 "
flextable(indicator %>%
  filter(b0 < bcurrent_without_stocking) %>%
  select(eel_emu_nameshort, eel_year, bcurrent_without_stocking, b0) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = paste0(sort(eel_year), collapse = "/"),
    mean_bcurrentnorestock_b0 = mean(bcurrent_without_stocking / b0)
  ) %>%
    arrange(desc(mean_bcurrentnorestock_b0)))%>%   
  set_table_properties(width = 0.8, layout = "autofit")

check_these_emusb0lessthanbcurrentwithout <- 
  indicator %>%
  filter(b0 < bcurrent & !eel_cou_code %in% c('SE', 'PL', 'DE')) %>%
  select(eel_emu_nameshort) %>%
  unique()%>%
  pull()
```

## Check irregularities in combinations of $B_{current}$, $B_{best}$, and $\sum{A}$
In this section, we investigate these unusual combinations: cases where $B_{current}$ exceeds $B_{best}$ while $\sum{A}$ is high, as well as instances where both $B_{current}$ and $B_{best}$ are low, corresponding to a low $\sum{A}$.

Here, we check for such unusual combinations of high $B_{current}$ vs $B_{best}$ while also having a high $\sum{A}$, or the reverse of a low $B_{current}$ or $B_{best}$ while also having a low $\sum{A}$

For EMUs which have no estimate for $B_{current}$ without restocking, only EMUs from Germany, Greece, and Poland had a $B_{current}$ that differed more than 10% from the expected $B_{current}$ (Fig.x , table y). For Germany and Poland, this is likely the result of restocking. For Greece, could it also be restocking?

For EMUs that did have an estimate for $B_{current}$ without restocking, only the ES_Vale EMU had $B_{current}$ estimates that differed more than 10% to the expected $B_{current}$ (Table y). This needs further investigation.

```{r plothighindicators, fig.cap=" Fig. x.  Histogram showing frequency distribution of the $B_{current}$/$B_{current}$ expected. Values higher than 1 indicate that $B_{current}$ is higher than $B_{current_expected "}
# First, compare $B_{current}$ to estimated $B_{current}$ for all series with no estimate for bcurrent without restock. Keep in mind, that this may still be effected by restocking.
indicator %>%
  filter(is.na(bcurrent_without_stocking)) %>%
  mutate(
    bcurrent_expected = bbest * exp(-suma),
    b_bexpect = bcurrent / bcurrent_expected
  ) %>%
  ggplot(., aes(x = b_bexpect)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current] / B[current_expected])) +
  scale_x_log10() +
  ylab("frequency")
```
```{r plothighindicators2, fig.cap = "Comparison of $B_{current Without Restocking}$ and $B_{currentExpected}$ calculated as $B_{best}*exp[-\\sumA]}$"}
# Then, look at $B_{current}$ without restocking vs expected bcurrent
indicator %>%
  mutate(
    bcurrent_expected = bbest * exp(-suma),
    b_bexpect = bcurrent_without_stocking / bcurrent_expected
  ) %>%
  ggplot(., aes(x = b_bexpect)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current_norestock] / B[current_expected])) +
  scale_x_log10() +
  ylab("frequency")
```

```{r tablebcurrentbcurrentestimated}
#| tab.id: bookmark_id
#| tab.cap: Compare $B_{current}$ to estimated $B_{current}$ for all series with no estimate for $B_{current without restock}$.

flextable(indicator %>%
  filter(is.na(bcurrent_without_stocking)) %>%
  mutate(
    bcurrent_expected = bbest * exp(-suma),
    b_bexpect = bcurrent / bcurrent_expected
  ) %>%
  filter(abs(b_bexpect) > 1.1) %>%
  select(eel_emu_nameshort, eel_year, b_bexpect) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
             years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s,Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())),
    mean_b_bexpect = mean(b_bexpect)
  ) %>%
  arrange(eel_emu_nameshort))
```
```{r tablebcurrentbcurrentwestimated}
#| tab.id: bookmark_id
#| tab.cap: Compare $B_{current without restocking}$ to estimated $B_{current}$ for all series with no estimate for bcurrent without restock. 
flextable(indicator %>%
  mutate(
    bcurrent_expected = bbest * exp(-suma),
    b_bexpect = bcurrent_without_stocking / bcurrent_expected
  ) %>%
  filter(abs(b_bexpect) > 1.1) %>%
  select(eel_emu_nameshort, eel_year, b_bexpect) %>%
  group_by(eel_emu_nameshort) %>%
  summarize(
    years = paste0(sort(eel_year), collapse = "/"),
    mean_b_bexpect = mean(b_bexpect)
  ) %>%
  arrange(eel_emu_nameshort))
```

For EMUs which have no estimate for $B_{current}$ without restocking, only EMUs from Germany, Greece, and Poland had a $B_{current}$ that differed more than 10% from the expected $B_{current}$. For Germany and Poland, this is likely the result of restocking. For Greece, could it also be restocking?

For EMUs that did have an estimate for $B_{current}$ without restocking, only the ES_Vale EMU had $B_{current}$ estimates that differed more than 10% to the expected $B_{current}$. This needs further investigation.

## checking difference between $B_{current}$ without restocking and $B_{current}$


```{r checkingdiffbcurrent, fig.cap=" Fig. XX  Histogram showing frequency distribution of the $B_{current}$/$B_{current}$ without stocking. Values lower than 1 indicate a problem."}
ggplot(indicator, aes(x = bcurrent / bcurrent_without_stocking)) +
  geom_histogram() +
  geom_vline(xintercept = 1, slope = 1, lty = 2) +
  xlab(expression(B[current] / B[currentw])) +
  scale_x_log10() +
  ylab("frequency") 
```

```{r checkingdiffbcurrenttable"}
#| tab.id: bookmark_id
#| tab.cap: "Table XX Situations in which $B_{current}$ without restocking was reported as greater than $B_current$ . The years in which this occurs are listed in column 2 and the average value of $B_{current}$ without restocking / $B_current$ in those years is presented in column 3 "
indicator %>% 
  filter(bcurrent_without_stocking>bcurrent) %>%
  mutate(ratio = bcurrent_without_stocking/bcurrent,
         years = ifelse(n()<5,
    paste0(eel_year, collapse="|"),
    sprintf("range:%s-%s,Number occurences %s",
            min(eel_year),
            max(eel_year),
            n())
    ),) %>%
  select(eel_emu_nameshort, years, ratio) %>%
 arrange(desc(ratio))%>%   
  flextable()%>%   
  set_table_properties(width = 0.8, layout = "autofit")

  
check_these_emusbcurrentlessthancurrentwithout <- 
  indicator %>%
  filter(bcurrent_without_stocking>bcurrent) %>% 
  select(eel_emu_nameshort) %>%
  unique()%>%
  pull()
```


## Checking $B_0$

NOTE THE CODE BELOW HAS ALSO BEEN REPORTED BY HILARIE IN THE OTHER ANNEX AND IS 
PROBABLY MORE UP TO DATE. WE NEED TO MERGE BOTH IN THE REPORT AT THE END.
 
```{r estimatingb0}
#| eval: TRUE
load(file.path(getwd(),"/data_dependencies/annexes13_method.Rdata"))
mor_wise <- annexes13_method %>% select(emu_nameshort, mortality_wise)
emu_sea <- emu_p %>%
  filter(emu_cou_code %in% eu_cou_codes) %>%
  mutate(rec_zone = ifelse(emu_cou_code %in% c("NL", "DK", "NO", "BE", "LU", "CZ", "SK") |
    emu_nameshort %in% c(
      "FR_Rhin", "FR_Meus", "GB_Tham", "GB_Angl", "GB_Humb", "GB_Nort", "GB_Solw",
      "DE_Ems", "DE_Wese", "DE_Elbe", "DE_Rhei", "DE_Eide", "DE_Maas"
    ),
  "NS",
  ifelse(emu_cou_code %in% c("EE", "FI", "SE", "LV", "LT", "AX", "PL", "DE"),
    "BA",
    "EE"
  )
  ))

mor_wise <- merge(emu_sea %>% st_drop_geometry(), mor_wise)
mor_wise <- mor_wise %>%
  mutate(cohort_wise = grepl("ohort", mortality_wise)) %>%
  mutate(emu_nameshort = ifelse(emu_nameshort == "NL_Neth", "NL_total", emu_nameshort))
load("../../R/shiny_data_visualisation/shiny_dv/data/recruitment/dat_ge.Rdata")
load("../../R/shiny_data_visualisation/shiny_dv/data/recruitment/dat_ye.Rdata")



estimate_b0 <- function(emu, year, mor_wise, precodata) {
  mod <- switch(unique(mor_wise$rec_zone[mor_wise$emu_nameshort == emu]),
    "EE" = dat_ge %>% filter(area == "Elsewhere Europe"),
    "NS" = dat_ge %>% filter(area == "North Sea"),
    "BA" = dat_ye
  )
  if ("value_std_1960_1979" %in% names(mod)) {
    Rcurrent <- mean(mod$value_std_1960_1979[mod$year %in% ((year - 4):year)])
  } else {
    Rcurrent <- mean(mod$p_std_1960_1979[mod$year %in% ((year - 4):year)])
  }
  if (unique(mor_wise$cohort_wise[mor_wise$emu_nameshort == emu])) {
    Rcurrent <- switch(mor_wise$rec_zone[mor_wise$emu_nameshort == emu],
      "EE" = mean(mod$p_std_1960_1979[mod$year %in% ((year - 12):(year - 7))]),
      "NS" = mean(mod$p_std_1960_1979[mod$year %in% ((year - 17):(year - 12))]),
      "BA" = mean(mod$value_std_1960_1979[mod$year %in% ((year - 22):(year - 17))])
    )
  }
  precodata$bbest[precodata$eel_emu_nameshort == emu & precodata$eel_year == year] / Rcurrent
}

indicator_sub <- indicator %>%
  filter(eel_emu_nameshort %in% unique(mor_wise$emu_nameshort))
indicator_sub$b0_estimated <- mapply(estimate_b0, indicator_sub$eel_emu_nameshort, indicator_sub$eel_year,
  MoreArgs = list(mor_wise = mor_wise, precodata = indicator_sub)
)
```
The EU regulation states that Member States should implement management measures in order to achieve an escapement equal to 40 % of the pristine recruitment. As such, the standard precautionary diagram show the lifespan anthropogenic mortality against the ratio of $B_{current}$ over $B_0$. However, the pristine situation is difficult to define and $B_0$ is even harder to estimate. As such, some countries have used observations of past productivity in some water bodies, multiplied by the total water surface to extrapolate pristine escapement. However, the availability of historical data does not allow to go back far in time, rarely before the 80s, which was not a pristine situation. Other countries have used the current escapement, corrected for anthropogenic mortality (i.e. $B_{best}$) and use this to extrapolate $B_{current}$. However, the extrapolation methods vary among countries, especially regarding the integration of mortality density dependence or not (accounting for mortality density dependent mortality leads to smaller $B_0$ since it postulates that natural mortality increases with abundance). As such, $B_0$ are hardly comparable among countries, and the status of EMUs with respect to the EU regulation target depends a lot on this estimation of $B_0$.
To avoid these inconsistencies, we propose here an alternative method. First, let remind that, by definition:
$${B}_{current} = {R}_{current} ⋅ {exp} ^ {\left (− Σ A − Σ M \right)}$$

and that if we do not account for any density dependence, we also have
$${B}_{best} = {R}_{current} ⋅ {exp} ^ {\left (− Σ M \right )}$$
$${B}_{0} = {R}_{0} ⋅ {exp} ^ {\left (− Σ M \right )}$$

As such, we can get an estimate of $B_0$ as:
$${B}_{0} \sim \frac{R_0}{R_{current}} \cdot {B}_{best}$$

Since recruitment was assumed to be closed to a pristine situation in the 1980s, we can directly use the WGEEL recruitment indices to get ${R}_{0} / {R}_{current}$ and to have a standard and consistent estimates of $B_0$ using $B_{best}$ reported by countries. Moreover, since these estimates are based on $B_{best}$, they are more comparable with $B_{current}$ ($B_{best}$ and $B_{current}$ are generally based on a same method), instead of having a ratio based on a value based on current observations mixed with value based on historical values or on extra-assumptions. Those new estimates would not account for mortality dependence, as such they would be seen as a upper bound for $B_0$.

Some preliminary steps are required. First, it is be required to choose the appropriate recruitment indices (elsewhere Europe, North Sea, yellow eel). Here we associated each EMU with a recruitment index according to Figure 3.1 from latest WGEEL report (ICES, 2021). Then, for countries using a cohort wise estimation of escapment, it is required to account for a lag between recruitment and escapement, corresponding to the lifespan. Since lifespan is not available, we used an ad-hoc rule: for EMUs with a year-wise process, we used the average value of the recruitment indices from latest 5 years as $R_current$. For EMUs associated with the Elsewhere index, we took the average value of the index from 7 to 12 years ago. We took 12 to 17 for North Sea and 17 to 22 for yellow eel indices.

```{r map_emu}
#| eval: TRUE
ggplot(emu_sea) +
  geom_sf(data = emu_p, inherit.aes = FALSE, fill = "grey") +
  geom_sf(aes(fill = rec_zone)) +
  scale_fill_discrete("recruitment index") +
  theme_bw()
# ggsave("2024/image/emu_rec.png",width=16/2.54,height=10/2.54,dpi=300)
```
```{r plotb0alternative}
#| eval: FALSE
ggplot(indicator_sub, aes(x = b0, y = b0_estimated)) +
  geom_point(aes(col = eel_cou_code)) +
  xlab(expression("reported B"[0])) +
  ylab(expression("adjusted B"[0])) +
  geom_abline(intercept = 0, slope = 1, lty = 2) +
  scale_color_discrete("country")
ggsave("2024/image/reest.png", width = 16 / 2.54, height = 10 / 2.54, dpi = 300)

ggplot(indicator_sub, aes(x = b0 / b0_estimated)) +
  geom_histogram() +
  facet_wrap(~eel_cou_code) +
  scale_x_log10() +
  geom_vline(xintercept = 1, lty = 2) +
  xlab(expression("reported B"[0] / "adjusted B"[0])) +
  ylab("frequency")
ggsave("2024/image/reest.png", width = 16 / 2.54, height = 10 / 2.54, dpi = 300)
```
Results show that the discrepancy between the two indicators is very heterogeneous among countries / EMUs. Unsurprisingly, the reported $B[0]$ are generally less than the estimated ones, but this is not always the case (e.g. SE, ES). More surprisingly, estimated $B[0]$ are highly variable, indicating that reported $B[best]$ are much more variable than variations in recruitment. Finally, the ratio between reported and estimated $B[0]$ are very contrasted among countries, either because of inappropriate accounting of restocking in $B[best]$ or because of inconsistencies in $B[0]$ estimations. Anyway, this questions the comparisons of $B[0]$ among EMUs.


As such, it is worthwhile checking whether is has consequences on the ratio $B_{current}/B_0$. The plot clearly shows the effect of the estimation of $B_0$ on estimated ratio. For some countries, effects are limited (e.g. SE, LT). But for most countries, estimated $B_0$ lead to much more lower estimated ratio (e.g. IE, GB, PT).


```{r comparisonsratio}
#| eval: TRUE
indicator_sub <- indicator_sub %>%
  mutate(
    old = bcurrent / b0,
    updated = bcurrent / b0_estimated
  )
ggplot(indicator_sub %>% filter(eel_year >= 2018), aes(x = old, y = updated)) +
  geom_point(aes(
    col = eel_cou_code,
    pch = as.factor(eel_year)
  )) +
  geom_abline(slope = 1, intercept = 0, lty = 2) +
  facet_wrap(~eel_cou_code) +
  guides(colour = FALSE) +
  scale_shape("year") +
  xlab("reported ratio") +
  ylab("estimated ratio")
ggsave("2024/image/ratiob0.png", width = 16 / 2.54, height = 10 / 2.54, dpi = 300)
```

## Effect of restocking
Theoretically, $B_{best}$ should not include restocking while $B_0$ should include restocking. In the absence of restocking $\Sigma A \sim -log(B_{best}/B_{current})$, but this equation should not be valid in the presence of restocking since $B_{best}$ and $\Sigma A$ should not include restocking while $B_current$ should include restocking.

Here, we see that many countries (except DE, SE and PL) seem to have accounted for restocking both in $B_{best}$ and $B_{current}$, with a possible double banking of restocking (i.e. both increasing escapement and decreasing mortality).

```{r plotsumA}
#| eval: TRUE
ggplot(indicator, aes(x = suma, y = (-log(bcurrent / bbest)))) +
  geom_point(aes(col = eel_cou_code), show.legend = FALSE) +
  facet_wrap(~eel_cou_code, scales = "free") +
  geom_abline(intercept = 0, slope = 1, lty = 2) +
  xlab(expression(paste(Sigma, "A"))) +
  scale_color_discrete("") +
  ylab(expression(-log(B[current] / B[best])))
ggsave("2024/image/sumAlog.png", width = 16 / 2.54, height = 12 / 2.54, dpi = 300)
```

# Questions for countries

* LV please provide annex 13 and explain why only 40 % of the habitat is covered for biomass
* LV why is the percentage of habitat covered different between mortality and biomass estimates (40 and 50 % respectively) (2021 -2023)
* IT ask for biomass and mortality indicators
* France : please provide a calculation of $B_{current}$ with restocking. 

```{r questions, results='asis'}
for (i in 1:length(check_these_emusbbestb0)) cat(sprintf("- %s $B_{best}$ reported is larger than $B_0$, this is unexpected. Please note that the calculation of $B_{best}$ should not include restocking. \n", check_these_emusbbestb0[i]))
for (i in 1:length(check_these_emusbcurrentbbest)) cat(sprintf("- %s $B_{current}$ reported is larger than $B_{best}$, this is unexpected in the absence of restocking. Please note that the calculation of $B_{best}$ should not include restocking. \n", check_these_emusbcurrentbbest[i]))
for (i in 1:length(check_these_emusbcurrentbbest_without_restocking)) cat(sprintf("- %s $B_{current without restocking}$ reported is larger than $B_{best}$, this is unexpected in the absence of restocking. Please note that the calculation of $B_{best}$ should not include restocking \n", check_these_emusbcurrentbbest_without_restocking[i]))
for (i in 1:length(check_these_emusb0lessthanbcurrent)) cat(sprintf("- %s $B_{current}$ reported is larger than $B_{0}$. In the absence of a massive restocking this is unexpected \n", check_these_emusb0lessthanbcurrent[i]))
for (i in 1:length(check_these_emusb0lessthanbcurrentwithout)) cat(sprintf("- %s $B_{currentwithoutrestocking}$ reported is larger than $B_{0}$ \n.", check_these_emusb0lessthanbcurrentwithout[i]))
for (i in 1:length(check_these_emusbcurrentlessthancurrentwithout)) cat(sprintf("- %s $B_{currentwithoutrestocking}$ reported is larger than $B_{current}$. This must be an error \n", check_these_emusbcurrentlessthancurrentwithout[i]))

```
