---
title: "Report on developments on the state of the European eel (Anguilla anguilla) stock, the fisheries on it and other anthropogenic impacts"
author: "WGEEL"
date: "2022-09-13"
documentclass: article
output: 
  bookdown::word_document2:
    fig_caption: yes
    number_sections: no
    reference_docx: "../Rmarkdown/ICES_template.docx"
---

```{r setup, include=FALSE, warning = FALSE, message = FALSE, error=FALSE}
library(knitr)
opts_knit$set(eval.after = "fig.cap",
		echo=FALSE,
		warning = FALSE,
		message = FALSE,
		error=FALSE)
Sys.setlocale("LC_ALL", "English_United States.932")
#options(save.defaults = list(version=2))
# Password are stored in R/etc/Rprofile.site
# For the moment the database is stored locally
CY <- 2024 # current year ==> dont forget to update the graphics path below
opt_calculation <- "geomean" # "geomean" or "mean"
opt_std <- "all" #"1979-1994" or "2000-2009" or "all"

options(width=90) # this sets the width of the output
#--------------------------------
# packages used by this script
#--------------------------------
#if(!require(RODBC)) install.packages("RODBC") ; require(RODBC)
library(flextable)
if(!require(officedown)) install.packages("officedown") ; require(officedown)
if(!require(officer)) install.packages("officer") ; require(officer)
if(!require(prettymapr)) install.packages("prettymapr") ; require(prettymapr)

if(!require(mgcv)) install.packages("mgcv") ; require(mgcv)
if(!require(car)) install.packages("car") ; require(car)
if(!require(ggplot2)) install.packages("ggplot2") ; require(ggplot2)
if(!require(reshape)) install.packages("reshape") ; require(reshape)
if(!require(reshape2)) install.packages("reshape2") ; require(reshape2)
if(!require(ggspatial)) install.packages("ggspatial") ; require(ggspatial)
if(!require(stacomirtools)) install.packages("stacomirtools") ; require(stacomirtools) # for ODBC connections
if(!require(stringr)) install.packages("stringr") ; require(stringr)
if(!require(Hmisc)) install.packages("Hmisc") ; require(Hmisc)
if(!require(xtable)) install.packages("xtable") ; require(xtable)
if(!require(grid)) install.packages("grid") ; require(grid)
if(!require(RPostgreSQL)) install.packages("RPostgreSQL") ; require(RPostgreSQL)
if(!require(RColorBrewer)) install.packages("RColorBrewer") ; require(RColorBrewer)
#if(!require(stacomiR)) install.packages("stacomiR") ; require(stacomiR)
if(!require(dplyr)) install.packages("dplyr") ; require(dplyr)
if(!require(boot)) install.packages("boot") ; require(boot)
if(!require(MASS)) install.packages("MASS") ; require(MASS)
if(!require(lme4)) install.packages("lme4") ; require(lme4)
if(!require(multcomp)) install.packages("multcomp") ; require(multcomp)
if(!require(openxlsx)) install.packages("openxlsx") ; require(openxlsx)
if(!require(getPass)) install.packages("getPass") ; require(getPass)
if(!require(yaml)) install.packages("yaml") ; require(yaml)
set_flextable_defaults(
  font.size = 8.5, font.family = "Calibri",
  font.color = "black",
  table.layout = "autofit",
  border.color = "black",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4)


redtext <- fp_text(color = 'red', bold = TRUE)
purpletext <- fp_text(color = 'purple', bold = TRUE)

#--------------------------------
# get your current name 
#--------------------------------
getUsername <- function(){
	name <- Sys.info()[["user"]]
	return(name)
}

wddata <- getwd()
#<TAF_REMOVE>
if (getUsername() == "cedric.briand") setwd("C:/workspace/wg_WGEEL/R/recruitment") 
if (getUsername() %in% c("hilaire.drouineau", "hdrouineau") ) setwd("/home/hilaire.drouineau/Documents/Bordeaux/migrateurs/WGEEL/github/wg_WGEEL/R/recruitment") 
if (getUsername() == "hamme005") setwd("C:/Tessa/wg_WGEEL/R/recruitment") 
#baseODBC=c("wgeel","wgeel",passwordwgeel) #"w3.eptb-vilaine.fr" "localhost" "wgeel" "wgeel_distant" 
cred=read_yaml("../../credentials.yml")
# TODO 2022 use this to connect, not sqldf !!!!!!!!!!!!!!
# currently still using sqldf and RpostgreSQL() change for compatibility with linux

#<END_TAF_REMOVE>

wd <- wddata

datawd <- str_c(wddata,"/",CY,"/data/")
outputdatawd <- str_c(wddata,"/",CY,"/data/")
imgwd <- str_c(wddata,"/",CY,"/image/")
tabwd <- str_c(wddata,"/",CY,"/table/")
shinywd <-  str_c(wddata,"/../shiny_data_visualisation/shiny_dv/data/recruitment/")
dir.create(str_c(wddata,"/",CY),showWarnings = FALSE)
dir.create(datawd, showWarnings = FALSE)
dir.create(imgwd, showWarnings = FALSE)
dir.create(tabwd, showWarnings = FALSE)

source('utilities.R')
graphics.off() # close all graphics devices
# the results will be stored in a list, when I first run the program,
# on the second run this list will be loaded and I can avoid some steps in the calculation
# by setting the chunks as eval=FALSE

```



<!-- TAF_REMOVE -->
```{r load_database, echo=FALSE, fig.show='hide', eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
pwd = passwordwgeel = password = cred$password
con = dbConnect(RPostgres::Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=passwordwgeel)
load_database(con, path=c(shinywd,datawd), year=CY)
```
<!-- END_TAF_REMOVE -->


```{r load_rdata, echo=FALSE, fig.show='hide', eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
# In this rchunk we load the data even if there is no connection to the database
load(file=str_c(datawd,"wger_init.Rdata"))
load(file=str_c(datawd,"statseries.Rdata"))
load(file=str_c(datawd,"R_stations.Rdata"))
load(file=str_c(datawd,"t_series_ser.Rdata"))
load(file=str_c(datawd,"last_years_with_problem.Rdata"))
stopifnot(all(!is.na(R_stations$area)))
if(sum(is.na(wger_init$area))>0) stop("At least one series has not been affected to an area")
```


```{r select_series, echo=FALSE, fig.show='hide', eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
#this function do the selection of series, returning several datasets as well as
#selection_summary (a list with interesting statistics)
selection <- select_series(wger_init, R_stations)
selection_summary <- selection$selection_summary
glass_eel_yoy <- selection$glass_eel_yoy
older <- selection$older
wger <- selection$wger
R_stations <- selection$R_stations
save(wger, file = paste0(outputdatawd, "wger.Rdata"))
save(older, file = paste0(outputdatawd, "older.Rdata"))
save(glass_eel_yoy, file = paste0(outputdatawd, "glass_eel_yoy.Rdata"))

save(wger, file = paste0(shinywd,"wger.Rdata"))
save(older, file = paste0(shinywd,"older.Rdata"))
save(glass_eel_yoy, file = paste0(shinywd, "glass_eel_yoy.Rdata"))


```


```{r table_series,echo=FALSE, eval=TRUE,fig.show='hide', results="hide", warning = FALSE, message = FALSE, error=FALSE}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%				THIS CHUNK CREATES THE TABLES	
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
series_tables <- make_table_series(selection_summary, R_stations, wger)
selection_summary <- series_tables$selection_summary
R_stations <- series_tables$R_stations 
series_CY <- series_tables$series_CY
series_CYm1 <- series_tables$series_CYm1
series_lost <- series_tables$series_lost
series_prob <- series_tables$series_prob
printstatseriesY <- series_tables$printstatseriesY
printstatseriesGNS <- series_tables$printstatseriesGNS
printstatseriesGEE <- series_tables$printstatseriesGEE
printstatseriesGY <- series_tables$printstatseriesGY

xseries_CY <- xtable(x = series_CY,
    label = "table_seriesCY",
    caption = str_c("Series updated to ",CY, ". Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Area NS = North Sea, EE = Elsewhere Europe, Division = FAO marine division. Series ordered by stage and from North to South"),
    align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}", "p{1cm}","p{1.4cm}"))
print(xseries_CY, file = str_c(	tabwd,"/table_seriesCY.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    tabular.environment="tabularx",
    width="\\textwidth",
    include.rownames=FALSE
)

#------------------------------------------------------
# xtable of series current year minus one
#------------------------------------------------------
xseries_CYm1 <- xtable(x = series_CYm1,
    label = str_c("table_seriesCYm1"),
    caption = str_c("Series updated to ",CY-1, " see table \\ref{table_seriesCY)} for codes. Series ordered from North to South"),
    align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}"))

print(xseries_CYm1, 
    file = str_c(tabwd,"/table_seriesCYm1.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    tabular.environment="tabularx",
    width="\\textwidth",
    include.rownames=FALSE
)
#------------------------------------------------------
# xtable of series that have not been updated
#------------------------------------------------------
xseries_lost <- xtable(x = series_lost,
    label = str_c("table_serieslost"),
    caption = str_c("Series stopped or not updated to ",CY-1, " see table \\ref{table_seriesCY)} for codes. Series ordered by last year"),
    align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}","p{1.2cm}"))
print(xseries_lost, 
    file = str_c(tabwd,"/table_serieslost.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    tabular.environment="tabularx",
    width="\\textwidth",
    include.rownames=FALSE
)


xstatseriesGNS <- xtable(x = printstatseriesGNS, 
    label = str_c("statseriesG"),
    caption = str_c("Short description of the sampling sites for European eel recruitment data in the North Sea. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses."),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
    digits=0)

print(xstatseriesGNS , 
    file = str_c(tabwd,"/table_statseriesGNS.tex"),
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    include.rownames=FALSE
)

xstatseriesGEE <- xtable(x = printstatseriesGEE, 
    label = str_c("statseriesG"),
    caption = str_c("Short description of the sampling sites for European eel recruitment data for Elsewhere Europe. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses."),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
    digits=0)

print(xstatseriesGEE , 
    file = str_c(tabwd,"/table_statseriesGEE.tex"),
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    include.rownames=FALSE
)

xstatseriesGY <- xtable(x = printstatseriesGY, 
    label = str_c("statseriesGY"),
    caption = str_c("Short description of the recruitment sites (continued : stage glass eel and yellow eel)"),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
    digits=0)
print(xstatseriesGY , 
    file = str_c(tabwd,"/table_statseriesGY.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    include.rownames=FALSE
)

xstatseriesY <- xtable(x = printstatseriesY, 
    label = str_c("statseriesY"),
    caption = str_c("Short description of the recruitment sites (continued : yellow eel series) "),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}"),
    digits=0)
print(xstatseriesY, 
    file = str_c(tabwd,"/table_statseriesY.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    include.rownames=FALSE
)

################################################################
# Table of the problem in series for this year
################################################################
xseries_prob <- xtable(x = series_prob[1:15,],
    label = "table_series_prob",
    caption = str_c("Data in " ,CY-1, " and ", CY, " having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
            2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
    align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
)
print(xseries_prob,
    file = str_c(	tabwd,"/table_series_prob.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    #tabular.environment="longtable",
    include.rownames=FALSE
)
if (nrow(series_prob)>15){
  xseries_prob1 <- xtable(x = series_prob[15:30,],
      label = "table_series_prob1",
      caption = str_c("Table \\ref{table_series_prob} continued. Data in ",CY-1," and ",CY,"  having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
              2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
      align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
  )
  print(xseries_prob1,
      file = str_c(	tabwd,"/table_series_prob1.tex"),
      table.placement = "htbp",
      caption.placement = "top",
      sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
      NA.string = ".",
      #tabular.environment="longtable",
      include.rownames=FALSE
  )
}

if (nrow(series_prob)>30){
  xseries_prob2 <- xtable(x = series_prob[30:nrow(series_prob),],
      label = "table_series_prob2",
      caption = str_c("Table \\ref{table_series_prob} continued. Data in ",CY-1," and ",CY," having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
              2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
      align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
  )
  print(xseries_prob2,
      file = str_c(	tabwd,"/table_series_prob2.tex"),
      table.placement = "htbp",
      caption.placement = "top",
      sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
      NA.string = ".",
      #tabular.environment="longtable",
      include.rownames=FALSE
  )
}

# when have the series been more than 10 years ?
#res <- bind_rows(glass_eel_yoy,older) %>% arrange(site, year) %>% 
#		mutate(count=1) %>% 
#		group_by(site) %>% 
#		mutate(n=cumsum(count)) %>%
#		#filter(site=='BrokGY')
#		filter(n==10)%>%
#		dplyr::select(site, year)




```


```{r figureseries, echo=FALSE,  eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dd <- as.data.frame(table(year=wger$year,lifestage=wger$lifestage))
dd$lifestage <- ifelse(dd$lifestage == "glass eel + yellow eel",
                        "mixed glass and yellow eels", as.character(dd$lifestage))
figure2 <- ggplot(dd, aes(x=as.numeric(as.character(year)), y=Freq, group=lifestage, col=lifestage)) + geom_point() + geom_line(lwd=2) + ylab('number of series') +xlab('year')+
		theme(text=element_text(size=12))+
		scale_x_continuous(limits=c(1900,CY))+
		theme_bw()+
		theme(text = element_text(size=20),
				axis.text.x = element_text(angle=0, hjust=1))+
		theme(legend.position = c(0.25,0.75), legend.text = element_text( size = 20))


print(figure2)
save_figure(figname="figure2",figure2,800,600)

ddd <- as.data.frame(table(year=wger$year,lifestage=wger$lifestage, area=wger$area2))
ddd$lifestage <- ifelse(ddd$lifestage == "glass eel + yellow eel",
                        "mixed glass and yellow eels", as.character(ddd$lifestage))

figure2.1 <- ggplot(ddd, aes(x=as.numeric(as.character(year)), y=Freq, group=lifestage, col=lifestage)) + geom_point() + geom_line(lwd=2) + ylab('number of series') +xlab('year')+
		facet_wrap(~factor(ddd$area), ncol=2) +
		theme(text=element_text(size=10))+
		scale_x_continuous(limits=c(1900,CY))+
		theme_bw()+
		theme(text = element_text(size=25),
				axis.text.x = element_text(angle=0, hjust=1))+
		# theme(legend.position = c(0.15,0.88), legend.text = element_text( size = 15),axis.text.x = element_text(angle = 45, size=16))
		theme(legend.text = element_text( size = 15),axis.text.x = element_text(angle = 45, size=16))



print(figure2.1)
save_figure(figname="series_no_area",figure2.1,1000,500)
```


```{r mapseries,echo=FALSE, eval=TRUE,results="hide", warning = FALSE, message = FALSE, error=FALSE,fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


# if problems see https://github.com/dkahle/ggmap/issues/160

if(!require(ggmap)) install.packages("ggmap") ; require(ggmap)
if(!require(sf)) install.packages("sf") ; require(sf)
if(!require(RPostgres)) install.packages("RPostgres") ; require(RPostgres)

load("../shiny_data_visualisation/shiny_dv/data/ref_and_eel_data.Rdata")
source("../utilities/load_library.R")
source("../shiny_data_visualisation/shiny_dv/database_connection.R")



# my_map <- get_map( c(left = -13, bottom = 35, right =
# 						27, top = 65),zoom=4, maptype = c("stamen_watercolor"))


#<TAF_REMOVE>
if (!file.exists(paste0(datawd,"fao.rdata"))){
con <- dbConnect(Postgres(),host=cred$host,password=cred$password,dbname=cred$dbname,user=cred$user)
fao <- st_read(con,query="select * from ref.tr_faoareas")
fao <- st_crop(fao, xmin = -13, xmax = 27,
		ymin = 35, ymax = 65)
fao <- st_transform(fao,3857)
fao$zone <- 
		ifelse(startsWith(fao$f_code,"27.4.") | startsWith(fao$f_code,"27.3."),
				"North Sea",
				"Elsewhere Europe")
# this is not used but just in case
fao$zoneyellow <- ifelse(fao$f_code %in% c("27.3.d",'27.3.b, c'),"Baltic",
    ifelse(startsWith(fao$f_code,"27.4.") | startsWith(fao$f_code,"27.3."),
        "North Sea",
        ifelse(startsWith(fao$f_code,"37"), "Mediterranean_sea",
        "Elsewhere Europe")))

save(fao, file=paste0(datawd,"fao.Rdata"))
}
#<END_TAF_REMOVE>

load(paste0(datawd,"fao.Rdata"))
# ggmap_bbox <- function(map) {
# 	if (!inherits(map, "ggmap")) stop("map must be a ggmap object")
# 	# Extract the bounding box (in lat/lon) from the ggmap to a numeric vector, 
# 	# and set the names to what sf::st_bbox expects:
# 	map_bbox <- setNames(unlist(attr(map, "bb")), 
# 			c("ymin", "xmin", "ymax", "xmax"))
# 	
# 	# Coonvert the bbox to an sf polygon, transform it to 3857, 
# 	# and convert back to a bbox (convoluted, but it works)
# 	bbox_3857 <- st_bbox(st_transform(st_as_sfc(st_bbox(map_bbox, crs = 4326)), 3857))
# 	
# 	# Overwrite the bbox of the ggmap object with the transformed coordinates 
# 	attr(map, "bb")$ll.lat <- bbox_3857["ymin"]
# 	attr(map, "bb")$ll.lon <- bbox_3857["xmin"]
# 	attr(map, "bb")$ur.lat <- bbox_3857["ymax"]
# 	attr(map, "bb")$ur.lon <- bbox_3857["xmax"]
# 	map
# }
# my_map<- ggmap_bbox(my_map)
stations <- st_transform(st_as_sf(R_stations,coords=c("ser_x","ser_y"),crs=4326),3857)
#stations <- st_as_sf(R_stations,coords=c("ser_x","ser_y"),crs=4326)

stations$X = st_coordinates(stations)[,"X"]
stations$Y = st_coordinates(stations)[,"Y"]

singlemap <- ggplot() +
  annotation_map_tile(type = "https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/${z}/${x}/${y}.jpg")+ 
		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone,alpha="1")) +
		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone)) +
		geom_sf_text(data=st_centroid(fao), inherit.aes=FALSE,aes(label=f_code),cex=1.5) +
#		geom_sf(data=stations,aes(color=ser_lfs_code,shape=ser_lfs_code),size=2, inherit.aes = FALSE)+
#		geom_sf(data=subset(stations,ser_lfs_code!="Y" & ser_qal_id==1),color = 'black',size=2, shape = 21,
#				inherit.aes=FALSE) +
#		geom_sf(data=subset(stations,ser_lfs_code=="Y"& ser_qal_id==1),color = 'black',size=2, shape = 24,
#				inherit.aes=FALSE) +
		geom_point(data=subset(stations, (ser_qal_id==1 |ser_qal_id==4)) ,aes(x=X,y=Y,
						color=ser_lfs_code,shape=ser_lfs_code,stroke=0),size=3)+
		geom_point(data=subset(stations,ser_lfs_code!="Y"& (ser_qal_id==1 |ser_qal_id==4)),
				color = 'black', 
				size=3, 
				shape = 21,
				stroke=1,
				aes(x=X,y=Y)) +
		geom_point(data=subset(stations,ser_lfs_code=="Y"& (ser_qal_id==1 |ser_qal_id==4)),
				color = 'black',		
				size= 3, 
				shape = 24,
				stroke =1,
				aes(x=X,y=Y)) +
		
		scale_color_manual("Life stage",values=c("white","grey","yellow")) +
		scale_shape_manual("Life stage", values=c(19,19,17)) + xlab("") + ylab("") +
		scale_fill_manual(NULL,values=c("#33b1c4","#30ff8a","#1a81db")) +
		guides(alpha=guide_legend("Recruitment series",
						legend.background = element_blank(),
						title.theme=element_text(face="bold"),
						keyheight=0,
						label.theme=element_text(size=0,lineheight=0),
						order=1, 
						override.aes=list(color=NA, shape=NA, alpha=NA, fill=NA))) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent")
		
		)
print(singlemap)


mapG <- ggplot() +
  annotation_map_tile(type = "https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/${z}/${x}/${y}.jpg")+
  geom_sf(data=fao %>% filter(zone %in% c("North Sea","Elsewhere Europe")), inherit.aes = FALSE, aes(fill=zone)) +
#		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone)) +
		geom_sf_text(data=st_centroid(fao), inherit.aes=FALSE, aes(label=f_code),cex=1.5) +
#		geom_sf(data=stations,aes(color=ser_lfs_code,shape=ser_lfs_code),size=2, inherit.aes = FALSE)+
#		geom_sf(data=subset(stations,ser_lfs_code!="Y" & ser_qal_id==1),color = 'black',size=2, shape = 21,
#				inherit.aes=FALSE) +
#		geom_sf(data=subset(stations,ser_lfs_code=="Y"& ser_qal_id==1),color = 'black',size=2, shape = 24,
#				inherit.aes=FALSE) +
		geom_point(data=stations %>% filter(ser_qal_id == 1 & ser_lfs_code %in% c("G", "GY")),aes(x=X,y=Y,
						color=ser_lfs_code,stroke=0),shape=19,size=3)+
		 geom_point(data=subset(stations,ser_qal_id==1&  ser_lfs_code %in% c("G", "GY")),
		 		color = 'black', 
		 		size=3, 
		 		shape = 21,
		 		stroke=1,
		 		aes(x=X,y=Y)) +
		guides(fill = guide_legend(override.aes = list(shape = 21))) +
		scale_fill_manual("Area",values=c("#33b1c4","#1a81db","#30ff8a")) +
		scale_color_manual("Life stage",values=c("white","grey","yellow"))+
		guides(alpha=guide_legend("Recruitment series",
						legend.background = element_blank(),
						title.theme=element_text(face="bold"),
						keyheight=0,
						label.theme=element_text(size=0,lineheight=0),
						order=1, 
						override.aes=list(color=NA, shape=NA, alpha=NA, fill=NA))) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent"),
				axis.text=element_text(size=8),
				plot.margin=margin(0.,0.1,0.1,0.1, "cm")
		
		) + xlab("")+ylab("")

mapY <- ggplot()+
  annotation_map_tile(type = "https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/${z}/${x}/${y}.jpg")+
		coord_sf(crs = st_crs(3857)) + # force it to be 3857
		geom_sf(data=fao, inherit.aes = FALSE, fill=NA) +
		geom_sf_text(data=st_centroid(fao), inherit.aes=FALSE,aes(label=f_code),cex=1.5) +
#		geom_sf(data=stations,aes(color=ser_lfs_code,shape=ser_lfs_code),size=2, inherit.aes = FALSE)+
#		geom_sf(data=subset(stations,ser_lfs_code!="Y" & ser_qal_id==1),color = 'black',size=2, shape = 21,
#				inherit.aes=FALSE) +
#		geom_sf(data=subset(stations,ser_lfs_code=="Y"& ser_qal_id==1),color = 'black',size=2, shape = 24,
#				inherit.aes=FALSE) +
		geom_point(data=stations %>% filter(ser_qal_id == 1 & ser_lfs_code %in% c("Y")),aes(x=X,y=Y,
						color=ser_lfs_code,stroke=0),shape=17,size=3)+
		 geom_point(data=subset(stations,ser_qal_id==1&  ser_lfs_code %in% c("Y")),
		 		color = 'black', 
		 		size=3, 
		 		shape = 24,
		 		stroke=1,
		 		aes(x=X,y=Y)) +
		guides(fill = guide_legend(override.aes = list(shape = 21))) +
		scale_color_manual("Life stage",values=c("white","grey","yellow"))+
		guides(alpha=guide_legend("Recruitment series",
						legend.background = element_blank(),
						title.theme=element_text(face="bold"),
						keyheight=0,
						label.theme=element_text(size=0,lineheight=0),
						order=1, 
						override.aes=list(color=NA, shape=NA, alpha=NA, fill=NA))) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent"),
				axis.text=element_text(size=8),
				plot.margin=margin(0.,0.1,0.1,0.1, "cm") 
		
		) + xlab("")+ylab("")

figure1 <- ggpubr::ggarrange(plotlist=list(mapG,mapY),nrow=1)
print(figure1)
save_figure("figure1",figure1,1100,800)
save_figure("singlemap",singlemap,1100,800)

```


```{r tableswgeel,echo=FALSE, eval=FALSE,results="hide", warning = FALSE, message = FALSE, error=FALSE}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# THIS R CHUNCK IS USED ONCE AT THE END TO GENERATE THE TABLES.
## This will fail if saved twice, run at the end of the working group to generate the table of values
wger_init$das_order <- order(wger_init$cou_order, wger_init$ser_y, wger_init$site, wger_init$year)
wger_init$ser_order <- rank(order(wger_init$cou_order, wger_init$ser_y, wger_init$site))
dat <- wger_init[wger_init$ser_order,]
dat$year=as.factor(dat$year)


tab1 <- reshape2::dcast(dat,year~site,value.var="value")
tab1[,2:ncol(tab1)]=round(tab1[,2:ncol(tab1)],2)
tab1[,1] <- as.character(tab1[,1])

statseries <- statseries[order(statseries$site),]

first_line <- c("kept",statseries$series_kept)
tab1 <- rbind(first_line,tab1)


openxlsx::write.xlsx(x=list("recruitment_series"=tab1,
				"series_description"=statseries, 
        "stat_G_EE"=printstatseriesGEE,
        "stat_G_NS"=printstatseriesGNS,
        "stat_GY"=printstatseriesGY,
        "stat_Y"=printstatseriesY,
        "t_series_ser"=t_series_ser),file=str_c(outputdatawd,"table_rec", CY, ".xlsx"))

openxlsx::write.xlsx(x=list("wger_init"=wger_init,
				"older"=older, "wger"=wger),file=str_c(outputdatawd,"table_long", CY, ".xlsx"))

```

```{r generation_of_plot_data, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.show='hide'}
###################################################
# Generation of the dataframes used to plot the data
# two similar dataframe are created
# with the new ggplot2 it is no longer necessary but code was developped earlier at
# the time when such format was still necessary
# we will create a first dataframe (scal) with all the series together, this was
# the initial analysis built by Wgeel, and it is kept for historical consistency
# later on the geomean have been added , and the graph add a bootstrap calculation of the mean (bootscal)
# At some point the wgeel discussed that it might make more sense to separate
# glass eel (scalgeel) and yellow eel (scalyellow), so this graph is showing all, the geomean on all series, the
# trend for glass eel and the trend for yellow eel. This graph shows "unprocessed" data,
# as the wgeel recruitment index uses a glm index to rebuilt a consistent series.
# At some point ACFM asked to use a different scaling period and we complied but the graph
# is no longer shown as it is a bit confusing.
# below now a geom bootstrap is proposed. 
# TODO  2018 discuss whether to present arithmetic (not really good), geometric mean,
# or nothing at all (Willem's suggestion)
###################################################
sgeomean.cl.boot <- function (x, conf.int = 0.95, B = 1000, na.rm = TRUE, reps = FALSE) 
{
	if (na.rm)    x <- x[!is.na(x)]
	n <- length(x)
	# geomean returns a dataframe, convert it to vector
	xbar <- as.numeric(geomean(x))
	if (n < 2L) # 2L is an integer
		return(c(Mean = xbar, Lower = NA, Upper = NA))
	z <- unlist(lapply(seq_len(B), function(i, x, N) sum(x[sample.int(N, 
												N, TRUE, NULL)]), x = x, N = n))/n
	quant <- quantile(z, c((1 - conf.int)/2, (1 + conf.int)/2))
	names(quant) <- NULL
	res <- c(Geomean = xbar, Lower = quant[1L], Upper = quant[2L])
	if (reps) 
		attr(res, "reps") <- z
	res
}
scal=data.frame("year"=as.numeric(names(tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE),
		"ymax"=tapply(wger$value_std_1979_1994,wger$year,max,na.rm=TRUE),
		"mean"=tapply(wger$value_std_1979_1994,wger$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(wger$value_std_1979_1994,wger$year,geomean,na.rm=TRUE)))


li_cl_boot=tapply(wger$value_std_1979_1994,wger$year,smean.cl.boot)
li_cl_boot_geomean=tapply(wger$value_std_1979_1994,wger$year,sgeomean.cl.boot)
bootscal=data.frame("year"=as.numeric(names(li_cl_boot)),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
		"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
		"ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
		"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),    
		"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
		"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))
# creating a subset with all data (glass_eel_yoy is limited in its timeframe)
datageel=subset(wger,wger$lifestage!="yellow eel")
scalgeel=data.frame(
		"year"=as.numeric(names(tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE),
		"ymax"=	tapply(datageel$value_std_1979_1994,datageel$year,max,na.rm=TRUE),
		"mean"=tapply(datageel$value_std_1979_1994,datageel$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean,na.rm=TRUE))
)
datayellow=subset(wger,wger$lifestage=="yellow eel")
scalyellow=data.frame(
		"year"=as.numeric(names(tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE),
		"ymax"=	tapply(datayellow$value_std_1979_1994,datayellow$year,max,na.rm=TRUE),	
		"mean"=tapply(datayellow$value_std_1979_1994,datayellow$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean,na.rm=TRUE)))
scaldata=wger[,c("year","value_std_1979_1994","value_std","site","lifestage")]
################################################################
# With scaling 2000-2010
##############################################################

scal_2000_2009=data.frame("year"=as.numeric(names(tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE),
		"ymax"=tapply(wger$value_std_2000_2009,wger$year,max,na.rm=TRUE),  
		"mean"=tapply(wger$value_std_2000_2009,wger$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(wger$value_std_2000_2009,wger$year,geomean)))
li_cl_boot=tapply(wger$value_std_2000_2009,wger$year,smean.cl.boot)
bootscal_2000_2009=data.frame("year"=as.numeric(names(li_cl_boot)),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
		"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
		"ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
		"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),
		"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
		"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))

scalgeel_2000_2009=data.frame(
		"year"=as.numeric(names(tapply(datageel$value_std_2000_2009,datageel$year,min))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datageel$value_std_2000_2009,datageel$year,min,na.rm=TRUE),
		"ymax"=	tapply(datageel$value_std_2000_2009,datageel$year,max,na.rm=TRUE),	
		"mean"=tapply(datageel$value_std_2000_2009,datageel$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datageel$value_std_2000_2009,datageel$year,geomean))
)

scalyellow_2000_2009=data.frame(
		"year"=as.numeric(names(tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE),
		"ymax"=	tapply(datayellow$value_std_2000_2009,datayellow$year,max,na.rm=TRUE),	
		"mean"=tapply(datayellow$value_std_2000_2009,datayellow$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datayellow$value_std_2000_2009,datayellow$year,geomean,na.rm=TRUE)))
scaldata_2000_2009=wger[,c("year","value_std_2000_2009","site","lifestage")]

#########################
# for Miran
# exporting the geomeans 
########################
print("simple geomeans for glass eel, asked by Miran")
round(unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean)),3)
print ("simple geomeans for yellow eels")
round(unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean)),3)

########################################
# FIGURE 3 WITHOUT LOG SCALE
# normalscale + geomean+ bootstrap scaled mean and confidence interval
#########################################

# first option, in the following figure the red line represents the geometric means
# and the dots are the bootstrap means
g <- ggplot(scaldata)
g1 <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
		ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
		theme(legend.position = "none")

figure3withoutlogscale <- g1+	scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)

print(figure3withoutlogscale)
save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)

# second option, in the following figure the blue line represents the arithmetic means
# and the dots are the bootstrap geommeans

g <- ggplot(scaldata)
g2 <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
		ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=geomean,ymin=ymin_geomean,ymax=ymax_geomean),size=0.5,colour="black")+
		geom_line(data=scal,aes(x=year,y=mean),colour="#003366",size=1.2)+
		theme(legend.position = "none")

figure3withoutlogscale_opt2 <- g2+scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)

print(figure3withoutlogscale_opt2)

save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)
save_figure("figure3withoutlogscale_opt2",figure3withoutlogscale_opt2,800,600)
# scaldata[scaldata$year>2000&scaldata$value_std>1,]
########################################
# FIGURE 3 WITH LOG SCALE
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

figure3 <- g1+
		scale_y_log10(name="scaled 1979-1994 values log scale",limits=c(0.001,30),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
		#ylab()
		
		scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)

print(figure3)
save_figure(figname="figure3",figure3,800,600)


figure3bis <- g1+
		scale_y_log10(name="scaled 1979-1994 values log scale",
				limits=c(0.001,30),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)

print(figure3bis)

save_figure(figname="figure3",figure3,800,600)
save_figure(figname="figure3bis",figure3bis,800,600)

########################################
# FIGURE 3 WITH LOG SCALE {{BLACK}}
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

g <- ggplot(scaldata)
figure3black <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5,show.legend=FALSE)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4,show.legend=FALSE)+
		#ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
		geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
		scale_y_log10(name="percentage of 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
		scale_x_continuous(breaks=c(1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,CY))+
		theme_black()

print(figure3black)
# {{{{{{{{{{{{{{{{{{{{{{{{{
save_figure(figname="figure3black",figure3black,800,600)

# {{{{{{{{{{{{{{{{{{{{{{{{{
##########################################
## Same graph for presentation but labels are in French
##########################################
#g <- ggplot(scaldata)
#g+geom_point(aes(x=year, y=value_std,colour=site,shape=lifestage),size=1.5,legend=FALSE)+
#		geom_line(aes(x=year, y=value_std,colour=site,lty=lifestage),size=0.4,legend=FALSE)+
#		opts(title="Tendance du recrutement Europeen")+
#		#ylab("scaled 1979-1994 values")+
#		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
#		scale_y_log10(name="% de 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
#		scale_x_continuous(name="Annee",breaks=c(1930,1950,1970,1980,1990,2000,2010),
#				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,2010))+theme_dark()
########################################
# FIGURE 4 
# limited graph with scale
########################################
scallog <- scal
scallog[scallog$ymin<1e-2,"ymin"] <- 1e-2
scallog[scallog$ymax>30,"ymax"] <- 30
g <- ggplot(scallog)
figure4 <- g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey",data=scallog)+
		ylab("scaled 1979-1994 values log scale")+
		geom_line(aes(x=year,y=mean),data=scalgeel,colour="darkblue",size=1)+
		geom_line(aes(x=year,y=mean),data=scalyellow,colour="darkorange4",size = 1)+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		scale_y_log10(limits=c(0.01,30),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+
		annotate("rect",xmin=1930,ymin=0.01,xmax=1960,ymax=30,fill="white",alpha=0.7)+
		scale_x_continuous(limits=c(1930,CY))

print(figure4)
save_figure(figname="figure4",figure4,800,600)

########################################
# FIGURE 4 
# BUT WITH REFERENCE 2000-2010 !
########################################
scallog <- scal_2000_2009
scallog[scallog$ymin<1e-1,"ymin"] <- 1e-1
scallog[scallog$ymax>1000,"ymax"] <- 1000
g <- ggplot(scallog)
figure42000_2009 <- g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey")+
		#ggtitle("Recruitment European overview")+
		ylab("scaled to 2000-2010, log scale")+
		geom_line(aes(x=year,y=mean),data=scalgeel_2000_2009,colour="darkblue",size=1)+
		geom_line(aes(x=year,y=mean),data=scalyellow_2000_2009,colour="darkorange4",size = 1)+
		geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		geom_abline( intercept = 0,slope=0,	alpha = .4,col="red")+
		geom_abline( intercept = 2,slope=0,	alpha = .4,col="red")+
		scale_y_log10(limits=c(1e-1,1000),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+		
		scale_x_continuous(limits=c(1930,CY))+
		annotate("rect",xmin=1930,ymin=1e-1,xmax=1960,ymax=1000,fill="white",alpha=0.7)+
		annotate("rect", xmin = 2000, xmax = 2009, ymin = 0.3, ymax = 3,
				alpha = .2,fill="blue")


print(figure42000_2009)

save_figure(figname="figure4_2000_2009",figure42000_2009,800,600)

########################################
# FIGURE NOTHING 
# JUST TO CHECK 
########################################

xg <- unlist(tapply(datageel$value_std,datageel$year,geomean))
rxg <- as.numeric(names(xg))
xy <- unlist(tapply(datayellow$value_std,datayellow$year,geomean))
rxy <- as.numeric(names(xy))
plot(rxg,
		xg,
		type="b",
		main="a simple graph to check that ggplot's running fine")
points(rxy,xy,type="l",col="green")
legend("topright",legend=c("glass","yellow"),col=c("black","green"),lty=1)

# additional figure to check log scaled

plot(rxy,
		xy,log="y",
		type="b",col="green")
points(rxg,xg,type="l")
#tapply(wger$value_std,wger$year,mean_cl_boot)


########################################
# Figure to put forward recent changes in the series
# WITH REFERENCE 2000-2010 !
########################################
figure_check_one_series <- function(site='KatwG',limits=c(1900,CY)){
	g <- ggplot(scaldata_2000_2009)
	g <- g+geom_point(aes(x=year, y=value_std_2000_2009),col="grey",size=1.5)+
			geom_line(aes(x=year, y=value_std_2000_2009),col="grey",size=0.4)+
			geom_point(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
			geom_line(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
			ylab("scaled 2000-2009 values")+
			geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
			geom_line(data=scal_2000_2009,aes(x=year,y=geomean),colour="red",size=1.2)+
			theme(legend.position = "none")+
			scale_x_continuous(limits=limits,breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata_2000_2009$year),to=max(scaldata_2000_2009$year),by=2))+
			scale_y_continuous(limits=c(0,20))+
			annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
	return(g)
}

figure_check_one_series("KatwG",limits=c(1960,2019))
```


```{r model_for_glass_eel_and_yellow_eel_datasets, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}

# glass_eel_yoy$site <- as.factor(glass_eel_yoy$site)

model_ge_area=glm(value_std~year_f:area+site,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log), maxit=300)

# lesser fit :
#model_ge_area1=glm(value_std~year_f:area + as.factor(lfs_code),
#		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
#		family=Gamma(link=log), maxit=300)

print("Analysis for glass eel")
print("data available")
(area_year=table(glass_eel_yoy$year,glass_eel_yoy$area))
print("number of sites finally selected for glass eel glm")
selection_summary$modelge <- list()
selection_summary$modelge$site <- as.character(model_ge_area$xlevels$site)
(selection_summary$modelge$nbsite <- length(selection_summary$modelge$site))
selection_summary$modelge$excluded <- unique(glass_eel_yoy$site)[!unique(glass_eel_yoy$site)%in%selection_summary$modelge$site]
selection_summary$modelge$value_excluded_zero <- glass_eel_yoy[glass_eel_yoy$value==0&!is.na(glass_eel_yoy$value),
		c("value_std","site","year","lifestage","das_comment","area")]

model_older=glm(value_std~year_f+as.factor(site),data=older,family=Gamma(link=log),
		subset=older$value>0 & older$year>1949  ,maxit=300)
selection_summary$modelolder <- list()
selection_summary$modelolder$site <- as.numeric(as.character(model_older$xlevels$`as.factor(site)`))
selection_summary$modelolder$nbsite <- length(selection_summary$modelolder$site)
selection_summary$modelolder$excluded <- unique(older$site)[!unique(older$site)%in%selection_summary$modelolder$site]
selection_summary$modelolder$excludedsite <- unique(older[older$site%in%selection_summary$modelolder$excluded,"site"])
selection_summary$modelolder$excludedsite <- unique(older[older$site%in%selection_summary$modelolder$excluded,"site"])
selection_summary$modelolder$value_excluded_zero <- older[older$value==0,
		c("value_std","site","year","lifestage","das_comment","area")]

xt_a <- xtable(Anova(model_ge_area,test="F"),
		caption=c("Anova for glass eel recruitment model",
				label="table_anova"))

o <- print(xt_a, file = str_c(tabwd,"/table_anova.tex"), 
		table.placement = "htbp",
		caption.placement = "top",
		NA.string = "",
		include.rownames=TRUE,
		tabular.environment="tabularx",
		width="0.8\\textwidth",
		sanitize.colnames.function=function(x){x})	
save(model_ge_area,model_older,file=paste0(shinywd,"recruitment_models.Rdata"))
#plot(model_ge_area)
```

```{r mixed_models, echo=FALSE, eval=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}


library(lme4)
# Mixed models are used because there is no independence between series collected at the same site.
# Here we create a new column location to "join" those series and treat the location as a mixed effect in the model.
glass_eel_yoy$location <- as.character(glass_eel_yoy$site)
unique(glass_eel_yoy$location)
adour_id <- grep("Ad", glass_eel_yoy$location); glass_eel_yoy$location[adour_id]
glass_eel_yoy$location[adour_id] <- "Adou"
albufera_id <- grep("Al", glass_eel_yoy$location); glass_eel_yoy$location[albufera_id]
glass_eel_yoy$location[albufera_id] <-"Albu"
minho_id <- grep("Mi", glass_eel_yoy$location); glass_eel_yoy$location[minho_id]
glass_eel_yoy$location[minho_id] <-"Minho"
gironde_id <- grep("Gi", glass_eel_yoy$location); glass_eel_yoy$location[gironde_id]
glass_eel_yoy$location[minho_id] <-"Giro"
brownhill_id <- grep("Bro", glass_eel_yoy$location); glass_eel_yoy$location[brownhill_id]
glass_eel_yoy$location[minho_id] <-"Bro"
flatford_id <- grep("Fla", glass_eel_yoy$location); glass_eel_yoy$location[flatford_id]
glass_eel_yoy$location[minho_id] <-"Fla"

glass_eel_yoy$lfs_code <- as.factor(glass_eel_yoy$lfs_code)
glass_eel_yoy$location <- as.factor(glass_eel_yoy$location)

# glmer is used to fit generalized (non-Gaussian) linear mixed models
glmer1 <- glmer(value_std~year_f:area+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer11 <- glmer(value_std~year_f:area+location+(1|site), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer12 <- glmer(value_std~year_f:area+site+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

# model_ge_area is the glm, compare it with ANOVA, this should be fine since is ML



# The deviance The deviance is basically a measure of how much unexplained variation there is in 
# regression model  the higher the value the less accurate the model
devglmer1 <- -2*logLik(glmer1)
devglm <- -2*logLik(model_ge_area)
# diffence of deviance between the two models
(delta_dev <- as.numeric(devglmer1-devglm))
(delta_df <- attr(devglm,"df")-attr(devglmer1,"df"))
## the GLM has a better fit
cat('Chi-square =', delta_dev, '(df=', delta_df,'), p =', 
		pchisq(delta_dev,delta_df,lower.tail=FALSE), "\n")
# same shown here
anova( glmer1, model_ge_area,  test="Chisq")
# So the glm is better than the mixed model



# Here we compare the mixed structure of the models, so we are using REML

glmer1 <- glmer(value_std~year_f:area+site+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glass_eel_yoy$year2 <- pmax(year,2011)
# model with  lfs_code

glmer2 <- glmer(value_std~year_f:area+(1+year|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer3 <- glmer(value_std~year_f:area+(1+year|location) + (1+year2|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

anova(glmer2, glmer1, refit=FALSE)

save(glmer1, glmer2, glmer3, file=paste0(outputdatawd,glmer.Rdata))
#fixef(glmer1)['(Intercept)'] + ranef(glmer1)$location

```


```{r model_for_glass_eel_graph_and_predictions, fig.show='hide',echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
# 1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~
######################################"
#~glass eel (and elver = glass eel + yellow eel) migrant analysis
######################################"~

########new sets of lines to graph plots with confidence intervals
# using expand.grid to build a complete grid for predictions
dat_ge=expand.grid(year_f=model_ge_area$xlevels$year_f,area=model_ge_area$xlevels$area,
		site=model_ge_area$xlevels$site[1])
dat_ge$year <- as.numeric(as.character(dat_ge$year_f))


#predicting
dat_ge$p=predict(model_ge_area,newdata=dat_ge)
dat_ge$se=predict(model_ge_area,newdata=dat_ge,se.fit=TRUE)[["se.fit"]]



mean_1960_1979 <- aggregate(dat_ge[dat_ge$year<1980,"p"],list(dat_ge[dat_ge$year<1980,"area"]),mean)
names(mean_1960_1979) <- c("area","mean")	



dat_ge <- merge(dat_ge,mean_1960_1979,by="area")
dat_ge$p_std_1960_1979 <- exp(dat_ge$p-dat_ge$mean)
dat_ge$p_std_1960_1979_min <- exp(dat_ge$p-dat_ge$mean-1.96*dat_ge$se)
dat_ge$p_std_1960_1979_max <- exp(dat_ge$p-dat_ge$mean+1.96*dat_ge$se)


upperlimit  <- 5
dat_ge$p_std_1960_1979_maxgraph <- pmin(dat_ge$p_std_1960_1979_max,upperlimit-0.01)

g <- ggplot(dat_ge,aes(x=year,y=p_std_1960_1979))

figure5_without_logscale<- g+
		geom_line(aes(colour=area,lty=area),lwd=1)+ 		
		scale_colour_brewer(name="area",palette="Set1")+
		geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_maxgraph,fill=area),alpha=.3)+
		coord_cartesian(ylim=c(0,5))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position = c(.8, .8))


figure5_advice_EE<- ggplot(dat_ge %>% filter(area == "Elsewhere Europe"),
                           aes(x=year,y=p_std_1960_1979)) +

		geom_line(lwd=1, aes(col=area), show.legend=FALSE)+ 		
		geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_maxgraph,fill=area),alpha=.3, show.legend=FALSE)+
		coord_cartesian(ylim=c(0,5))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme_ICES_plots("Recruitment") + ggtitle("Elsewhere Europe")

figure5_advice_EE
save_figure("figure5_advice_EE",figure5_advice_EE,600,480, pdf = FALSE)


figure5_advice_NS<- ggplot(dat_ge %>% filter(area == "North Sea"),
                           aes(x=year,y=p_std_1960_1979)) +

		geom_line(lwd=1, aes(col=area))+ 		
		geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_maxgraph,fill=area),alpha=.3, show.legend=FALSE)+
		coord_cartesian(ylim=c(0,5))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme_ICES_plots("Recruitment") + ggtitle("North Sea")

figure5_advice_NS
save_figure("figure5_advice_NS",figure5_advice_NS,600,480, pdf = FALSE)


# function similar to theme_dark() but allows legends
# black and white plot ====
figure5_without_logscale_black <- g+geom_line(aes(colour=area,lty=area),lwd=1)+
		scale_colour_manual(name="area",values=c("yellow","lawngreen"))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_black()+
		geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)+
		scale_fill_manual(name="area",values=c("yellow","lawngreen"))


figure5_without_logscale_black
save_figure("figure5_without_logscale_black_ribbon",figure5_without_logscale_black,600,480)


#====
#+geom_smooth(aes(ymin = min, ymax = max,fill=area),stat="identity")+facet_grid( ~ area) 
figure5 <- g+geom_line(aes(colour=area,lty=area),lwd=1.3)+geom_point(aes(colour=area,fill=area,shape=area),size=3)+
		#ggtitle("Recruitment overview glass eel series")+
		scale_colour_brewer(name="area",palette="Set1")  +
		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position=c(.8,.9))+geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)


figure5
save_figure("figure5_ribbon",figure5,600,480)
#figure5danish <- g+geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		ggtitle("title="Glasaal data fra hele Europa")+
#		scale_colour_brewer(name="area",palette="Set1")  +
#		xlab("Aar")+
#		scale_y_log10(name="Linear model forudsigelser/ gennemsnit 1960-1979",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#figure5danish

#levels(dat$area) <- c (
#		iconv("Andre steder i Europa","UTF8"),
#		iconv("Nordsj?en","UTF8"))#
#g <- ggplot(dat,aes(x=year,y=p_std_1960_1979))
#figure5norvegiean <- g+
#		geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,shape=area),size=3)+
#		ggtitle(label=iconv("Indeks av glass?lrekruttering","UTF8"))+
#		scale_colour_brewer(name=iconv("Omr?det","UTF8"),palette="Set1")  +
#		scale_shape(name=iconv("Omr?det","UTF8"))+
#		scale_linetype(name=iconv("Omr?det","UTF8"))+
#		xlab(iconv("?r","UTF8"))+
#		scale_y_log10(name=iconv("Standardiserte GLM-prognoser (i prosent av
#		1960-1979-gjennomsnitt)","UTF8"), #limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#save_figure("figure5norvegiean",figure5norvegiean,600,480)
#pdf("images/2013/figure5norvegiean.png")
#figure5norvegiean
#dev.off()
save_figure("figure5_ribbon",figure5,600,480)



#figure5bw <- g+geom_line(aes(colour=area,lty=area),wd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		#ggtitle("Recruitment overview glass eel series")+
#		scale_colour_manual(name="area",values=c("black","grey40"))  +
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
#		scale_y_log10(name="standardized glm predictions \n mean 1960-1979-log scale",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))+
#		theme_bw()+
#		theme(legend.box =NULL,
#				legend.key = element_rect(colour = NA, fill = 'white'),
#				legend.text = element_text(size = 8, colour = 'black'), 
#				legend.background = element_rect(colour = NA, fill = 'white'))
#print(figure5bw)
#save_figure("figure5bw",figure5bw,600,480)


pred <- dcast(dat_ge,year~area,value.var="p_std_1960_1979")
predmin <- dcast(dat_ge,year~area,value.var="p_std_1960_1979_min")	
predmax <- dcast(dat_ge,year~area,value.var="p_std_1960_1979_max")
synthesis <- cbind(pred,predmin[,c(2,3)],predmax[,c(2,3)])
colnames(synthesis) <- c("year","Elsewhere Europe","North Sea", "EEminCI","NSminCI","EEmaxCI","NSmaxCI")

#if (opt_calculation=="geomean") {
#	synthesis=as.data.frame(tapply(dat_ge[,"p_std_1960_1979"],
#					list(dat_ge[,"year_f"],dat_ge[,"area"]),
#					function(X) {Y=geomean(X) ;
#						return(as.numeric(Y))}))
#} else {
#	synthesis=as.data.frame(tapply(dat_ge[,"p_std_1960_1979"],
#					list(dat_ge[,"year_f"],dat_ge[,"area"]),mean,na.rm=TRUE))
#}
selection_summary$five_year_average <- synthesis %>% filter(year>CY-5) %>% dplyr::select(c(1,2,3)) %>% colMeans() %>% round(digits=3)
selection_summary$five_year_averagem3 <- synthesis %>% filter(year<=CY-2,year>CY-7) %>% dplyr::select(c(1,2,3)) %>% colMeans() %>% round(digits=3)

#xfive_year_avg_glass <- xtable(x = five_year_avg_glass,
#		label = "table_five_year_avg_glass",
#		caption = str_c("GLM estimates for glass eel series, averaged every five years"))
#print(xfive_year_avg_glass, 
#		file = str_c(tabwd,"/table_five_year_avg_glass.tex"),
#		table.placement = "htbp",
#		caption.placement = "top", 
#		NA.string = ".")




gg0 <- synthesis[,c("Elsewhere Europe","North Sea")]
colnames(gg0) <- c("EE","NS")
rownames(gg0) <- synthesis$year
gg <- split_per_decade_ge(gg0)
gg[,1:8] <- 100*round(gg[,1:8],2)
gg[,9:ncol(gg)] <- 100*round(gg[,9:ncol(gg)],3)
nothing <- latex(gg,
		rowlabel="",
		rowlabel.just="c",
		where="hptb",
		cgroup=cgroupdecade,
		n.cgroup=rep(ncol(gg0),length(cgroupdecade)),
		collabel.just=strsplit("c c c c c c c c c c c c c c c", " ")[[1]],	
		col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
		#landscape=TRUE,
		label="table_glm_glass_eel",
		caption=str_c("GLM $glass~eel \\sim year:area + site $ geometric means of predicted values for ",selection_summary$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period."),	
		file= str_c(tabwd,"/table_glm_glass_eel.tex"))



write.table(synthesis,file=str_c(outputdatawd,"glm_results_glass.csv"),sep=";")

#plot(log(synthesis[synthesis$year>1979,"Elsewhere Europe"]))
trend <- synthesis[synthesis$year>1979,]
trend$EE <- trend$"Elsewhere Europe"
trend$lEE <- log(trend$EE)

trend$lNS <- log(trend$"North Sea")


#round(lm(lEE~year,data=trend)$coefficient[2],4) # -0.098
#round(lm(lNS~year,data=trend)$coefficient[2],4) # -0.098 North Sea -0129

# sgipee test for change ee ---------------------------------------------

#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
#sgipee_test_for_change_ee <- summary(test1)$coefficients[3,4]
#if (sgipee_test_for_change_ee<=0.05) {
#  test_sgipee_char_ee <- "significant"
#}else {
#  test_sgipee_char_ee <- "not significant"
#}

## test on the trend after 2011 ee ----------------------------------------------
#
#K = matrix(c(0,1,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
#summary_coefficient_after <- summary(glht(test1, linfct = K, alternative="greater"))
#confint_coefficient_after  <- confint(glht(test1, linfct = K, alternative="greater"))
#trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)


# sgipee test for change ns ---------------------------------------------

#test=lm(lNS~year+pmax(year,2011),data=trend)
#
#sgipee_test_for_change_ns <- summary(test)$coefficients[3,4]
#if (sgipee_test_for_change_ns<=0.05) {
#  test_sgipee_char_ns <- "significant"
#}else {
#  test_sgipee_char_ns <- "not significant"
#}

## test on the trend after 2011 ns ----------------------------------------------
#
#
#summary_coefficient_after <- summary(glht(test, linfct = K, alternative="greater"))
#confint_coefficient_after  <- confint(glht(test, linfct = K, alternative="greater"))
#trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)


# test glm with a breakpoint ----------------------------------------------------
# this models takes numeric, not factors we assume a log trend
model_ge_area_b=glm(value_std~year:area+site+pmax(year,2011):area,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>=1980,],
		family=Gamma(link=log), maxit=300)
##summary(model_ge_area_b)
## plot(model_ge_area_b)
len <- length(coef(model_ge_area_b))
#gg <- visreg::visreg(model_ge_area_b,"year",by="area", plot=TRUE,gg=TRUE,band=FALSE)
#gg <- gg+facet_wrap(~area,scales="free_y")
#print(gg)
# last coeff are
# year:areaElsewhere Europe 
# year:areaNorth Sea 
# areaElsewhere Europe:pmax(year, 2011)   
# areaNorth Sea:pmax(year, 2011) 
#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
# this is the n-1 row of the summary
sgipee_test_for_change_ee <- summary(model_ge_area_b)$coefficients[len-1,4]   
sgipee_test_for_change_ns <- summary(model_ge_area_b)$coefficients[len,4]

Kee = matrix(c(rep(0,len-4),1,0,1,0), nrow = 1) # we just add the to coef trend to have the trend after 2011
# test if the coefficient alpha + beta > 0 so the slope of increase is larger than 0
# H0 alpha+beta = 0.5 / alternative alpha+beta >0
summary_coefficient_afteree <-  summary(glht(model_ge_area_b, linfct = Kee, alternative="greater",rhs=0)) 
# test if the coefficient alpha + beta > 0.05 so the slope of the increase is larger than the slope of decrease
# H0 alpha+beta = 0.5 / alternative alpha+beta >0.5
summary(glht(model_ge_area_b, linfct = Kee, alternative="less",rhs=0.05))
Kns = matrix(c(rep(0,len-4),0,1,0,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
summary_coefficient_afterns <- summary(glht(model_ge_area_b, linfct = Kns, alternative="greater"))
trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afteree$test$coefficients,
		summary_coefficient_afteree$test$pvalues)
trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afterns$test$coefficients,
		summary_coefficient_afterns$test$pvalues)


# back to long format, save for shiny

save(dat_ge, file=str_c(outputdatawd,"dat_ge.Rdata"))
save(dat_ge, file=str_c(outputdatawd,"dat_ge.Rdata"))
```

```{r segmented_regression, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
if(!require(segmented)) install.packages("segmented") ; require(segmented)


dat_ge1 <- expand.grid(year=1980:2025,area=as.factor(model_ge_area_b$xlevels$area),
		site=model_ge_area_b$xlevels$site[1])

dat_ge1$p <- predict(model_ge_area_b,newdata=dat_ge1)
dat_ge1$se <- predict(model_ge_area_b,newdata=dat_ge1,se.fit=TRUE)[["se.fit"]]

#mean_1960_1979 # this is the average p for all series before 1980
# it was generated in the previous chunk
dat_ge1 <- merge(dat_ge1, mean_1960_1979, by="area")

dat_ge1$p_std_1960_1979=exp((dat_ge1$p-dat_ge1$mean))
dat_ge1$p_std_1960_1979_min=exp(dat_ge1$p-dat_ge1$mean-1.96*dat_ge1$se)
dat_ge1$p_std_1960_1979_max=exp(dat_ge1$p-dat_ge1$mean+1.96*dat_ge1$se)






figure51 <-  
		ggplot(dat_ge,aes(x=year,y=p_std_1960_1979))+
		geom_line(aes(colour=area,lty=area),lwd=1.3)+
		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
		geom_line(data=dat_ge1, aes(x=year,y=p_std_1960_1979,colour=area))+
		#ggtitle("Recruitment overview glass eel series")+
		scale_colour_brewer(name="area",palette="Set1")  +
		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position=c(.8,.9))+geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)


ggplot(dat_ge1) 

datNS <- dat_ge %>%filter(area=="North Sea") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datNS)
o1<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011,2014)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o1)
datEE <- dat_ge %>%filter(area=="Elsewhere Europe") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datEE)
o2<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011,2014)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 500, display=TRUE))
plot(o2)

datNS <- dat_ge %>%filter(area=="North Sea") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datNS)
o11 <- segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o11)
datEE <- dat_ge %>%filter(area=="Elsewhere Europe") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datEE)
o21<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o21)
AIC(o1, o11, o2, o21)
```

```{r model_diagnostics, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#####deprecated
# summary(model_ge_area)
# influence_plot
require(boot)
gey <- glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959&!is.na(glass_eel_yoy$value_std),]
gey$E <- resid(model_ge_area) # working residuals
gey$P=predict(model_ge_area)
plot(coefficients(model_ge_area)[grep("North Sea",names(coefficients(model_ge_area)))],type="l")
points(log(datNS$p_std_1960_1979)+4,type="l",col="red")
plot(gey$E~gey$P)

# Three ways of getting the diagnostic graph of residuals
glm.diag.plots(model_ge_area)
plot(model_ge_area,which=1)
panel.smooth(gey$P,gey$E,col="black",col.smooth="red")
library(lattice)
panel.smoother <- function(x, y) {
	panel.xyplot(x, y) # show points 
	panel.loess(x, y,col.line="red")  # show smoothed line 
	panel.abline(h=0)
}
panel.smoother2 <- function(x, y) {
	panel.xyplot(x, y) # show points 
	panel.loess(x, y,col.line="red")  # show smoothed line 
	panel.abline(h=-0.2)
}
mga_diag <- glm.diag(model_ge_area)
gey$res <- mga_diag$res
show.settings()

xyplot(res~P, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
xyplot(res~year, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother2,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
abline(h=0)
xyplot(res~P|area, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
xyplot(res~P|site, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
# un rsidu / carte par annee


# pour aller chercher les stations en 3035
options(sqldf.RPostgreSQL.user = cred$user,  
			sqldf.RPostgreSQL.password = passwordwgeel,
			sqldf.RPostgreSQL.dbname = cred$dbname,
			sqldf.RPostgreSQL.host = cred$host, #getInformation("PostgreSQL host: if local ==> localhost"), 
			sqldf.RPostgreSQL.port = cred$port)
locxy_3035 <- sqldf("select ser_id,st_x(the_geom) as X, st_y(the_geom) as Y from ts.t_location_loc where loc_tyl_code='Recruit'")
gey <- merge(gey,locxy_3035,by="ser_id",all.x=TRUE,all.y=FALSE)
Gey <- gey #spatial data frame
coordinates(Gey) <- c("x","y")
# dev.size("px") to check right dimensions
#png(file=str_c(imgwd,"/resid_bretagne.png"), width=672,height= 389)

#bb <- elargit(bb,0.01,0.01)

#frequire(latticeExtra) # a + as.layer(b) pour mettre deux graphiques
# but for now I don't have missing data there
emu_c=readShapePoints(str_c(shpwd,"/","t_emuagreg_ema_point_3035.shp")) # a spatial object of class sp
# this corresponds to the center of each emu.
wisesp=readShapePoly(str_c(shpwd,"/","rbd_f1v3_3035.shp")) # a spatial object of class sp
# this is the map showing the "missing parts", to be placed behind the others
country_c=readShapePoints(str_c(shpwd,"/","t_country_coun_3035"))# a spatial object of class sp
# this is the map of coutry centers, to overlay points for each country
emusp0=readShapePoly(str_c(shpwd,"/","t_emuagreg_ema_3035")) # a spatial object of class sp
years <- 1960:2019
bb <- bbox(emusp0)
# loop to create all the graphs
for (year in years){
	#trellis.device(device="png",filename=str_c(imgwd,"/resids/",year,".png"))
	png(filename=str_c(imgwd,"/resids/",year,".png"),width=600, height=500)
	bb <- bubble(Gey[Gey@data$year==year,], "E",col=c("red","green"),main=str_c(year),
			xlab="",ylab="",
			do.sqrt = FALSE,
			sp.layout=list("sp.polygons", emusp0,    first = FALSE)
	) 		
	print(bb)
	dev.off()
}
# 
model_ge_area <- gls(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
		subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959 ,maxit=300)

lmer(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
		subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959)

#library(nlme)
glass_eel_yoy$lvalue_std=log(glass_eel_yoy$value_std)
M.lm <- gls(lvalue_std~site,data=glass_eel_yoy)

vf1Fixed <- 
		
		M.gls1  <- glmmPQL(value_std~year_f:area+site,
				data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
				random = ~ 1 | site,
				weights = varIdent (form = ~ 1 | site) ,
				family=Gamma(link=log)
		)
M.gls1  <- glmmPQL(value_std~year_f:area+site,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		random = ~ 1 | site,
		family=Gamma(link=log)
)
# prediction for lough neagh
# historical data
#glass_eel_yoy2=wger[wger$lifestage!="yellow eel" ,] #glass eel and yoy
#model_ge_area2=glm(value_std~year_f:area+site,data=glass_eel_yoy2[glass_eel_yoy2$value>0 ,],
#	family=Gamma(link=log), maxit=300)
#
#newdata <- expand.grid(year_f=levels(glass_eel_yoy2$year_f),site="Bann",area="Elsewhere Europe")
#newdata <- newdata[as.numeric(as.character(newdata$year_f))>1922,]
#newdata$P=predict(model_ge_area2,type="response",newdata=newdata)
#newdata$year <- as.numeric(as.character(newdata$year_f))
#
#plot(newdata$year,newdata$P, type="b",col="black",xlab="year",ylab="standardized value")
#gey2 <- glass_eel_yoy2[glass_eel_yoy2$site=='Bann',]
#gey2 <- gey2[order(gey2$year),]
#points(gey2$year,gey2$value_std, type="b",col="grey40",lty=2,pch=18)
#legend("topright",col=c("black","grey20"),lty=c(1,2),pch=c(1,18),legend=c("predicted for Bann","Bann (observed)"))
#write.table(gey2,file=str_c(datawd,"Bann_data.csv"),sep=";")
#write.table(newdata,file=str_c(datawd,"Bann_predictions.csv"),sep=";")
```

```{r model_for_yellow_eel, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~
######################################"
#~yellow eel migrant analysis
######################################"~
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~~

print("Analysis for yellow eel")
area_year_older=table(older$year,older$area)
selection_summary$nb_for_yellow_eel_glm <- length(unique(older$site))
table(older$geo)
print("stations selected for analysis")
unique(older$site)
model_older=glm(value_std ~ year_f + as.factor(site),
		data = older,
		family = Gamma(link=log),
		subset = older$value >0 &
				older$year > 1949 & older$year <=CY-1,
		maxit = 300)
# parteen was removed but is no longer among the series
summary(model_older)
#plot(model_older)
anova(model_older,test="F")


dat_ye=expand.grid(year_f=unique(model_older$xlevels$year_f),
		site=model_older$xlevels$`as.factor(site`[1])
dat_ye$year=as.numeric(as.character(dat_ye$year))

#predicting --------------------------------------------------------------------------------------------

# in the log scale
dat_ye$p=predict(model_older,newdata=dat_ye)
dat_ye$se=predict(model_older,newdata=dat_ye,se.fit = TRUE)$se.fit

#standardising prediction to 1960-1979 level -----------------------------------------------------------
# 2 options mean or geomean


#in the logscale we remove the arithmetic mean to standardise prediction relatively to
#1960-1980 
dat_ye$mean_1960_1979=mean(dat_ye[dat_ye$year>=1960&dat_ye$year<1980,"p"])
dat_ye$value_std_1960_1979=exp(dat_ye$p-dat_ye$mean_1960_1979)
dat_ye$yellow_eel_min=exp(dat_ye$p-dat_ye$mean-1.96*dat_ye$se)
dat_ye$yellow_eel_max=exp(dat_ye$p-dat_ye$mean+1.96*dat_ye$se)

# Table --------------------------------------------------------------------------------------------

yy0 <- dat_ye[,"value_std_1960_1979",drop = FALSE]
rownames(yy0) <- dat_ye$year

yy <- split_per_decade(data=yy0)
yy <- 100*round(yy,2)
nothing <- latex(yy,
		rowlabel="",
		rowlabel.just="c",
		where="hptb",
		col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
		landscape=FALSE,
		label="table_glm_yellow",
		caption=str_c("GLM $yellow~eel \\sim year + site $ geometric means of predicted values for ",selection_summary$nb_series_older, " yellow eel series, values given in percentage of the 1960-1979 period."),	
		file= str_c(tabwd,"/table_glm_yellow.tex"))

# Figures -------------------------------------------------------------------------------------------


dat_ye$time =as.Date(strptime(paste(dat_ye$year,"-01-01",sep=""),format="%Y-%m-%d"))
g <- ggplot(dat_ye,aes(x=time,y=value_std_1960_1979)) 
figure6_without_log_scale <- g+ geom_line(lwd=1, color="darkolivegreen")+ geom_point(color="khaki3")+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+	
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.6,fill="darkolivegreen2")+
		xlab("year")+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))#+
#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="grey20")
save_figure("figure6_without_log_scale",figure6_without_log_scale,600,480)


figure6_advice_YY<- ggplot(dat_ye,aes(x=time,y=value_std_1960_1979))  +
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=1,linetype=2)+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max, fill="area"), show.legend=FALSE, alpha = .3)+
		geom_line(lwd=1, aes(col="area"), show.legend=FALSE)+ 		
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme_ICES_plots("Recruitment") + ggtitle("Yellow")

figure6_advice_YY
save_figure("figure6_advice_YY",figure6_advice_YY,600,480, pdf = FALSE)



figure6_without_log_scale
figure6_without_log_scale_black <- g+geom_line(lwd=1,color="white")+ 
		geom_point(color="white")+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.3,fill="darkolivegreen2")+
		#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="turquoise1") +
		theme_black()
figure6_without_log_scale_black
save_figure("figure6_without_log_scale_black",figure6_without_log_scale_black,600,480)
figure6 <- g+geom_line(lwd=1,color="darkolivegreen")+geom_point(color="khaki3")+
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' (log scale)'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%")) +
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.3,fill="darkolivegreen2")+
		xlab("year")+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))
#stat_smooth(method="lm",formula=y ~ ns(x,4), lty=2, size=0.8,alpha=0.3,col="grey20")
figure6
save_figure("figure6",figure6,600,480)

# Final save ----------------------------------------------------------------------------------------

write.table(synthesis,file=str_c(outputdatawd,"glm_results_yellow.csv"),sep=";")
dat_ye <- dat_ye[,c("year","p","se","mean_1960_1979","yellow_eel_min","yellow_eel_max","value_std_1960_1979")]
selection_summary$five_year_averagey <- dat_ye %>% filter(year>CY-5) %>% dplyr::select(c(year,value_std_1960_1979)) %>% colMeans() %>% round(digits=3)
selection_summary$dat_ye <- 
		dat_ye %>% 
		filter(year<=CY-2,year>CY-7) %>% 
		dplyr::select(c(year,value_std_1960_1979)) %>% 
		colMeans() %>% 
		round(digits=3)


#colnames(dat_ye)  <- c("year","geomean_p_std_1960_1979") 
save(dat_ye,file=paste0(outputdatawd,"dat_ye.Rdata")) 
save(dat_ye,file=paste0(shinywd,"dat_ye.Rdata")) 

if (file.exists(str_c(outputdatawd,"glm_results_glass_and_yellow.xlsx"))) unlink(str_c(outputdatawd,"glm_results_glass_and_yellow.xlsx"))
openxlsx::write.xlsx(x=list("Glass eel"=data.frame(
						"year"=synthesis$year,
						"EE_minCI_percent"=100*synthesis$EEminCI,
						"EE_percent"=100*synthesis$"Elsewhere Europe",
						"EE_maxCI_percent"=100*synthesis$EEmaxCI,
						"NS_minCI_percent"=100*synthesis$NSminCI,
						"NS_percent"=100*synthesis$"North Sea",
						"NS_maxCI_percent"=100*synthesis$NSmaxCI
				), "Yellow eel"= data.frame("year"=dat_ye$year,
						"Y_minCI_percent"=100*dat_ye$yellow_eel_min,
						"Y_percent"=100*dat_ye$value_std_1960_1979,
						"Y_maxCI_percent"=100*dat_ye$yellow_eel_max)),
		file=str_c(outputdatawd,"glm_results_glass_and_yellow.xlsx"),
		row.names=FALSE)


# saving yellow_eel_pred for shiny ---------------------------------------------------------------------
yellow_eel_pred <- dat_ye

save(yellow_eel_pred,file=paste0(outputdatawd,"yellow_eel_pred.Rdata"))
save(yellow_eel_pred,file=paste0(shinywd,"yellow_eel_pred.Rdata"))
```


```{r test_period, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


glass_eel_yoy$site <- as.factor(glass_eel_yoy$site)
# we select all series that are already included (removed -1)

load(file=str_c(shinywd,"inclusion.Rdata"))
# todo redo this too tired now
inner_join(glass_eel_yoy, 
				inclusion %>% filter(sgl_year!=-1), 
				by=(c("ser_id"="sgl_ser_id"))) %>%
		dplyr::select(sgl_year,area,site)%>%
		distinct() %>%
		mutate(number=1)%>%
		dplyr::select(-site)%>% 
		group_by(sgl_year,area)%>%
		mutate(number=sum(number))
#unique(glass_eel_yoy$ser_id)[!unique(glass_eel_yoy$ser_id)%in%inclusion$sgl_ser_id  ]
run_exclude_before <- function(the_year){
	load(file=str_c(outputdatawd,"dat_ge.Rdata"))
	dat_ge_reference <- dat_ge
	glass_eel_yoy_included <- inner_join(glass_eel_yoy, 
			inclusion %>% filter(sgl_year!=-1), 
			by=(c("ser_id"="sgl_ser_id"))) 
	if (!all(unique(glass_eel_yoy$ser_id)%in% unique(glass_eel_yoy_included$ser_id ))){
		warning("ser_id ",unique(glass_eel_yoy$ser_id)[!unique(glass_eel_yoy$ser_id)%in% 
								unique(glass_eel_yoy_included$ser_id )]," not in inclusion")
	}
	glass_eel_yoy_included <- glass_eel_yoy_included	%>% 
			dplyr::filter(sgl_year <= the_year)
	model_ge_area <- glm(value_std~year_f:area+site,
			data=glass_eel_yoy_included[glass_eel_yoy_included$value>0 & glass_eel_yoy_included$year>1959,],
			family=Gamma(link=log), maxit=300)
	dat_ge <- expand.grid(year_f=model_ge_area$xlevels$year_f,area=model_ge_area$xlevels$area,
			site=model_ge_area$xlevels$site[1])
	dat_ge$year <- as.numeric(as.character(dat_ge$year_f))
	dat_ge$p <- predict(model_ge_area, newdata=dat_ge)
	dat_ge$se <- predict(model_ge_area,newdata=dat_ge,se.fit=TRUE)[["se.fit"]]
	mean_1960_1979 <- aggregate(dat_ge[dat_ge$year<1980,"p"], 
			list(dat_ge[dat_ge$year<1980,"area"]),
			mean)
	names(mean_1960_1979) <- c("area","mean")	
	dat_ge <- merge(dat_ge,mean_1960_1979,by="area")
	dat_ge$p_std_1960_1979 <- exp(dat_ge$p-dat_ge$mean)
	dat_ge$p_std_1960_1979_min <- exp(dat_ge$p-dat_ge$mean-1.96*dat_ge$se)
	dat_ge$p_std_1960_1979_max <- exp(dat_ge$p-dat_ge$mean+1.96*dat_ge$se)
	result <- list()
	result$year <- the_year
	result$nbsite <- length(model_ge_area$xlevels$site)
	result$dat_ge <- dat_ge
	result$delta <- dat_ge_reference$p_std_1960_1979 - dat_ge$p_std_1960_1979
	return(result)
}
res <- mapply(run_exclude_before, the_year=c(2010:2020), SIMPLIFY=FALSE)
require(tidyr)

delta <- lapply(res,function(X)X[["delta"]])
delta <- as.data.frame(delta)
colnames(delta)<-2010:2020
delta$year <- dat_ge$year
delta$area <- dat_ge$area
res_delta <-delta %>% pivot_longer(cols=contains("2"), names_to="year_included",values_to="delta")


g<- ggplot(res_delta)+
		geom_line(aes(x=year,y=delta,color=year_included))+
		facet_wrap( ~area) +
		theme_bw()
figure_inclusion_1<- g
save_figure("figure_inclusion_1",figure_inclusion_1,600,480)


pred <- lapply(res,function(X)X[["dat_ge"]]$"p_std_1960_1979")
pred <- as.data.frame(pred)
colnames(pred)<-2010:2020
pred$year <- dat_ge$year
pred$area <- dat_ge$area
res_pred <-pred %>% pivot_longer(cols=contains("2"), names_to="year_included",values_to="pred")
matplot(pred,ylim=c(0,0.2))
g<-ggplot(res_pred)+geom_line(aes(x=year,y=pred,color=year_included))+ 
		facet_wrap( ~area) +
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()
figure_inclusion_2 <- g
save_figure("figure_inclusion_2",figure_inclusion_2,600,480)
```

```{r diagramme,echo=FALSE,eval=TRUE,results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
if(!require(DiagrammeR)) install.packages("DiagrammeR") ; require(DiagrammeR)
if(!require(magrittr)) install.packages("magrittr") ; require(magrittr)
if(!require(DiagrammeRsvg)) install.packages("DiagrammeRsvg") ; require(DiagrammeRsvg)
if(!require(rsvg)) install.packages("rsvg") ; require(rsvg)

node_list <- create_node_df(n=16,		
		type=rep(c("box",
						"value"), 16
		),
		label=c(
				str_c("Series available in ", CY),
				selection_summary$nb_series_init,
				"used",
				selection_summary$nb_series_final,
				"G + GY",
				selection_summary$nb_series_glass_eel,
				"Y",
				selection_summary$nb_series_older,
				"NS",
				as.numeric(selection_summary$nb_series_glass_eel_per_area[selection_summary$nb_series_glass_eel_per_area$area=="Elsewhere Europe",2]),
				"EE",
				as.numeric(selection_summary$nb_series_glass_eel_per_area[selection_summary$nb_series_glass_eel_per_area$area=="North Sea",2]),
				"< 10 Y",
				as.numeric(selection_summary$ser_qal_id_count[selection_summary$ser_qal_id_count$ser_qal_id==0,"len"]),
				"discarded",
				as.numeric(selection_summary$ser_qal_id_count[selection_summary$ser_qal_id_count$ser_qal_id==3,"len"])
                
		),
		color=c(rep("green",12),"orange","orange","red","red"),
		style="filled",
		shape=rep(c("plaintext","circle"),8),
		value=1:16,
		fixedsize =FALSE
)

edge_list<-create_edge_df(
		from=c(1,2,3,4,5,4,7,2 ,2 ,13,15,6,6,11,9),
		to=  c(2,3,4,5,6,7,8,13,15,14,16,9,11,12,10),
		rel="a",
		label=rep(" ",15),
		color=rep("grey",15),
		length=100)



igraph1 <- create_graph( attr_theme = NULL)

igraph2 <- igraph1%>%
		add_nodes_from_table(table = node_list, 
				type_col=type,
				label_col=label) 
#igraph2 %>% get_node_df()
# Add the edges to the graph
igraph3 <-igraph2 %>%
		add_edges_from_table(
				table = edge_list,
				from_col = from,
				to_col = to,
				from_to_map = id_external
		)


render_graph(igraph3, layout="tree")


render_graph(igraph3, layout="tree") %>% 
    export_svg %>%  charToRaw %>% rsvg_png(str_c(imgwd,"series_selection.png"))


```



# Recruitment

## Data sources

In this section, the latest trends in glass and yellow eel recruitment are
addressed. The time-series data are derived from fishery-dependent sources (i.e.
catch records) and also from fishery-independent surveys across much of the
geographic range of European eel. The stages are categorized as : 

 * glass eel (G), continental age 0 years, 
 * a mixture of glass eel and  yellow eel dominated by recruits from the same
   year (GY),
 * and yellow eel (Y) recruiting to continental habitats. 
 
The yellow  eel series might consist of yellow eel of several ages. This is
   certainly the case for all series from the Baltic (mean age up to 6), some
   Irish sites, and sites located far upstream. The glass eel recruitment
   time-series have been grouped into two geographical areas: "continental North
   Sea" (NS) and "Elsewhere Europe" (EE) (Figure \@ref(fig:figure1)). Previous
   analyses by the working group (ICES, 2010, p19, Bornarel et al. (2017) have
   shown a different trend between the two sets. This is mostly due to a more
   pronounced decline of the North Sea series compared to the Elsewhere Europe
   area during the 1980s. 

The WGEEL has collated information
on recruitment from `r selection_summary[["nb_series_init"]]` time-series.
Some time-series date back to the beginning of 20th century (yellow eel, Gta
lv, Sweden) or 1920 (glass eel, Loire, France). Among those series
`r selection_summary[["nb_series_final"]]` have been selected to calculate the
WGEEL recruitment indices; see details on data selection and processing below. 

```{r figure1, fig.cap="Map of recruitment sampling stations, left (white = Glass eel (G); grey = Glass + Yellow eel (GY), right Yellow eel (Y)).", fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure1.png"))
knitr::include_graphics(paste0(imgwd,"singlemap.png"))
```

##	Details on data selection and processing 

Out of the `r selection_summary[["nb_series_init"]]` series  that were  compiled
in the Data Call`r selection_summary[["nb_series_final"]]` meet  the required
conditions to be used in the analysis to calculate the recruitment indexes ( 
see tables \@ref(tab:xstatseriesGEE) - glass eel (G) stage for the Elsewhere
Europe area, \@ref(tab:xstatseriesGNS) - glass eel (G) North Sea,
\@ref(tab:xstatseriesGY) - glass and yellow combined (GY) and
\@ref(tab:xstatseriesY)
- yellow eel stage  for the full description of the series compiled in the data
call)

1. First, if there are two or more series from the same location, i.e. they are
      not independent, only one series is kept. For instance, the longer of two
   series has been kept for the Severn (Severn EA, a total of all the glass eel
   fisheries for England and Wales) while the second series (Severn HMRC) has
   been dropped from the list, as it was considered a duplicate being based on
   the same fishery. The series left out following this rule are :
   `r selection_summary$sites_summary$qal_3`
   [TODO SELECT AMONG THOSE with qal_id 3 THE DUPLICATES, you may need to read ser_qal_comment
   for more information currently  BroGY(GB), EmsBGY(DE), FarpGY(DE), FlaGY(GB), SeHMG(GB)]
   
2. The second rule is to exclude a series from the analysis when it is less than
   ten years long. The series are, however, still updated in the database until
   they are long enough to be included. If there are missing years, or years
   excluded for data quality reasons, the data series will be included when the
   total number of "good" years of data meets the 10 year criterion. Within any
   series, individual annual data point or points can be excluded from the
   analysis where a one-off problem is identified which negates the value as an
   index for that year, such as a major reduction in effort (e.g. Covid or other
   effort related restriction). The series left out because they don't meet the
   10 years criteria are : `r selection_summary$sites_summary$qal_0` 
   
3. Finally, it was decided to discard recruitment series that were obviously
   biased by restocking (e.g. Farpener Bach in Germany). The series left out
   for that reason are `r selection_summary$sites_summary$qal_3` [ TODO among those
   with qal_id 3 select  HHKGY(DE), MeusY(BE)]


***************************************************************

[There should be nothing here :
`r selection_summary$sites_summary$qal_4`  
If the name of a series is apparent in the previous line, 
check series with ser_qal_id 4 and remove them, otherwise
remove sections between horizontal lines 

*******************************************************************

See Annex XXXXX, tables
\@ref(tab:xstatseriesGEE), \@ref(tab:xstatseriesGNS), \@ref(tab:xstatseriesGY), 
\@ref(tab:xstatseriesY) for  the reason for which the series have
been excluded for the recruitment analysis.


## Number of series available

****************************************************************************
[Read this if you want some stats related to the graph on the number of series i.e.
How many points in the last year -- then delete part between horizontal bars] 

Glass eel and glass eel + young yellow eel time-series available maximum :

`r selection_summary[["nbmaxglasseel"]]` in `r max(as.numeric(selection_summary[["yearmaxglasseel"]]))`
`r selection_summary[["nbcurrentglasseel"]]` in `r CY`.

 The maximum number of older yellow eel :
 
time-series has increased to `r selection_summary[["nbmaxyellow"]]` in
`r max(as.numeric(selection_summary[["yearmaxyellow"]]))` but dropped to
`r selection_summary[["nbcurrentyellow"]]` (Figure \@ref(fig:figure2)).

****************************************************************************

The WGEEL has collated information on recruitment from
`r selection_summary[["nb_series_init"]]` time-series (Tables
\@ref(tab:xstatseriesGEE), \@ref(tab:xstatseriesGNS), \@ref(tab:xstatseriesGY), 
\@ref(tab:xstatseriesY), Figure \@ref(fig:figure2)). Among those series, 
`r selection_summary[["nb_series_final"]]` have been selected for further analysis. 
For the calculation of the glass eel recruitment index, 
`r selection_summary[["nb_series_glass_eel"]]` series have been retained,
`r   selection_summary$nb_series_glass_eel_G` glass eel series and 
`r   selection_summary$nb_series_glass_eel_GY` glass and yellow eel mixed series), from which
`r selection_summary$nb_series_glass_eel_per_area%>% filter(area=='North Sea') %>% pull(2)` came
from NS and
`r selection_summary$nb_series_glass_eel_per_area%>% filter(area=='Elsewhere Europe') %>% pull(2)` 
from EE (see Annex X table 1). For the calculation of the yellow eel
recruitment index, 
`r selection_summary$nb_series_older`
 yellow eel series have been retained, 
`r  selection_summary$nb_series_older_northsea` coming from the North Sea,
`r  selection_summary$nb_series_older_baltic` from the Baltic Sea,
`r  selection_summary$nb_series_older_atlantic` from the Atlantic region and
`r  selection_summary$nb_series_older_mediterranean` from the Mediterranean Sea
(Figure \@ref(fig:figure2b)). 

```{r figure2, fig.cap="Trends in number of glass eel (black circle), glass+young yellow eel (grey triangle) and older yellow eel (black triangle) time-series giving a report in  any specific year.", fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure2.png"))
```

```{r figure2b, fig.cap="Series selection and analysis. Series less than 10 years are not used in the analysis. Y yellow eel series, G + GY glass and young yellow eel series. NS North Sea, EE Elsewhere Europe", fig.width=16/254, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
if (file.exists(paste0(imgwd,"series_no_area.png")))
  knitr::include_graphics(paste0(imgwd,"series_no_area.png"))
```


 `r format(selection_summary[["nCY"]], scientific = TRUE)` time-series were
updated to `r CY` (`r format(selection_summary[["nCYG"]], scientific = TRUE)` for
glass eel, `r format(selection_summary[["nCYGY"]], scientific = TRUE)` for glass
+ yellow eel and `r format(selection_summary[["nCYY"]], scientific=TRUE)` for
  yellow eel) and `r format(selection_summary[["nCYm1Y"]], scientific = TRUE)` 
 and  `r format(selection_summary[["nCYm1"]],scientific=TRUE)` 
 series (`r format(selection_summary[["nCYm1G"]],scientific=TRUE)` G, `r format(selection_summary[["nCYm1GY"]],scientific=TRUE)`
GY, and `r format(selection_summary[["nCYm1Y"]], scientific=TRUE)`) were
updated only to `r CY-1`.


In `r CY`, [XX DO THIS MANUALLY] new series were added to the recruitment trend
analysis: [XX] GE ([XXX]) and [XX] GY ([XXX]).

Among the time-series based on trap indices, some have reported preliminary data for 2023 as 
their trapping season had not finished. As usual, the indices given for 2023 must be considered as provisional, 
especially those for the yellow eel.


`r format(selection_summary[["nseries_lost"]], scientific=TRUE)` time-series have been stopped
or not updated beyond `r CY-2` 

[remove these details] 
(`r format(selection_summary[["nseries_lostG"]], scientific=TRUE)`
for glass eel,  `r format(selection_summary[["nseries_lostGY"]], scientific =TRUE)` for glass
eel + yellow eel and `r format(selection_summary[["nseries_lostY"]], scientific=TRUE)` for
yellow eel (Table \@ref(tab:xserieslost))) but are still included in the
analysis 
[end remove these details].

 Some have stopped reporting either because
of a lack of recruits in the case of the fishery-based surveys (Ems in Germany,
stopped in 2001; Vidaa in Denmark, stopped in 1990), a lack of financial support
(the Tiber in Italy, 2006) or the introduction of quota from 2008 to 2011 that
has disrupted the five fishery-based French time-series.


The number of time series available between regions and life stages is not an
even distribu-tion, influenced by factors including variation in the behaviour
of eel, traditions of fishery and usage of eel, and the history of scientific
investigation and eel management (Figure \@ref(fig:figure3) &
\@ref(fig:figure4)). Thus, most of the glass eel series come from the Atlantic
while the yellow eel series come from the Baltic and the North Sea. 
 
***************************************************************************** 

[remove this section - raw data scaling and maps no longer provided]
This figure is given as it   consistent with the trend provided by WGEEL
from 2002 to 2006. The scaling is   performed on the 1979-1994 average of each
time-series, and `r length(selection_summary[["sc_1979_1994_unused_series"]])`
time-series without data during that   period are excluded from the analysis.
The time-series left out are :
`r paste(selection_summary[["sc_1979_1994_unused_series"]],collapse=", ")`

***********************************************************************************

```{r diagramme selection, fig.cap="Schematic showing the recruitment series received by type and region, and numbers selected for analysis. Y= Yellow eel, G= Glass eel, GY= mixed glass and yellow eels. NS= North-Sea, EE= Elsewhere Europe", fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"series_selection.png"))
```

## GLM based trend

The WGEEL recruitment index used in the ICES Annual Stock Advice is fitted using
a GLM with a Gamma distribution and a log
link: $glass eel \sim year:area + site$, where :

 * $glass eel$ is individual glass eel time-series including both pure G
   series and those identified as a mixture of glass and yellow eel (G+Y),
 * $site$ is the site monitored for recruitment, 
 * $area$ is either the continental North Sea or Elsewhere Europe, and
 * $year$ is the year coded as a categorical value. 
 For yellow eel time-series, only one estimate is
provided: $yellow~eel \sim year + site$. 

The trend is hindcast using the predictions from 1960 onwards for
`r selection_summary$modelge$nbsite` glass eel time-series and from 1950 onwards for
`r selection_summary$modelolder$nbsite` yellow eel time-series. Some zero values have been
excluded from the GLM analysis: `r nrow(selection_summary$modelge$value_excluded_zero)` for the
glass eel model and `r nrow(selection_summary$modelolder$value_excluded_zero)` for the yellow
eel model. . This treatment has been tested and has no effect on the trend
(ICES, 2017).

The reconstructed values are then aggregated using geometric means of the two
refer-ence areas (Elsewhere Europe EE, and North Sea NS). The predictions are
given in reference to the geometric mean of the 1960-1979 period. 


As for previous working groups, data call and meeting timing means that some
data se-ries on glass and yellow eel recruitment are not complete for this year
at the date of submis-sion to WGEEL. Therefore, each year the recruitment index
is updated when the complete data from the previous year is available. 
Thus, in the case of the glass eel series, the recruitment of `r CY-1`
has been recalculated from [PASTE VALUE FROM PREVIOUS REPORT HERE] to
`r round(100*synthesis[nrow(synthesis)-1,"Elsewhere Europe"], digits= 1)`% in the Elsewhere Europe series
(Figure \@ref(fig:figure5), Table \@ref(tab:tableglmglasseel)). For the North
Sea, recruitment for `r CY-1` has been recalculated from
[PASTE VALUE FROM PREVIOUS REPORT HERE] to
`r round(100*synthesis[nrow(synthesis)-1,"North Sea"], digits =1)`%.  

Analyses of provisional `r CY` data show recruitment as a percentage of
1960-1979 levels at `r round(100*synthesis[nrow(synthesis),"North Sea"], digits =1)` % in the North Sea~~, reaching its historical minimum,~~ and
`r round(100*synthesis[nrow(synthesis),"Elsewhere Europe"], digits =1)` % in elsewhere Europe (Figure \@ref(fig:figure5), Table \@ref(tab:tableglmglasseel)). Data are **only
provisional** and give estimates at  
  `r round(100*synthesis[nrow(synthesis),"North Sea"], digits =1)`% in the
North Sea and
`r round(100*synthesis[nrow(synthesis),"Elsewhere Europe"], digits= 1)`% in
Elsewhere Europe (Figure
\@ref(fig:figure5) \@ref(fig:figure5withlogscale), Tables
\@ref(tab:tableglmglasseel)).

```{r tableglmglasseel,echo=FALSE,eval=TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,tab.cap=str_c("GLM 'glass eel ~ year:area + site'  geometric means of predicted values for ",selection_summary$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period.")}
columns = names(gg)
years = rep(196:202,each=2)*10
autofit(flextable(gg%>% setNames(1:ncol(gg)) %>%
  tibble::rownames_to_column(" ")) %>%
  delete_part(part = "header") %>%
  add_header_row(values=c("",years),top=FALSE) %>%
  merge_h(part="header") %>%
  add_header_row(values=c("",columns),top=FALSE) %>%
  bold(bold = TRUE, part = "header") %>%
  theme_booktabs(x, bold_header = FALSE))
```



```{r figure5, fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.cap=paste("WGEEL recruitment index: estimated (GLM) glass eel recruitment for the continental North Sea and Elsewhere Europe series with 95% confidence intervals updated to", CY,". The GLM ($glass eel \\sim area:year+site$)  was  fitted  on", selection_summary$modelge$nbsite,"time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. The predictions $p$ have been scaled to the 1960-1979 average $\\bar{p}_{1960-1979}$. Number of series",pull(selection_summary$nb_series_glass_eel_per_area[1,1]), "=\\n", pull(selection_summary$nb_series_glass_eel_per_area[1,2]), "\\n", pull(selection_summary$nb_series_glass_eel_per_area[2,1]),"\\n", pull(selection_summary$nb_series_glass_eel_per_area[2,2]))}
#fig.cap=paste("WGEEL recruitment index: estimated (GLM) glass eel recruitment for the continental North Sea and Elsewhere Europe series with 95% confidence intervals updated to", CY,". The GLM ($glass eel \sim area:year+site$)  was  fitted  on", selection_summary$modelge$nbsite,"time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. The predictions $p$ have been scaled to the 1960-1979 average $\bar{p}_{1960-1979}$. Number of series",pull(selection_summary$nb_series_glass_eel_per_area[1,1]), "=\n", pull(selection_summary$nb_series_glass_eel_per_area[1,2]),"\n",pull(selection_summary$nb_series_glass_eel_per_area[2,1]),"\n",pull(selection_summary$nb_series_glass_eel_per_area[2,2]))
knitr::include_graphics(paste0(imgwd,"figure5_without_logscale_ribbon.png"))
```

For yellow eel series, the autumn ascent has not been recorded yet and most of
the series have reported data till the middle of the summer. The `r CY-1` yellow
eel index is at
`r round(100*dat_ye[dat_ye$year==CY-1,"value_std_1960_1979"], digits=1)`% of the
1960-1979 baseline (Figure \@ref(fig:figure6),
Tables \@ref(tab:tableglmyellow)). 

```{r tableglmyellow,echo=FALSE,eval=TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,tab.cap=str_c("GLM $glass~eel \\sim year:area + site $ geometric means of predicted values for ",selection_summary$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period.")}
autofit(flextable(yy)%>%
          bold(bold = TRUE, part = "header"))
```

```{r figure6, fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,fig.cap=paste("Geometric mean of estimated (GLM) yellow eel recruitment for Europe updated to",CY,". The GLM (yellow eel ~ year+site) was fitted to",selection_summary[["nb_for_yellow_eel_glm"]],"yellow eel time-series $p$ and scaled to the 1960-1979 average $\\bar{p}_{1960-1979}$.")}
#fig.cap=paste("Geometric mean of estimated (GLM) yellow eel recruitment for Europe updated to",CY,". The GLM ($yellow eel \sim year+site$) was fitted to",selection_summary[["nb_for_yellow_eel_glm"]],"yellow eel time-series $p$ and scaled to the 1960-1979 average $\bar{p}_{1960-1979}$.")
knitr::include_graphics(paste0(imgwd,"figure6_without_log_scale.png"))
```

## Conclusion

The status of European eel remains critical. Indices of both glass and yellow
eel recruitment strongly declined from 1980 to 2011. Index values correspond to
the recruitment as a per-centage of the 19601979 geometric mean. Glass eel
recruitment in the North Sea index area was
`r round(100*synthesis[nrow(synthesis),"North Sea"], digits =1)`% in `r CY`
(provisional) and
`r round(100*synthesis[nrow(synthesis)-1,"North Sea"], digits =1)`%  in `r CY-1`
(final). In the Elsewhere Europe index series it was
`r round(100*synthesis[nrow(synthesis),"Elsewhere Europe"], digits =1)`% in
`r CY` (provisional) and
`r round(100*synthesis[nrow(synthesis)-1,"Elsewhere Europe"], digits= 1)`% in
`r CY-1` (final). The yellow eel recruitment index for `r CY-1` was 
`r round(100*dat_ye[dat_ye$year==CY-1,"value_std_1960_1979"], digits=1)`%
(final) of the 19601979 geometric mean. Time-series from 1980 to `r CY` show
that glass eel recruitment remains at a very low level. 

***************************************************************************

## Test for change (remove)


After high levels in the late 1970s, the recruitment declined and has been very
low for all years after 2000. From ICES (2014) onward a change in the
recruitment has been detected. One of the test used to show that change in 2014
was based on SGIPEE(2011) working group. We have used a test only slighly
different from the test used in ICES 2011. The difference is that the model is
now based on individual series as source data, not only the prediction. The
model differs from that used by wgeel also as year is here treated as a
continuous value, whereas it is treated as a factor in the glm for recruitment,
and the years are restricted to decreasing part of the recruitment (after 1980).
\begin{equation} glass~eel \sim  \alpha_{site} site + \beta_{area} Y_{>=1980} +
\gamma_{area} Y_{>2011} + \epsilon, \end{equation} where glass eel is the number
of glass eel in the glass eel series, either for the Elsewhere Europe or the
North Sea time series,  $year_{year>1980}$ is a continuous value corresponding
to year after 1980, $year_{year>2011}$ is also a continuous value, $\epsilon$ is
a random error with mean 0 and standard deviation sigma, and $\alpha_{site}$,
$\beta_{area}$ and $\gamma_{area}$ are the estimated parameters. The parameters
$\gamma_{area}$ are higly significant both in the Elsewhere Europe area
(p=`r round(sgipee_test_for_change_ee,digits=1)` and for the North Sea
p=`r round(sgipee_test_for_change_ns,digits=1)` North Sea. This result confirms
that there has been a change in the recruitment slope.

\textcolor{purple}{Add a table with past coeff, current coeff, and probabilities
and diminish the text}

To test whether there is an increase in recruitment since 2011 the slope of
$\beta_{area}+\gamma_{area}$, i.e. the slope of the recent increase in
recruitment is positive, the NULL hypothesis $H0:b>0$ is tested.

****************************************************************


# Annex

## Additional figures

We provide the same figures as in the main text but Figure
\@ref(fig:figure3withoutlogscale) without log scale for Figure
\@ref(fig:figure3). For the prediction, figures with log scales are provided
(Figures \@ref(fig:figure5withlogscale) and \@ref(fig:figure6withlogscale)).

```{r figure3withoutlogscale, fig.cap="Same as figure \\@ref(fig:figure3) but without log scale", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure3withoutlogscale.png"))
```

```{r figure5withlogscale, fig.cap="Same as figure \\@ref(fig:figure5) but with a log scale.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure5_ribbon.png"))
```

```{r figure6withlogscale, fig.cap="Same graph as figure \\@ref(fig:figure6) but with a log scale.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure6.png"))
```

## Additional figures [remove these even from annex]

```{r figure3, fig.cap=paste("Time-series of glass eel and yellow eel recruitment in European rivers with time-series having data for the 1979-1994 period (", selection_summary[["sc_1979_1994_nb"]], "sites). Each time-series has been scaled to its 1979-1994 average. Note the logarithmic scale on the y-axis. The mean values and their bootstrap confidence interval (95%) are represented as black dots and bars. Geometric means are presented in red."), fig.width=16/2.54, warning = FALSE, message = FALSE, echo=FALSE, error=FALSE}
knitr::include_graphics(paste0(imgwd,'figure3.png'))
```


```{r figure4, fig.cap=paste("Time-series of glass eel and yellow eel recruitment in Europe with",selection_summary[["sc_1979_1994_nb"]],"time-series out of the", selection_summary[["nb_series_init"]],"available to the working group. Each time-series has been scaled to its 1979-1994 average. The mean values of combined yellow and glass eel time-series and their bootstrap confidence interval (95%) are represented as black dots and bars. The brown line represents the mean value for yellow eel, the blue line represents the mean value for glass eel time-series. The range of  these  time-series  is  indicated  by  a  grey  shade.  Note that individual time-series  from  Figure \\@ref(fig:figure3)  were  removed to make the mean value more clear.  Note also the logarithmic scale on the y-axis."), fig.width=16/2.54, warning = FALSE, echo=FALSE, message = FALSE, error=FALSE}
knitr::include_graphics(paste0(imgwd,'figure4.png'))
```

## Additional Tables

### Series statistics

```{r xstatseriesGEE, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Short description of the sampling sites for European eel recruitment data for Elsewhere Europe. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses.")}
autofit(flextable(data = printstatseriesGEE)%>%
          bold(bold = TRUE, part = "header"))
```


```{r xstatseriesGNS, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,tab.cap=str_c("Short description of the sampling sites for European eel recruitment data in the North Sea. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses.")}
	autofit(flextable(data = printstatseriesGNS)%>%
          bold(bold = TRUE, part = "header"))
```

```{r xstatseriesGY, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, tab.cap=str_c("Short description of the recruitment sites (continued : stage glass eel and yellow eel)")}
autofit(flextable(data = printstatseriesGY) %>%
          bold(bold = TRUE, part = "header"))
```


```{r xstatseriesY, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, tab.cap= str_c("Short description of the recruitment sites (continued : yellow eel series) ")}
autofit(flextable(data = printstatseriesY)%>%
          bold(bold = TRUE, part = "header"))
```

### Missing values at annual level

```{r xseriesprob, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,echo=FALSE, tab.cap=str_c("Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality, 2 = wgeel has modified the data, 3 = not used due to poor quality, 4 = data is used, but there are warnings on its quality")}
autofit(flextable(data = series_prob[1:15,])%>%
          bold(bold = TRUE, part = "header"))
```


```{r xseriesprob1, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Table continued. Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality, 2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality")}
autofit(flextable(data = series_prob[15:30,])%>%
          bold(bold = TRUE, part = "header"))
```


```{r xseriesprob2, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Table XXX continued. Data in " ,CY, " and ", CY-1, "having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality, 2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality")}
autofit(flextable(data = series_prob[30:nrow(series_prob),])%>%
          bold(bold = TRUE, part = "header"))
```

### Series last report year

```{r tableseriesCY,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE, tab.cap=str_c("Series updated to ",CY, ". Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Area NS = North Sea, EE = Elsewhere Europe, Division = FAO marine division. Series ordered by stage and from North to South")}
autofit(flextable(data = series_CY)%>%
          bold(bold = TRUE, part = "header"))
```

```{r xseriesCYm1, echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,tab.cap=str_c("Series updated to ",CY-1, " see table XXX for codes. Series ordered from North to South")}
autofit(flextable(data = series_CYm1)%>%
          bold(bold = TRUE, part = "header"))
```

```{r xserieslost,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,tab.cap=str_c("table_serieslost")}
autofit(flextable(data = series_lost %>%
                    setNames(str_match(names(.), "^\\\\scshape\\{(.*?)\\}$")[,2]))%>%
          bold(bold = TRUE, part = "header"))
```

## Exploitation Rates

By dividing glass eel declared landing by the time series of abundance, we an derive a relative indicator of glass eel mortality exploitation rate that can inform on trends in glass eel fishing mortality. The analysis is restricted to Elsewhere Europe since no commercial fisheries took place in the North Sea area in the last years. Moreover, we restricted the analysis to the post 2000 period since recent ICES data calls have focused on those decades. While some landings data are still missing, the diagram suggests that the exploitation rate for glass has decreased after the implementation of the Eel Regulation in 2009 (Year 2009 was removed since French, which accounts for a significant part of the landings, have not reported data for this year) and reached its lowest level from 2014 to 2017. The exploitation rate has remained at this level since then despite an increase from 2017 to 2019. The upcoming landing workshop aiming at reconstructing time series of landings could enable us to go further back in time and to improve. This exercise is currently only feasible for glass eel recruitment: while landings data are available for other stages, we are still missing abundance indices of yellow eel standing stock of for silver eel abundance.



```{r fishingmortalitydata,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
pwd = passwordwgeel = password = cred$password
con = dbConnect(RPostgres::Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=passwordwgeel)
query="select sum(eel_value),eel_year,eel_emu_nameshort,eel_cou_code from datawg.t_eelstock_eel where eel_typ_id=4 and eel_qal_id=1 and eel_lfs_code in ('G','GY') and eel_year >= 2000 group by eel_year, eel_emu_nameshort,eel_cou_code "
landings=dbGetQuery(con,query) %>%
  na.omit() %>%
  mutate(area=ifelse(eel_cou_code %in% c("DK","NO","NL","DE") | eel_emu_nameshort %in% c("GB_Scot","GB_Nort","GB_Humb","GB_Angl","GB_Tham"),
                     "North Sea","Elsewhere Europe"))
emusNS <-landings %>%
  filter(area=="North Sea") %>%
  arrange(eel_emu_nameshort) %>%
  dplyr::select(eel_emu_nameshort) %>%
  unique() %>%
  dplyr::pull() %>%
  paste(collapse=", ")
emusEE <-landings %>%
  filter(area!="North Sea") %>%
  arrange(eel_emu_nameshort) %>%
  dplyr::select(eel_emu_nameshort) %>%
  unique() %>%
  dplyr::pull() %>%
  paste(collapse=", ")
                

landings <- landings %>%
  dplyr::group_by(eel_year,area) %>%
  dplyr::summarize(landings=sum(sum, na.rm=TRUE)) %>%
  dplyr::rename(year_f=eel_year) %>%
  ungroup()

rates <- left_join(dat_ge%>% mutate(year_f=as.numeric(as.character(year_f))),landings ) %>%
  filter(year_f >= 2000) %>%
  filter(area=="Elsewhere Europe") %>%
  mutate(landings=ifelse(year_f==2009, NA, landings))

dbDisconnect(con)
```





```{r fishingmortality, eval=TRUE, fig.cap=paste("Reported G and GY commerical landings divided by recruitment index for EE (including landings reported in EMUs",emusEE,". The resulting ratio is a relative proxy of the exploitation rate that inform on trends in fishing mortality. The graph is restricted to the post Eel Regulation period since landings data are thought to be of better quality since then. Note that 2000 landings data is not available for GB. Year 2009 was removed since French, which accounts for a significant part of the landings, have not reported data for this year."), fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}

ggplot(rates,aes(x=year_f)) +geom_ribbon(aes(ymin=landings/p_std_1960_1979_max, 
                                             ymax=landings/p_std_1960_1979_min),
                                         alpha=.3) +
  geom_line(aes(y=landings/p_std_1960_1979))+
  geom_point(aes(y=landings/p_std_1960_1979))+
  xlab("") + 
  scale_x_continuous(breaks=seq(2000, CY, 3), labels=seq(2000, CY, 3))+
  ylab("Reported landings divided by glass eel recruitment index") +
  theme_bw()

ggsave(paste0(imgwd,"rates.png"),width=16/2.54,height=12/2.54,dpi=300)


```
 
<!-- TAF_REMOVE -->
```{r TAF,  eval= FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
source("TAFgeneration/taf_generation_script.R")
```


## Quality analysis
### Retrospective analysis
The following diagrams show the influence of new time series integration and data revision on the assessment. Each line corresponds to the GLM based on the time series used in year indicated by the color. The panel "not updated" stands for a GLM in which the data available at the time of the assessment are used. In "updated panel", potential revisions of data are integrated.

```{r retrospective,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
cred=read_yaml("../../credentials.yml")
con = dbConnect(RPostgres::Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=cred$password)

series=dbReadTable(con,Id(schema="datawg",table="t_series_ser"))
inclusion=dbGetQuery(con,"select min(extract (year from run_date)) as intro_year, ser_nameshort from datawg.t_modeldata_dat left join datawg.t_modelrun_run on dat_run_id=run_id left join datawg.t_series_ser on ser_id=dat_ser_id group by ser_nameshort") %>%
  mutate(intro_year=ifelse(intro_year==2018,"2018",intro_year))

#####First we draw retrospective plots with the data as they were when the model was run


#######retrospective plot model_yoy

retro_yoy_notupdated=do.call(bind_rows,lapply(2018:(CY-1),compute_retro_year)) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std")) %>%
  bind_rows(dat_ge%>%
              mutate(proj=FALSE)) %>%
  mutate(run_id=ifelse(is.na(run_id),CY,run_id)) %>%
  mutate(model="yoy",type="not updated") 


#####Now we draw retrospective plots with the data with data as they are now


#######retrospective plot model_yoy

retro_older_notupdated=do.call(bind_rows,lapply(2018:(CY-1),compute_retro_year,model="glm_older")) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std"))%>%
  bind_rows(dat_ye%>%
              dplyr::mutate(proj=FALSE) %>%
              dplyr::rename(p_std_1960_1979 = value_std_1960_1979)) %>%
  dplyr::mutate(run_id=ifelse(is.na(run_id),CY,run_id)) %>%
  mutate(model="yellow",type="not updated") 




#######retrospective plot model_yoy

retro_yoy_updated=do.call(bind_rows,
                          lapply(2018:(CY-1), compute_retro_year, update_data=TRUE)) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std")) %>%
  bind_rows(dat_ge%>%
              mutate(proj=FALSE)) %>%
  mutate(run_id=ifelse(is.na(run_id), CY, run_id)) %>%
  mutate(model="yoy",type="updated") 


#######retrospective plot model_yoy

retro_older_updated=do.call(bind_rows,
                            lapply(2018:(CY-1),compute_retro_year,model="glm_older", update_data=TRUE)) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std"))%>%
  bind_rows(dat_ye %>%
              mutate(proj=FALSE) %>%
              dplyr::rename(p_std_1960_1979 = value_std_1960_1979)) %>%
  dplyr::mutate(run_id=ifelse(is.na(run_id),CY,run_id))  %>%
  mutate(model="yellow",type="updated") 


dbDisconnect(con)

ggplot(bind_rows(retro_older_updated,
                 retro_older_notupdated,
                 retro_yoy_notupdated,
                 retro_yoy_updated) %>%
         filter(!proj) %>%
         mutate(area=ifelse(is.na(area), "", as.character(area))),
       aes(x=year,y=p_std_1960_1979)) + 
  geom_line(aes(col=as.factor(run_id))) +
  facet_wrap(~area) +
  scale_y_log10(expression(frac(p,bar(p)[1960-1979]))) + 
  facet_grid(type ~ model + area) +
  scale_color_viridis_d("")+ guides(lty = "none") + 
  xlim(CY-10,CY)



retro_advice_data <- bind_rows(
                 retro_older_notupdated,
                 retro_yoy_notupdated) %>%
         filter(!proj) %>%
         mutate(area=ifelse(is.na(area), "", as.character(area))) %>%
  filter(run_id %in% (CY-4):CY) %>%
  rename(AssessmentYear = run_id)

retro_EE <- ggplot(retro_advice_data %>%
         filter(area == "Elsewhere Europe"),
       aes(x=year,y=p_std_1960_1979)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("Elsewhere Europe")+
  theme_ICES_plots("quality_R",retro_advice_data) 

retro_EE
save_figure("retro_EE",retro_EE,600,480, pdf=FALSE)



retro_NS <- ggplot(retro_advice_data %>%
         filter(area == "North Sea"),
       aes(x=year,y=p_std_1960_1979)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("North Sea") +
  theme_ICES_plots("quality_R",retro_advice_data) 

retro_NS
save_figure("retro_NS",retro_NS,600,480, pdf=FALSE)


retro_YY <- ggplot(retro_advice_data %>%
         filter(model == "yellow"),
       aes(x=year,y=p_std_1960_1979)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("Yellow") +
  theme_ICES_plots("quality_R",retro_advice_data) 

retro_YY
save_figure("retro_YY",retro_YY,600,480, pdf=FALSE)


getmodel <- function(y, model){
  tmp <- environment()
  load(paste0(y,"/data/dat_",ifelse(model=="ge","ge","ye"),".Rdata"), envir = tmp)
  if (model == "ge")
    return(tmp$dat_ge %>%
            mutate(AssessmentYear = y))
  return(tmp$dat_ye%>%
            mutate(AssessmentYear = y))
}
retro_ge <- bind_rows(dat_ge %>%
                        mutate(AssessmentYear = CY),
                      do.call(bind_rows,lapply((CY-4):(CY-1), getmodel,model="ge")))



retro_EE <- ggplot(retro_ge %>%
         filter(area == "Elsewhere Europe"),
       aes(x=year,y=p_std_1960_1979)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("Elsewhere Europe")+
  theme_ICES_plots("quality_R",retro_advice_data) 

retro_EE
save_figure("retro_EE",retro_EE,600,480, pdf=FALSE)



retro_NS <- ggplot(retro_advice_data %>%
         filter(area == "North Sea"),
       aes(x=year,y=p_std_1960_1979)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("North Sea") +
  theme_ICES_plots("quality_R",retro_advice_data) 

retro_NS
save_figure("retro_NS",retro_NS,600,480, pdf=FALSE)



retro_ye <- bind_rows(dat_ye %>%
                        mutate(AssessmentYear = CY),
                      do.call(bind_rows,lapply((CY-4):(CY-1), getmodel,model="ye")))



retro_YY <- ggplot(retro_ye ,
       aes(x=year,y=value_std_1960_1979)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=1,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("Elsewhere Europe")+
  theme_ICES_plots("quality_R",retro_advice_data) 

retro_YY
save_figure("retro_YY",retro_YY,600,480, pdf=FALSE)



```

### Sensitivity to individual time series
The following figures show how the index would change in case the corresponding time-series was discared from the dataset. The colour code indicates the year in which the time series was integrated into the GLM.

```{r influenceseries,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
compute_discrepancy=function(si, model = model_ge_area, years = 2010:2024){
  if ("area" %in% colnames(model$model))
    current_area <- R_stations$area[R_stations$ser_nameshort==si]
         pred_without=predict_model(update(model,data=model$data %>%
                  filter(site!=si & value_std >0))) %>%
           filter(year %in% years)
         pred_with=predict_model(model) %>%
           filter(year %in% years) 
         if ("area" %in% colnames(model$model)){
           pred_with <-
             pred_with %>%
             filter(area == current_area)
           pred_without <-
             pred_without %>%
             filter(area == current_area)
             
         }
         sum((pred_with$p_std-pred_without$p_std)^2)
}
   

sites = unique(na.omit(model_ge_area$data$site))
disc_yoy=data.frame(sites=sites,diff=sapply(sites,compute_discrepancy), area=R_stations$area[match(sites, R_stations$ser_nameshort)]) %>%
  arrange((diff))  %>%
  left_join(inclusion,by=c("sites"="ser_nameshort")) %>%
  mutate(sites=factor(sites,levels=as.character(sites)))
ggplot(disc_yoy %>%
         arrange(desc(diff)),
       aes(x=sites,y=diff,fill=intro_year))+
  geom_bar(stat="identity")+
  coord_flip() + facet_wrap(~area)+
  scale_fill_viridis_d("inclusion in assessment")

sites = unique(na.omit(model_older$data$site))
disc_older=data.frame(sites=sites,diff=sapply(sites,compute_discrepancy,model=model_older)) %>%
  arrange((diff)) %>%
  left_join(inclusion,by=c("sites"="ser_nameshort")) %>%
  mutate(sites=factor(sites,levels=as.character(sites))) 


ggplot(disc_older %>% arrange(desc(diff)),aes(x=sites,y=diff,fill=intro_year))+
  geom_bar(stat="identity")+
  coord_flip()+
  scale_fill_viridis_d("inclusion in assessment")


```


### Residuals plots
The residual plots per series are used to detect potential patterns in time series or possible outliers.

```{r resdiualsyoy,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
datares <- data.frame(obs = names(residuals(model_ge_area)),
                      res = residuals(model_ge_area)) %>%
  right_join(model_ge_area$data %>%
               tibble::rownames_to_column("obs"))

for (i in na.omit(unique(datares$site))){
  print(ggplot(datares %>% filter(site == i),
         aes(x = year, y = res, fill=ifelse(abs(res)<=3,"TRUE","FALSE")))+
    geom_bar(stat = "identity", show.legend=FALSE) + 
    facet_wrap(~site, ncol = 2) +
    ggtitle(i) + 
    scale_fill_manual(values=c("FALSE"='red',"TRUE"="grey")) +
    theme_bw() + 
    geom_hline(aes(yintercept=-3), lty = 2) +
    geom_hline(aes(yintercept = 3), lty = 2))
}
```



```{r resdiualsolder,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
datares <- data.frame(obs = names(residuals(model_older)),
                      res = residuals(model_older)) %>%
  right_join(model_older$data %>%
               tibble::rownames_to_column("obs"))

for (i in na.omit(unique(datares$site))){
  print(ggplot(datares %>% filter(site == i),
         aes(x = year, y = res, fill=ifelse(abs(res)<=3,"TRUE","FALSE")))+
    geom_bar(stat = "identity", show.legend=FALSE) + 
    facet_wrap(~site, ncol = 2) +
    ggtitle(i) + 
    scale_fill_manual(values=c("FALSE"='red',"TRUE"="grey")) +
    theme_bw() + 
    geom_hline(aes(yintercept=-3), lty = 2) +
    geom_hline(aes(yintercept=3), lty = 2))
}
```
<!-- END_TAF_REMOVE -->
