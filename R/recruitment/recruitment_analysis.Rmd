---
title: "Recruitment chapter : Report on developments on the state of the European eel (Anguilla anguilla) stock, fisheries and other anthropogenic impacts"
author: "WGEEL"
date: "`r Sys.Date()`"
documentclass: article
output: 
  bookdown::word_document2:
    fig_caption: yes
    number_sections: no
    reference_docx: "../Rmarkdown/ICES_template.docx"
---

```{r setup, include=FALSE, warning = FALSE, message = FALSE, error=FALSE}
library(knitr)

flextable2ICES <- function(x){
  x |>
    font(fontname = "Calibri", part = "all") |>
    fontsize(size = 8.5, part = "all") |>
    bold(part = "header") |>
    flextable::align(align = "left", part = "all") |>
    flextable::border(part = "all", 
                      border.top = fp_border(color = "black", width = 0.5),
                      border.bottom = fp_border(color = "black", width = 0.5)) |>
    bg(bg = "#B7D1C3", part = "header") |>
    style(pr_p=fp_par(padding = 2),
          part = "all") |>
    style(pr_p=fp_par(padding = 2,
                      border = fp_border(width = 0, col = "#B7D1C3", style = "none")),
          part = "header") |>
    flextable::valign(part = "body", valign = "top")
}


opts_knit$set(eval.after = "fig.cap",
		echo=FALSE,
		warning = FALSE,
		message = FALSE,
		error=FALSE)
Sys.setlocale("LC_ALL", "English_United States.932")
#options(save.defaults = list(version=2))
# Password are stored in R/etc/Rprofile.site
# For the moment the database is stored locally
CY <- 2025 # current year ==> dont forget to update the graphics path below
opt_calculation <- "geomean" # "geomean" or "mean"
opt_std <- "all" #"1979-1994" or "2000-2009" or "all"

options(width=90) # this sets the width of the output
#--------------------------------
# packages used by this script
#--------------------------------
#if(!require(RODBC)) install.packages("RODBC") ; require(RODBC)
library(flextable)
if(!require(officedown)) install.packages("officedown") ; require(officedown)
if(!require(officer)) install.packages("officer") ; require(officer)
if(!require(prettymapr)) install.packages("prettymapr") ; require(prettymapr)
if(!require(ggmagnify)) install.packages("ggmagnify", repos = c("https://hughjonesd.r-universe.dev", 
                 "https://cloud.r-project.org")) ; require(ggmagnify)

if(!require(mgcv)) install.packages("mgcv") ; require(mgcv)
if(!require(car)) install.packages("car") ; require(car)
if(!require(ggplot2)) install.packages("ggplot2") ; require(ggplot2)
if(!require(stringr)) install.packages("stringr") ; require(stringr)
if(!require(patchwork)) install.packages("patchwork") ; require(patchwork)

if(!require(reshape)) install.packages("reshape") ; require(reshape)
if(!require(reshape2)) install.packages("reshape2") ; require(reshape2)
if(!require(ggspatial)) install.packages("ggspatial") ; require(ggspatial)
if(!require(stacomirtools)) install.packages("stacomirtools") ; require(stacomirtools) # for ODBC connections
if(!require(stringr)) install.packages("stringr") ; require(stringr)
if(!require(Hmisc)) install.packages("Hmisc") ; require(Hmisc)
if(!require(xtable)) install.packages("xtable") ; require(xtable)
if(!require(grid)) install.packages("grid") ; require(grid)
if(!require(RPostgreSQL)) install.packages("RPostgreSQL") ; require(RPostgreSQL)
if(!require(RColorBrewer)) install.packages("RColorBrewer") ; require(RColorBrewer)
#if(!require(stacomiR)) install.packages("stacomiR") ; require(stacomiR)
if(!require(dplyr)) install.packages("dplyr") ; require(dplyr)
if(!require(boot)) install.packages("boot") ; require(boot)
if(!require(MASS)) install.packages("MASS") ; require(MASS)
if(!require(lme4)) install.packages("lme4") ; require(lme4)
if(!require(multcomp)) install.packages("multcomp") ; require(multcomp)
if(!require(openxlsx)) install.packages("openxlsx") ; require(openxlsx)
if(!require(getPass)) install.packages("getPass") ; require(getPass)
if(!require(yaml)) install.packages("yaml") ; require(yaml)
set_flextable_defaults(
  font.size = 8.5, font.family = "Calibri",
  font.color = "black",
  table.layout = "autofit",
  border.color = "black",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4)


redtext <- fp_text(color = 'red', bold = TRUE)
purpletext <- fp_text(color = 'purple', bold = TRUE)

#--------------------------------
# get your current name 
#--------------------------------
getUsername <- function(){
	name <- Sys.info()[["user"]]
	return(name)
}

#<TAF_REMOVE>
if (getUsername() == "cedric.briand") setwd("C:/workspace/wg_WGEEL/R/recruitment") 
if (getUsername() %in% c("hilaire.drouineau", "hdrouineau") ) setwd("/home/hilaire.drouineau/Documents/Bordeaux/migrateurs/WGEEL/github/wg_WGEEL/R/recruitment") 
if (getUsername() == "hamme005") setwd("C:/Tessa/wg_WGEEL/R/recruitment") 
#baseODBC=c("wgeel","wgeel",passwordwgeel) #"w3.eptb-vilaine.fr" "localhost" "wgeel" "wgeel_distant" 
cred=read_yaml("../../credentials.yml")
# TODO 2022 use this to connect, not sqldf !!!!!!!!!!!!!!
# currently still using sqldf and RpostgreSQL() change for compatibility with linux

#<END_TAF_REMOVE>
wddata <- getwd()
wd <- wddata

datawd <- str_c(wddata,"/",CY,"/data/")
outputdatawd <- str_c(wddata,"/",CY,"/data/")
imgwd <- str_c(wddata,"/",CY,"/image/")
tabwd <- str_c(wddata,"/",CY,"/table/")
shinywd <-  str_c(wddata,"/../shiny_data_visualisation/shiny_dv/data/recruitment/")
dir.create(str_c(wddata,"/",CY),showWarnings = FALSE)
dir.create(datawd, showWarnings = FALSE)
dir.create(imgwd, showWarnings = FALSE)
dir.create(tabwd, showWarnings = FALSE)

source('utilities.R')
graphics.off() # close all graphics devices
# the results will be stored in a list, when I first run the program,
# on the second run this list will be loaded and I can avoid some steps in the calculation
# by setting the chunks as eval=FALSE

```



<!-- TAF_REMOVE -->

```{r load_database, echo=FALSE, fig.show='hide', eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
pwd = passwordwgeel = password = cred$password
con = dbConnect(RPostgres::Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=passwordwgeel)
load_database(con, path=c(shinywd,datawd), year=CY)
```

<!-- END_TAF_REMOVE -->


```{r load_rdata, echo=FALSE, fig.show='hide', eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
# In this rchunk we load the data even if there is no connection to the database
load(file=str_c(datawd,"wger_init.Rdata"))
load(file=str_c(datawd,"statseries.Rdata"))
load(file=str_c(datawd,"R_stations.Rdata"))
load(file=str_c(datawd,"t_series_ser.Rdata"))
load(file=str_c(datawd,"last_years_with_problem.Rdata"))
stopifnot(all(!is.na(R_stations$area)))
if(sum(is.na(wger_init$area))>0) stop("At least one series has not been affected to an area")
```


```{r select_series, echo=FALSE, fig.show='hide', eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE}
#thisv function do the selection of series, returning several datasets as well as
#selection_summary (a list with interesting statistics)
selection = select_series(wger_init, R_stations)
selection_summary <- selection$selection_summary
glass_eel_yoy <- selection$glass_eel_yoy
older <- selection$older
wger <- selection$wger
R_stations <- selection$R_stations
save(wger, file = paste0(outputdatawd, "wger.Rdata"))
save(older, file = paste0(outputdatawd, "older.Rdata"))
save(glass_eel_yoy, file = paste0(outputdatawd, "glass_eel_yoy.Rdata"))

save(wger, file = paste0(shinywd,"wger.Rdata"))
save(older, file = paste0(shinywd,"older.Rdata"))
save(glass_eel_yoy, file = paste0(shinywd, "glass_eel_yoy.Rdata"))


```


```{r table_series,echo=FALSE, eval=TRUE,fig.show='hide', results="hide", warning = FALSE, message = FALSE, error=FALSE}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%				THIS CHUNK CREATES THE TABLES	
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
series_tables <- make_table_series(selection_summary, R_stations, wger)
selection_summary <- series_tables$selection_summary
R_stations <- series_tables$R_stations 
series_CY <- series_tables$series_CY |> dplyr::select(!all_of("Qal Comment"))
series_CYm1 <- series_tables$series_CYm1
series_lost <- series_tables$series_lost
series_prob <- series_tables$series_prob
printstatseriesY <- series_tables$printstatseriesY
printstatseriesGNS <- series_tables$printstatseriesGNS
printstatseriesGEE <- series_tables$printstatseriesGEE
printstatseriesGY <- series_tables$printstatseriesGY

xseries_CY <- xtable(x = series_CY,
    label = "table_seriesCY",
    caption = str_c("Series updated to ",CY, ". Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Area NS = North Sea, EE = Elsewhere Europe, Division = FAO marine division. Series ordered by stage and from North to South"),
    align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}", "p{1cm}","p{1.4cm}"))
print(xseries_CY, file = str_c(	tabwd,"/table_seriesCY.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    tabular.environment="tabularx",
    width="\\textwidth",
    include.rownames=FALSE
)

#------------------------------------------------------
# xtable of series current year minus one
#------------------------------------------------------
xseries_CYm1 <- xtable(x = series_CYm1,
    label = str_c("table_seriesCYm1"),
    caption = str_c("Series updated to ",CY-1, " see table \\ref{table_seriesCY)} for codes. Series ordered from North to South"),
    align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}"))

print(xseries_CYm1, 
    file = str_c(tabwd,"/table_seriesCYm1.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    tabular.environment="tabularx",
    width="\\textwidth",
    include.rownames=FALSE
)
#------------------------------------------------------
# xtable of series that have not been updated
#------------------------------------------------------
xseries_lost <- xtable(x = series_lost,
    label = str_c("table_serieslost"),
    caption = str_c("Series stopped or not updated to ",CY-1, " see table \\ref{table_seriesCY)} for codes. Series ordered by last year"),
    align=c("p{0cm}","p{1.3cm}","p{6.5cm}","p{1cm}","p{1cm}","p{1cm}","p{1.4cm}","p{1.2cm}"))
print(xseries_lost, 
    file = str_c(tabwd,"/table_serieslost.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    tabular.environment="tabularx",
    width="\\textwidth",
    include.rownames=FALSE
)


xstatseriesGNS <- xtable(x = printstatseriesGNS, 
    label = str_c("statseriesG"),
    caption = str_c("Short description of the sampling sites for European eel recruitment data in the North Sea. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses."),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}","p{1cm}"),
    digits=0)

print(xstatseriesGNS , 
    file = str_c(tabwd,"/table_statseriesGNS.tex"),
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    include.rownames=FALSE
)

xstatseriesGEE <- xtable(x = printstatseriesGEE, 
    label = str_c("statseriesG"),
    caption = str_c("Short description of the sampling sites for European eel recruitment data for Elsewhere Europe. Min and max indicate the first year and last year in the records, and the values are given in the n+ and n- columns, indicate the number of years with values and the number of years when there are missing data within the series. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). Kept = 1 means that the dataseries is used in recruitment analyses."),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}","p{1cm}"),
    digits=0)

print(xstatseriesGEE , 
    file = str_c(tabwd,"/table_statseriesGEE.tex"),
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    include.rownames=FALSE
)

xstatseriesGY <- xtable(x = printstatseriesGY, 
    label = str_c("statseriesGY"),
    caption = str_c("Short description of the recruitment sites (continued : stage glass eel and yellow eel)"),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}","p{1cm}"),
    digits=0)
print(xstatseriesGY , 
    file = str_c(tabwd,"/table_statseriesGY.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    include.rownames=FALSE
)

xstatseriesY <- xtable(x = printstatseriesY, 
    label = str_c("statseriesY"),
    caption = str_c("Short description of the recruitment sites (continued : yellow eel series) "),
    align=c("p{0cm}","p{1cm}","p{1cm}","p{1cm}","p{1cm}","p{0.8cm}","p{0.8cm}","p{1cm}","p{2cm}","p{2cm}","p{1cm}","p{1cm}","p{1cm}"),
    digits=0)
print(xstatseriesY, 
    file = str_c(tabwd,"/table_statseriesY.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    include.rownames=FALSE
)

################################################################
# Table of the problem in series for this year
################################################################
xseries_prob <- xtable(x = series_prob[1:15,],
    label = "table_series_prob",
    caption = str_c("Data in " ,CY-1, " and ", CY, " having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
            2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
    align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
)
print(xseries_prob,
    file = str_c(	tabwd,"/table_series_prob.tex"),
    table.placement = "htbp",
    caption.placement = "top",
    sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
    NA.string = ".",
    #tabular.environment="longtable",
    include.rownames=FALSE
)
if (nrow(series_prob)>15){
  xseries_prob1 <- xtable(x = series_prob[15:30,],
      label = "table_series_prob1",
      caption = str_c("Table \\ref{table_series_prob} continued. Data in ",CY-1," and ",CY,"  having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
              2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
      align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
  )
  print(xseries_prob1,
      file = str_c(	tabwd,"/table_series_prob1.tex"),
      table.placement = "htbp",
      caption.placement = "top",
      sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
      NA.string = ".",
      #tabular.environment="longtable",
      include.rownames=FALSE
  )
}

if (nrow(series_prob)>30){
  xseries_prob2 <- xtable(x = series_prob[30:nrow(series_prob),],
      label = "table_series_prob2",
      caption = str_c("Table \\ref{table_series_prob} continued. Data in ",CY-1," and ",CY," having problems causing the data in the specific year to be excluded from the analysis. Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Division = FAO marine division. Kept: 0 = missing, 1 = good quality,
              2 = wgeel has modified the data, 3 = not used due to poor quality, 4 =	data is used, but there are warnings on its quality"),
      align=c("p{0cm}","p{1.5cm}","p{1.5cm}","p{1.5cm}","p{1cm}","p{1cm}","p{1cm}","p{8cm}")
  )
  print(xseries_prob2,
      file = str_c(	tabwd,"/table_series_prob2.tex"),
      table.placement = "htbp",
      caption.placement = "top",
      sanitize.colnames.function=function(x){x}, # otherwise \\ are escaped
      NA.string = ".",
      #tabular.environment="longtable",
      include.rownames=FALSE
  )
}

# when have the series been more than 10 years ?
#res <- bind_rows(glass_eel_yoy,older) %>% arrange(site, year) %>% 
#		mutate(count=1) %>% 
#		group_by(site) %>% 
#		mutate(n=cumsum(count)) %>%
#		#filter(site=='BrokGY')
#		filter(n==10)%>%
#		dplyr::select(site, year)




```


```{r figureseries, echo=FALSE,  eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dd <- as.data.frame(table(year=wger$year,lifestage=wger$lifestage))
dd$lifestage <- ifelse(dd$lifestage == "glass eel + yellow eel",
                        "mixed glass and yellow eels", as.character(dd$lifestage))
figure2 <- ggplot(dd, aes(x=as.numeric(as.character(year)), y=Freq, group=lifestage, col=lifestage)) + geom_point() + geom_line(lwd=2) + ylab('number of series') +xlab('year')+
		theme(text=element_text(size=12))+
		scale_x_continuous(limits=c(1900,CY))+
		theme_bw()+
		theme(text = element_text(size=20),
				axis.text.x = element_text(angle=0, hjust=1))+
		theme(legend.position = c(0.25,0.75), legend.text = element_text( size = 20))


print(figure2)
save_figure(figname="figure2",figure2,800,600)

ddd <- as.data.frame(table(year=wger$year,lifestage=wger$lifestage, area=wger$area2))
ddd$lifestage <- ifelse(ddd$lifestage == "glass eel + yellow eel",
                        "mixed glass and yellow eels", as.character(ddd$lifestage))

figure2.1 <- ggplot(ddd, aes(x=as.numeric(as.character(year)), y=Freq, group=lifestage, col=lifestage)) + geom_point() + geom_line(lwd=2) + ylab('number of series') +xlab('year')+
		facet_wrap(~factor(ddd$area), ncol=2) +
		theme(text=element_text(size=10))+
		scale_x_continuous(limits=c(1900,CY))+
		theme_bw()+
		theme(text = element_text(size=25),
				axis.text.x = element_text(angle=0, hjust=1))+
		# theme(legend.position = c(0.15,0.88), legend.text = element_text( size = 15),axis.text.x = element_text(angle = 45, size=16))
		theme(legend.text = element_text( size = 15),axis.text.x = element_text(angle = 45, size=16))



print(figure2.1)
save_figure(figname="series_no_area",figure2.1,1000,500)
```


```{r mapseries,echo=FALSE, eval=TRUE,results="hide", warning = FALSE, message = FALSE, error=FALSE,fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


# if problems see https://github.com/dkahle/ggmap/issues/160

if(!require(ggmap)) install.packages("ggmap") ; require(ggmap)
if(!require(sf)) install.packages("sf") ; require(sf)
if(!require(RPostgres)) install.packages("RPostgres") ; require(RPostgres)

load("../shiny_data_visualisation/shiny_dv/data/ref_and_eel_data.Rdata")
source("../utilities/load_library.R")
source("../shiny_data_visualisation/shiny_dv/database_connection.R")



# my_map <- get_map( c(left = -13, bottom = 35, right =
# 						27, top = 65),zoom=4, maptype = c("stamen_watercolor"))


#<TAF_REMOVE>
if (!file.exists(paste0(datawd,"fao.rdata"))){
con <- dbConnect(Postgres(),host=cred$host,password=cred$password,dbname=cred$dbname,user=cred$user)
fao <- st_read(con,query="select * from ref.tr_faoareas")
fao <- st_crop(fao, xmin = -13, xmax = 27,
		ymin = 35, ymax = 65)
fao <- st_transform(fao,3857)
fao$zone <- 
		ifelse(startsWith(fao$f_code,"27.4.") | startsWith(fao$f_code,"27.3."),
				"North Sea",
				"Elsewhere Europe")
# this is not used but just in case
fao$zoneyellow <- ifelse(fao$f_code %in% c("27.3.d",'27.3.b, c'),"Baltic",
    ifelse(startsWith(fao$f_code,"27.4.") | startsWith(fao$f_code,"27.3."),
        "North Sea",
        ifelse(startsWith(fao$f_code,"37"), "Mediterranean_sea",
        "Elsewhere Europe")))

save(fao, file=paste0(datawd,"fao.Rdata"))
}
#<END_TAF_REMOVE>

load(paste0(datawd,"fao.Rdata"))
# ggmap_bbox <- function(map) {
# 	if (!inherits(map, "ggmap")) stop("map must be a ggmap object")
# 	# Extract the bounding box (in lat/lon) from the ggmap to a numeric vector, 
# 	# and set the names to what sf::st_bbox expects:
# 	map_bbox <- setNames(unlist(attr(map, "bb")), 
# 			c("ymin", "xmin", "ymax", "xmax"))
# 	
# 	# Coonvert the bbox to an sf polygon, transform it to 3857, 
# 	# and convert back to a bbox (convoluted, but it works)
# 	bbox_3857 <- st_bbox(st_transform(st_as_sfc(st_bbox(map_bbox, crs = 4326)), 3857))
# 	
# 	# Overwrite the bbox of the ggmap object with the transformed coordinates 
# 	attr(map, "bb")$ll.lat <- bbox_3857["ymin"]
# 	attr(map, "bb")$ll.lon <- bbox_3857["xmin"]
# 	attr(map, "bb")$ur.lat <- bbox_3857["ymax"]
# 	attr(map, "bb")$ur.lon <- bbox_3857["xmax"]
# 	map
# }
# my_map<- ggmap_bbox(my_map)
stations <- st_transform(st_as_sf(R_stations,coords=c("ser_x","ser_y"),crs=4326),3857)
#stations <- st_as_sf(R_stations,coords=c("ser_x","ser_y"),crs=4326)

stations$X = st_coordinates(stations)[,"X"]
stations$Y = st_coordinates(stations)[,"Y"]

singlemap <- ggplot() +
  annotation_map_tile(type = "https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/${z}/${x}/${y}.jpg")+ 
		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone,alpha="1")) +
		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone)) +
		geom_sf_text(data=st_centroid(fao), inherit.aes=FALSE,aes(label=f_code),cex=1.5) +
#		geom_sf(data=stations,aes(color=ser_lfs_code,shape=ser_lfs_code),size=2, inherit.aes = FALSE)+
#		geom_sf(data=subset(stations,ser_lfs_code!="Y" & ser_qal_id==1),color = 'black',size=2, shape = 21,
#				inherit.aes=FALSE) +
#		geom_sf(data=subset(stations,ser_lfs_code=="Y"& ser_qal_id==1),color = 'black',size=2, shape = 24,
#				inherit.aes=FALSE) +
		geom_point(data=subset(stations, (ser_qal_id==1 |ser_qal_id==4)) ,aes(x=X,y=Y,
						color=ser_lfs_code,shape=ser_lfs_code,stroke=0),size=3)+
		geom_point(data=subset(stations,ser_lfs_code!="Y"& (ser_qal_id==1 |ser_qal_id==4)),
				color = 'black', 
				size=3, 
				shape = 21,
				stroke=1,
				aes(x=X,y=Y)) +
		geom_point(data=subset(stations,ser_lfs_code=="Y"& (ser_qal_id==1 |ser_qal_id==4)),
				color = 'black',		
				size= 3, 
				shape = 24,
				stroke =1,
				aes(x=X,y=Y)) +
		
		scale_color_manual("Life stage",values=c("white","grey","yellow")) +
		scale_shape_manual("Life stage", values=c(19,19,17)) + xlab("") + ylab("") +
		scale_fill_manual(NULL,values=c("#33b1c4","#30ff8a","#1a81db")) +
		guides(alpha=guide_legend("Recruitment series",
						legend.background = element_blank(),
						title.theme=element_text(face="bold"),
						keyheight=0,
						label.theme=element_text(size=0,lineheight=0),
						order=1, 
						override.aes=list(color=NA, shape=NA, alpha=NA, fill=NA))) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent")
		
		)
print(singlemap)


mapG <- ggplot() +
  annotation_map_tile(type = "https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/${z}/${x}/${y}.jpg")+
  geom_sf(data=fao %>% filter(zone %in% c("North Sea","Elsewhere Europe")), inherit.aes = FALSE, aes(fill=zone)) +
#		geom_sf(data=fao, inherit.aes = FALSE,aes(fill=zone)) +
		geom_sf_text(data=st_centroid(fao), inherit.aes=FALSE, aes(label=f_code),cex=1.5) +
#		geom_sf(data=stations,aes(color=ser_lfs_code,shape=ser_lfs_code),size=2, inherit.aes = FALSE)+
#		geom_sf(data=subset(stations,ser_lfs_code!="Y" & ser_qal_id==1),color = 'black',size=2, shape = 21,
#				inherit.aes=FALSE) +
#		geom_sf(data=subset(stations,ser_lfs_code=="Y"& ser_qal_id==1),color = 'black',size=2, shape = 24,
#				inherit.aes=FALSE) +
		geom_point(data=stations %>% filter(ser_qal_id == 1 & ser_lfs_code %in% c("G", "GY")),aes(x=X,y=Y,
						color=ser_lfs_code,stroke=0),shape=19,size=3)+
		 geom_point(data=subset(stations,ser_qal_id==1&  ser_lfs_code %in% c("G", "GY")),
		 		color = 'black', 
		 		size=3, 
		 		shape = 21,
		 		stroke=1,
		 		aes(x=X,y=Y)) +
		guides(fill = guide_legend(override.aes = list(shape = 21))) +
		scale_fill_manual("Area",values=c("#33b1c4","#1a81db","#30ff8a")) +
		scale_color_manual("Life stage",values=c("white","grey","yellow"))+
		guides(alpha=guide_legend("Recruitment series",
						legend.background = element_blank(),
						title.theme=element_text(face="bold"),
						keyheight=0,
						label.theme=element_text(size=0,lineheight=0),
						order=1, 
						override.aes=list(color=NA, shape=NA, alpha=NA, fill=NA))) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent"),
				axis.text=element_text(size=8),
				plot.margin=margin(0.,0.1,0.1,0.1, "cm")
		
		) + xlab("")+ylab("")

mapY <- ggplot()+
  annotation_map_tile(type = "https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/${z}/${x}/${y}.jpg")+
		coord_sf(crs = st_crs(3857)) + # force it to be 3857
		geom_sf(data=fao, inherit.aes = FALSE, fill=NA) +
		geom_sf_text(data=st_centroid(fao), inherit.aes=FALSE,aes(label=f_code),cex=1.5) +
#		geom_sf(data=stations,aes(color=ser_lfs_code,shape=ser_lfs_code),size=2, inherit.aes = FALSE)+
#		geom_sf(data=subset(stations,ser_lfs_code!="Y" & ser_qal_id==1),color = 'black',size=2, shape = 21,
#				inherit.aes=FALSE) +
#		geom_sf(data=subset(stations,ser_lfs_code=="Y"& ser_qal_id==1),color = 'black',size=2, shape = 24,
#				inherit.aes=FALSE) +
		geom_point(data=stations %>% filter(ser_qal_id == 1 & ser_lfs_code %in% c("Y")),aes(x=X,y=Y,
						color=ser_lfs_code,stroke=0),shape=17,size=3)+
		 geom_point(data=subset(stations,ser_qal_id==1&  ser_lfs_code %in% c("Y")),
		 		color = 'black', 
		 		size=3, 
		 		shape = 24,
		 		stroke=1,
		 		aes(x=X,y=Y)) +
		guides(fill = guide_legend(override.aes = list(shape = 21))) +
		scale_color_manual("Life stage",values=c("white","grey","yellow"))+
		guides(alpha=guide_legend("Recruitment series",
						legend.background = element_blank(),
						title.theme=element_text(face="bold"),
						keyheight=0,
						label.theme=element_text(size=0,lineheight=0),
						order=1, 
						override.aes=list(color=NA, shape=NA, alpha=NA, fill=NA))) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent"),
				axis.text=element_text(size=8),
				plot.margin=margin(0.,0.1,0.1,0.1, "cm") 
		
		) + xlab("")+ylab("")

figure1 <- ggpubr::ggarrange(plotlist=list(mapG,mapY),nrow=1)
print(figure1)
save_figure("figure1",figure1,1100,800)
save_figure("singlemap",singlemap,1100,800)

```


```{r tableswgeel,echo=FALSE, eval=FALSE,results="hide", warning = FALSE, message = FALSE, error=FALSE}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# THIS R CHUNCK IS USED ONCE AT THE END TO GENERATE THE TABLES.
## This will fail if saved twice, run at the end of the working group to generate the table of values
wger_init$das_order <- order(wger_init$cou_order, wger_init$ser_y, wger_init$site, wger_init$year)
wger_init$ser_order <- rank(order(wger_init$cou_order, wger_init$ser_y, wger_init$site))
dat <- wger_init[wger_init$ser_order,]
dat$year=as.factor(dat$year)


tab1 <- reshape2::dcast(dat,year~site,value.var="value")
tab1[,2:ncol(tab1)]=round(tab1[,2:ncol(tab1)],2)
tab1[,1] <- as.character(tab1[,1])

statseries <- statseries[order(statseries$site),]

first_line <- c("kept",statseries$series_kept)
tab1 <- rbind(first_line,tab1)


openxlsx::write.xlsx(x=list("recruitment_series"=tab1,
				"series_description"=statseries, 
        "stat_G_EE"=printstatseriesGEE,
        "stat_G_NS"=printstatseriesGNS,
        "stat_GY"=printstatseriesGY,
        "stat_Y"=printstatseriesY,
        "t_series_ser"=t_series_ser),file=str_c(outputdatawd,"table_rec", CY, ".xlsx"))

openxlsx::write.xlsx(x=list("wger_init"=wger_init,
				"older"=older, "wger"=wger),file=str_c(outputdatawd,"table_long", CY, ".xlsx"))

```

```{r generation_of_plot_data, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.show='hide'}
###################################################
# Generation of the dataframes used to plot the data
# two similar dataframe are created
# with the new ggplot2 it is no longer necessary but code was developped earlier at
# the time when such format was still necessary
# we will create a first dataframe (scal) with all the series together, this was
# the initial analysis built by Wgeel, and it is kept for historical consistency
# later on the geomean have been added , and the graph add a bootstrap calculation of the mean (bootscal)
# At some point the wgeel discussed that it might make more sense to separate
# glass eel (scalgeel) and yellow eel (scalyellow), so this graph is showing all, the geomean on all series, the
# trend for glass eel and the trend for yellow eel. This graph shows "unprocessed" data,
# as the wgeel recruitment index uses a glm index to rebuilt a consistent series.
# At some point ACFM asked to use a different scaling period and we complied but the graph
# is no longer shown as it is a bit confusing.
# below now a geom bootstrap is proposed. 
# TODO  2018 discuss whether to present arithmetic (not really good), geometric mean,
# or nothing at all (Willem's suggestion)
###################################################
sgeomean.cl.boot <- function (x, conf.int = 0.95, B = 1000, na.rm = TRUE, reps = FALSE) 
{
	if (na.rm)    x <- x[!is.na(x)]
	n <- length(x)
	# geomean returns a dataframe, convert it to vector
	xbar <- as.numeric(geomean(x))
	if (n < 2L) # 2L is an integer
		return(c(Mean = xbar, Lower = NA, Upper = NA))
	z <- unlist(lapply(seq_len(B), function(i, x, N) sum(x[sample.int(N, 
												N, TRUE, NULL)]), x = x, N = n))/n
	quant <- quantile(z, c((1 - conf.int)/2, (1 + conf.int)/2))
	names(quant) <- NULL
	res <- c(Geomean = xbar, Lower = quant[1L], Upper = quant[2L])
	if (reps) 
		attr(res, "reps") <- z
	res
}
scal=data.frame("year"=as.numeric(names(tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(wger$value_std_1979_1994,wger$year,min,na.rm=TRUE),
		"ymax"=tapply(wger$value_std_1979_1994,wger$year,max,na.rm=TRUE),
		"mean"=tapply(wger$value_std_1979_1994,wger$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(wger$value_std_1979_1994,wger$year,geomean,na.rm=TRUE)))


li_cl_boot=tapply(wger$value_std_1979_1994,wger$year,smean.cl.boot)
li_cl_boot_geomean=tapply(wger$value_std_1979_1994,wger$year,sgeomean.cl.boot)
bootscal=data.frame("year"=as.numeric(names(li_cl_boot)),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
		"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
		"ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
		"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),    
		"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
		"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))
# creating a subset with all data (glass_eel_yoy is limited in its timeframe)
datageel=subset(wger,wger$lifestage!="yellow eel")
scalgeel=data.frame(
		"year"=as.numeric(names(tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datageel$value_std_1979_1994,datageel$year,min,na.rm=TRUE),
		"ymax"=	tapply(datageel$value_std_1979_1994,datageel$year,max,na.rm=TRUE),
		"mean"=tapply(datageel$value_std_1979_1994,datageel$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean,na.rm=TRUE))
)
datayellow=subset(wger,wger$lifestage=="yellow eel")
scalyellow=data.frame(
		"year"=as.numeric(names(tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datayellow$value_std_1979_1994,datayellow$year,min,na.rm=TRUE),
		"ymax"=	tapply(datayellow$value_std_1979_1994,datayellow$year,max,na.rm=TRUE),	
		"mean"=tapply(datayellow$value_std_1979_1994,datayellow$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean,na.rm=TRUE)))
scaldata=wger[,c("year","value_std_1979_1994","value_std","site","lifestage")]
################################################################
# With scaling 2000-2010
##############################################################

scal_2000_2009=data.frame("year"=as.numeric(names(tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(wger$value_std_2000_2009,wger$year,min,na.rm=TRUE),
		"ymax"=tapply(wger$value_std_2000_2009,wger$year,max,na.rm=TRUE),  
		"mean"=tapply(wger$value_std_2000_2009,wger$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(wger$value_std_2000_2009,wger$year,geomean)))
li_cl_boot=tapply(wger$value_std_2000_2009,wger$year,smean.cl.boot)
bootscal_2000_2009=data.frame("year"=as.numeric(names(li_cl_boot)),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"=unlist(lapply(li_cl_boot,function(X)X["Lower"])),
		"ymax"=unlist(lapply(li_cl_boot,function(X)X["Upper"])),
		"ymin_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Lower"])),
		"ymax_geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Upper"])),
		"mean"=unlist(lapply(li_cl_boot,function(X)X["Mean"])),
		"geomean"=unlist(lapply(li_cl_boot_geomean,function(X)X["Geomean"])))

scalgeel_2000_2009=data.frame(
		"year"=as.numeric(names(tapply(datageel$value_std_2000_2009,datageel$year,min))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datageel$value_std_2000_2009,datageel$year,min,na.rm=TRUE),
		"ymax"=	tapply(datageel$value_std_2000_2009,datageel$year,max,na.rm=TRUE),	
		"mean"=tapply(datageel$value_std_2000_2009,datageel$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datageel$value_std_2000_2009,datageel$year,geomean))
)

scalyellow_2000_2009=data.frame(
		"year"=as.numeric(names(tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE))),
		"value_std"=NA,
		"name"=NA,
		"lifestage"=NA,
		"ymin"= tapply(datayellow$value_std_2000_2009,datayellow$year,min,na.rm=TRUE),
		"ymax"=	tapply(datayellow$value_std_2000_2009,datayellow$year,max,na.rm=TRUE),	
		"mean"=tapply(datayellow$value_std_2000_2009,datayellow$year,mean,na.rm=TRUE),
		"geomean"=unlist(tapply(datayellow$value_std_2000_2009,datayellow$year,geomean,na.rm=TRUE)))
scaldata_2000_2009=wger[,c("year","value_std_2000_2009","site","lifestage")]

#########################
# for Miran
# exporting the geomeans 
########################
print("simple geomeans for glass eel, asked by Miran")
round(unlist(tapply(datageel$value_std_1979_1994,datageel$year,geomean)),3)
print ("simple geomeans for yellow eels")
round(unlist(tapply(datayellow$value_std_1979_1994,datayellow$year,geomean)),3)

########################################
# FIGURE 3 WITHOUT LOG SCALE
# normalscale + geomean+ bootstrap scaled mean and confidence interval
#########################################

# first option, in the following figure the red line represents the geometric means
# and the dots are the bootstrap means
g <- ggplot(scaldata)
g1 <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
		ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
		theme(legend.position = "none")

figure3withoutlogscale <- g1+	scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)

print(figure3withoutlogscale)
save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)

# second option, in the following figure the blue line represents the arithmetic means
# and the dots are the bootstrap geommeans

g <- ggplot(scaldata)
g2 <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4)+
		ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=geomean,ymin=ymin_geomean,ymax=ymax_geomean),size=0.5,colour="black")+
		geom_line(data=scal,aes(x=year,y=mean),colour="#003366",size=1.2)+
		theme(legend.position = "none")

figure3withoutlogscale_opt2 <- g2+scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		scale_y_continuous(limits=c(0,10))+annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)

print(figure3withoutlogscale_opt2)

save_figure("figure3withoutlogscale",figure3withoutlogscale,800,600)
save_figure("figure3withoutlogscale_opt2",figure3withoutlogscale_opt2,800,600)
# scaldata[scaldata$year>2000&scaldata$value_std>1,]
########################################
# FIGURE 3 WITH LOG SCALE
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

figure3 <- g1+
		scale_y_log10(name="scaled 1979-1994 values log scale",limits=c(0.001,30),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
		#ylab()
		
		scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)

print(figure3)
save_figure(figname="figure3",figure3,800,600)


figure3bis <- g1+
		scale_y_log10(name="scaled 1979-1994 values log scale",
				limits=c(0.001,30),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		scale_x_continuous(breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2))+
		annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=30,fill="grey",alpha=0.5)

print(figure3bis)

save_figure(figname="figure3",figure3,800,600)
save_figure(figname="figure3bis",figure3bis,800,600)

########################################
# FIGURE 3 WITH LOG SCALE {{BLACK}}
# All series 1979-1994 +
#  geomean+ bootstrap scaled mean and confidence interval
#########################################

g <- ggplot(scaldata)
figure3black <- g+geom_point(aes(x=year, y=value_std_1979_1994,colour=site,shape=lifestage),size=1.5,show.legend=FALSE)+
		geom_line(aes(x=year, y=value_std_1979_1994,colour=site,lty=lifestage),size=0.4,show.legend=FALSE)+
		#ylab("scaled 1979-1994 values")+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
		geom_line(data=scal,aes(x=year,y=geomean),colour="red",size=1.2)+
		scale_y_log10(name="percentage of 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
		scale_x_continuous(breaks=c(1930,1950,1970,1980,1990,2000,2010),
				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,CY))+
		theme_black()

print(figure3black)
# {{{{{{{{{{{{{{{{{{{{{{{{{
save_figure(figname="figure3black",figure3black,800,600)

# {{{{{{{{{{{{{{{{{{{{{{{{{
##########################################
## Same graph for presentation but labels are in French
##########################################
#g <- ggplot(scaldata)
#g+geom_point(aes(x=year, y=value_std,colour=site,shape=lifestage),size=1.5,legend=FALSE)+
#		geom_line(aes(x=year, y=value_std,colour=site,lty=lifestage),size=0.4,legend=FALSE)+
#		opts(title="Tendance du recrutement Europeen")+
#		#ylab("scaled 1979-1994 values")+
#		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="beige")+
#		scale_y_log10(name="% de 1979-1994",limits=c(0.005,10),breaks=c(0.01,0.1,1,10),labels=c("1%","10%","100%","1000%"))+
#		scale_x_continuous(name="Annee",breaks=c(1930,1950,1970,1980,1990,2000,2010),
#				minor_breaks=seq(from=min(scaldata$year),to=max(scaldata$year),by=2),limits=c(1930,2010))+theme_dark()
########################################
# FIGURE 4 
# limited graph with scale
########################################
scallog <- scal
scallog[scallog$ymin<1e-2,"ymin"] <- 1e-2
scallog[scallog$ymax>30,"ymax"] <- 30
g <- ggplot(scallog)
figure4 <- g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey",data=scallog)+
		ylab("scaled 1979-1994 values log scale")+
		geom_line(aes(x=year,y=mean),data=scalgeel,colour="darkblue",size=1)+
		geom_line(aes(x=year,y=mean),data=scalyellow,colour="darkorange4",size = 1)+
		geom_pointrange(data=bootscal,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		scale_y_log10(limits=c(0.01,30),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+
		annotate("rect",xmin=1930,ymin=0.01,xmax=1960,ymax=30,fill="white",alpha=0.7)+
		scale_x_continuous(limits=c(1930,CY))

print(figure4)
save_figure(figname="figure4",figure4,800,600)

########################################
# FIGURE 4 
# BUT WITH REFERENCE 2000-2010 !
########################################
scallog <- scal_2000_2009
scallog[scallog$ymin<1e-1,"ymin"] <- 1e-1
scallog[scallog$ymax>1000,"ymax"] <- 1000
g <- ggplot(scallog)
figure42000_2009 <- g+geom_ribbon(aes(x=year,ymin=ymin,ymax=ymax),fill="grey")+
		#ggtitle("Recruitment European overview")+
		ylab("scaled to 2000-2010, log scale")+
		geom_line(aes(x=year,y=mean),data=scalgeel_2000_2009,colour="darkblue",size=1)+
		geom_line(aes(x=year,y=mean),data=scalyellow_2000_2009,colour="darkorange4",size = 1)+
		geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
		geom_abline( intercept = 0,slope=0,	alpha = .4,col="red")+
		geom_abline( intercept = 2,slope=0,	alpha = .4,col="red")+
		scale_y_log10(limits=c(1e-1,1000),breaks=c(0.01,0.1,1,10,100,1000),labels=c("0.01","0.1","1","10","100","1000"))+		
		scale_x_continuous(limits=c(1930,CY))+
		annotate("rect",xmin=1930,ymin=1e-1,xmax=1960,ymax=1000,fill="white",alpha=0.7)+
		annotate("rect", xmin = 2000, xmax = 2009, ymin = 0.3, ymax = 3,
				alpha = .2,fill="blue")


print(figure42000_2009)

save_figure(figname="figure4_2000_2009",figure42000_2009,800,600)

########################################
# FIGURE NOTHING 
# JUST TO CHECK 
########################################

xg <- unlist(tapply(datageel$value_std,datageel$year,geomean))
rxg <- as.numeric(names(xg))
xy <- unlist(tapply(datayellow$value_std,datayellow$year,geomean))
rxy <- as.numeric(names(xy))
plot(rxg,
		xg,
		type="b",
		main="a simple graph to check that ggplot's running fine")
points(rxy,xy,type="l",col="green")
legend("topright",legend=c("glass","yellow"),col=c("black","green"),lty=1)

# additional figure to check log scaled

plot(rxy,
		xy,log="y",
		type="b",col="green")
points(rxg,xg,type="l")
#tapply(wger$value_std,wger$year,mean_cl_boot)


########################################
# Figure to put forward recent changes in the series
# WITH REFERENCE 2000-2010 !
########################################
figure_check_one_series <- function(site='KatwG',limits=c(1900,CY)){
	g <- ggplot(scaldata_2000_2009)
	g <- g+geom_point(aes(x=year, y=value_std_2000_2009),col="grey",size=1.5)+
			geom_line(aes(x=year, y=value_std_2000_2009),col="grey",size=0.4)+
			geom_point(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
			geom_line(aes(x=year, y=value_std_2000_2009),colour="blue",size=1,data=scaldata_2000_2009[scaldata_2000_2009$site==site,])+
			ylab("scaled 2000-2009 values")+
			geom_pointrange(data=bootscal_2000_2009,aes(x=year,y=mean,ymin=ymin,ymax=ymax),size=0.5,colour="black")+
			geom_line(data=scal_2000_2009,aes(x=year,y=geomean),colour="red",size=1.2)+
			theme(legend.position = "none")+
			scale_x_continuous(limits=limits,breaks=c(1900,1930,1950,1970,1980,1990,2000,2010),minor_breaks=seq(from=min(scaldata_2000_2009$year),to=max(scaldata_2000_2009$year),by=2))+
			scale_y_continuous(limits=c(0,20))+
			annotate("rect",xmin=1900,ymin=0,xmax=1960,ymax=10,fill="grey",alpha=0.5)
	return(g)
}

figure_check_one_series("KatwG",limits=c(1960,2019))
```


```{r model_for_glass_eel_and_yellow_eel_datasets, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}

# glass_eel_yoy$site <- as.factor(glass_eel_yoy$site)

model_ge_area=glm(value_std~year_f:area+site,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log), maxit=300)

# lesser fit :
#model_ge_area1=glm(value_std~year_f:area + as.factor(lfs_code),
#		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
#		family=Gamma(link=log), maxit=300)

print("Analysis for glass eel")
print("data available")
(area_year=table(glass_eel_yoy$year,glass_eel_yoy$area))
print("number of sites finally selected for glass eel glm")
selection_summary$modelge <- list()
selection_summary$modelge$site <- as.character(model_ge_area$xlevels$site)
(selection_summary$modelge$nbsite <- length(selection_summary$modelge$site))
selection_summary$modelge$excluded <- unique(glass_eel_yoy$site)[!unique(glass_eel_yoy$site)%in%selection_summary$modelge$site]
selection_summary$modelge$value_excluded_zero <- glass_eel_yoy[glass_eel_yoy$value==0&!is.na(glass_eel_yoy$value),
		c("value_std","site","year","lifestage","das_comment","area")]

model_older=glm(value_std~year_f+as.factor(site),data=older,family=Gamma(link=log),
		subset=older$value>0 & older$year>1949  ,maxit=300)
selection_summary$modelolder <- list()
selection_summary$modelolder$site <- as.numeric(as.character(model_older$xlevels$`as.factor(site)`))
selection_summary$modelolder$nbsite <- length(selection_summary$modelolder$site)
selection_summary$modelolder$excluded <- unique(older$site)[!unique(older$site)%in%selection_summary$modelolder$site]
selection_summary$modelolder$excludedsite <- unique(older[older$site%in%selection_summary$modelolder$excluded,"site"])
selection_summary$modelolder$excludedsite <- unique(older[older$site%in%selection_summary$modelolder$excluded,"site"])
selection_summary$modelolder$value_excluded_zero <- older[older$value==0,
		c("value_std","site","year","lifestage","das_comment","area")]

xt_a <- xtable(Anova(model_ge_area,test="F"),
		caption=c("Anova for glass eel recruitment model",
				label="table_anova"))

o <- print(xt_a, file = str_c(tabwd,"/table_anova.tex"), 
		table.placement = "htbp",
		caption.placement = "top",
		NA.string = "",
		include.rownames=TRUE,
		tabular.environment="tabularx",
		width="0.8\\textwidth",
		sanitize.colnames.function=function(x){x})	
save(model_ge_area,model_older,file=paste0(shinywd,"recruitment_models.Rdata"))
save(model_ge_area,model_older,file=paste0(outputdatawd,"recruitment_models.Rdata"))

#plot(model_ge_area)
```


```{r mapsresidualsyoy, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
residualsge_tab <- data.frame(residuals = residuals(model_ge_area)) |>
  bind_cols(model_ge_area$data |>
              dplyr::select(all_of(c("value_std", "year_f", "area", "site"))) |>
              na.omit()) |>
  left_join(stations |> dplyr::select(all_of(c("ser_nameshort", "X", "Y"))), by = join_by(site == ser_nameshort))


resid <- ggplot() +
  annotation_map_tile(type = "https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/${z}/${x}/${y}.jpg") + 
		geom_sf(data=fao, inherit.aes = FALSE, fill = NA) +
		geom_point(data = residualsge_tab |>
		             filter(year_f %in% c("2025")),
		           aes(x=X,
		               y=Y,
		               fill = residuals,
		               shape=area),
		           stroke = 1,
		           size=3) + 
  scale_fill_gradient2(midpoint = 0, low = "blue", mid = "white",
                        high = "red", space = "Lab" ) + 
  scale_shape_manual("", values = c(21, 24)) +
		theme(
				legend.box.background = element_rect(fill="#EFD9C1",color=NA),
				legend.background = element_blank(),
				legend.position = c(.995, .3),
				legend.justification = c("right", "center"),
				legend.box.just = "left",
				legend.box.margin = margin(1, 1, 1, 1),
				legend.margin = margin(1, 1, 1, 1),
				legend.key = element_rect(colour = "transparent", fill = "transparent"),
				axis.text=element_text(size=8),
				plot.margin=margin(0.,0.1,0.1,0.1, "cm")
		
		) + xlab("")+ylab("")


save_figure("figureResidMapyoy",resid,1100,800)

```

```{r mixed_models, echo=FALSE, eval=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}


library(lme4)
# Mixed models are used because there is no independence between series collected at the same site.
# Here we create a new column location to "join" those series and treat the location as a mixed effect in the model.
glass_eel_yoy$location <- as.character(glass_eel_yoy$site)
unique(glass_eel_yoy$location)
adour_id <- grep("Ad", glass_eel_yoy$location); glass_eel_yoy$location[adour_id]
glass_eel_yoy$location[adour_id] <- "Adou"
albufera_id <- grep("Al", glass_eel_yoy$location); glass_eel_yoy$location[albufera_id]
glass_eel_yoy$location[albufera_id] <-"Albu"
minho_id <- grep("Mi", glass_eel_yoy$location); glass_eel_yoy$location[minho_id]
glass_eel_yoy$location[minho_id] <-"Minho"
gironde_id <- grep("Gi", glass_eel_yoy$location); glass_eel_yoy$location[gironde_id]
glass_eel_yoy$location[minho_id] <-"Giro"
brownhill_id <- grep("Bro", glass_eel_yoy$location); glass_eel_yoy$location[brownhill_id]
glass_eel_yoy$location[minho_id] <-"Bro"
flatford_id <- grep("Fla", glass_eel_yoy$location); glass_eel_yoy$location[flatford_id]
glass_eel_yoy$location[minho_id] <-"Fla"

glass_eel_yoy$lfs_code <- as.factor(glass_eel_yoy$lfs_code)
glass_eel_yoy$location <- as.factor(glass_eel_yoy$location)

# glmer is used to fit generalized (non-Gaussian) linear mixed models
glmer1 <- glmer(value_std~year_f:area+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer11 <- glmer(value_std~year_f:area+location+(1|site), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer12 <- glmer(value_std~year_f:area+site+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

# model_ge_area is the glm, compare it with ANOVA, this should be fine since is ML



# The deviance The deviance is basically a measure of how much unexplained variation there is in 
# regression model  the higher the value the less accurate the model
devglmer1 <- -2*logLik(glmer1)
devglm <- -2*logLik(model_ge_area)
# diffence of deviance between the two models
(delta_dev <- as.numeric(devglmer1-devglm))
(delta_df <- attr(devglm,"df")-attr(devglmer1,"df"))
## the GLM has a better fit
cat('Chi-square =', delta_dev, '(df=', delta_df,'), p =', 
		pchisq(delta_dev,delta_df,lower.tail=FALSE), "\n")
# same shown here
anova( glmer1, model_ge_area,  test="Chisq")
# So the glm is better than the mixed model



# Here we compare the mixed structure of the models, so we are using REML

glmer1 <- glmer(value_std~year_f:area+site+(1|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glass_eel_yoy$year2 <- pmax(year,2011)
# model with  lfs_code

glmer2 <- glmer(value_std~year_f:area+(1+year|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

glmer3 <- glmer(value_std~year_f:area+(1+year|location) + (1+year2|location), data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		family=Gamma(link=log))

anova(glmer2, glmer1, refit=FALSE)

save(glmer1, glmer2, glmer3, file=paste0(outputdatawd,glmer.Rdata))
#fixef(glmer1)['(Intercept)'] + ranef(glmer1)$location

```


```{r model_for_glass_eel_graph_and_predictions, fig.show='hide',echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
# 1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~1~~
######################################"
#~glass eel (and elver = glass eel + yellow eel) migrant analysis
######################################"~

########new sets of lines to graph plots with confidence intervals
# using expand.grid to build a complete grid for predictions
dat_ge=expand.grid(year_f=model_ge_area$xlevels$year_f,area=model_ge_area$xlevels$area,
		site=model_ge_area$xlevels$site[1])
dat_ge$year <- as.numeric(as.character(dat_ge$year_f))


#predicting
dat_ge$p=predict(model_ge_area,newdata=dat_ge)
dat_ge$se=predict(model_ge_area,newdata=dat_ge,se.fit=TRUE)[["se.fit"]]



mean_1960_1979 <- aggregate(dat_ge[dat_ge$year<1980,"p"],list(dat_ge[dat_ge$year<1980,"area"]),mean)
names(mean_1960_1979) <- c("area","mean")	



dat_ge <- merge(dat_ge,mean_1960_1979,by="area")
dat_ge$p_std_1960_1979 <- exp(dat_ge$p-dat_ge$mean)
dat_ge$p_std_1960_1979_min <- exp(dat_ge$p-dat_ge$mean-1.96*dat_ge$se)
dat_ge$p_std_1960_1979_max <- exp(dat_ge$p-dat_ge$mean+1.96*dat_ge$se)


upperlimit  <- 5
dat_ge$p_std_1960_1979_maxgraph <- pmin(dat_ge$p_std_1960_1979_max,upperlimit-0.01)

g <- ggplot(dat_ge,aes(x=year,y=p_std_1960_1979  * 100))

figure5_without_logscale<- g+
		geom_line(aes(colour=area,lty=area),lwd=1)+ 		
		scale_colour_brewer(name="area",palette="Set1")+
		geom_ribbon(aes(ymin=p_std_1960_1979_min * 100,ymax=p_std_1960_1979_maxgraph  * 100,fill=area),alpha=.3)+
		coord_cartesian(ylim=c(0,500))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_bw()+
		geom_hline(yintercept=100,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position = c(.8, .8))
save_figure("figure5_without_logscale_ribbon",figure5_without_logscale,600,480)


figure5_advice_EE<- ggplot(dat_ge %>% filter(area == "Elsewhere Europe"),
                           aes(x=year,y=p_std_1960_1979*100)) +

		geom_line(lwd=1, aes(col=area), show.legend=FALSE)+ 		
		geom_ribbon(aes(ymin=p_std_1960_1979_min*100,ymax=p_std_1960_1979_maxgraph*100,fill=area),alpha=.3, show.legend=FALSE)+
		coord_cartesian(ylim=c(0,5*100))+
		scale_y_continuous("Std. GLM recruitment")+
		theme_bw()+
		geom_hline(yintercept=100,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme_ICES_plots("Recruitment") + ggtitle("Glass eel Elsewhere Europe recruitment index")

save_figure("figure5_advice_EE",figure5_advice_EE,600,480, pdf = FALSE)


figure5_advice_NS<- ggplot(dat_ge %>% filter(area == "North Sea"),
                           aes(x=year,y=p_std_1960_1979*100)) +

		geom_line(lwd=1, aes(col=area), show.legend=FALSE)+ 		
		geom_ribbon(aes(ymin=p_std_1960_1979_min*100,ymax=p_std_1960_1979_maxgraph*100,fill=area),alpha=.3, show.legend=FALSE)+
		coord_cartesian(ylim=c(0,5*100))+
		scale_y_continuous("Std. GLM recruitment")+
		theme_bw()+
		geom_hline(yintercept=100,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme_ICES_plots("Recruitment") + ggtitle("Glass eel North Sea recruitment index")

save_figure("figure5_advice_NS",figure5_advice_NS,600,480, pdf = FALSE)

# function similar to theme_dark() but allows legends
# black and white plot ====
figure5_without_logscale_black <- g+geom_line(aes(colour=area,lty=area),lwd=1)+
		scale_colour_manual(name="area",values=c("yellow","lawngreen"))+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		theme_black()+
		geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)+
		scale_fill_manual(name="area",values=c("yellow","lawngreen"))

figure5_without_logscale_black
save_figure("figure5_without_logscale_black_ribbon",figure5_without_logscale_black,600,480)

#====
#+geom_smooth(aes(ymin = min, ymax = max,fill=area),stat="identity")+facet_grid( ~ area) 
figure5 <- g+geom_line(aes(colour=area,lty=area),lwd=1.3)+geom_point(aes(colour=area,fill=area,shape=area),size=3)+
		#ggtitle("Recruitment overview glass eel series")+
		scale_colour_brewer(name="area",palette="Set1")  +
		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(1,10,100,1000),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position=c(.8,.9))+geom_ribbon(aes(ymin=p_std_1960_1979_min * 100,ymax=p_std_1960_1979_max * 1000,fill=area),alpha=.3)

figure5
save_figure("figure5_ribbon",figure5,600,480)
#figure5danish <- g+geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		ggtitle("title="Glasaal data fra hele Europa")+
#		scale_colour_brewer(name="area",palette="Set1")  +
#		xlab("Aar")+
#		scale_y_log10(name="Linear model forudsigelser/ gennemsnit 1960-1979",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#figure5danish

#levels(dat$area) <- c (
#		iconv("Andre steder i Europa","UTF8"),
#		iconv("Nordsj?en","UTF8"))#
#g <- ggplot(dat,aes(x=year,y=p_std_1960_1979))
#figure5norvegiean <- g+
#		geom_line(aes(colour=area,lty=area),lwd=1.3)+
#		geom_point(aes(colour=area,shape=area),size=3)+
#		ggtitle(label=iconv("Indeks av glass?lrekruttering","UTF8"))+
#		scale_colour_brewer(name=iconv("Omr?det","UTF8"),palette="Set1")  +
#		scale_shape(name=iconv("Omr?det","UTF8"))+
#		scale_linetype(name=iconv("Omr?det","UTF8"))+
#		xlab(iconv("?r","UTF8"))+
#		scale_y_log10(name=iconv("Standardiserte GLM-prognoser (i prosent av
#		1960-1979-gjennomsnitt)","UTF8"), #limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))
#save_figure("figure5norvegiean",figure5norvegiean,600,480)
#pdf("images/2013/figure5norvegiean.png")
#figure5norvegiean
#dev.off()
save_figure("figure5_ribbon",figure5,600,480)

#figure5bw <- g+geom_line(aes(colour=area,lty=area),wd=1.3)+
#		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
#		#ggtitle("Recruitment overview glass eel series")+
#		scale_colour_manual(name="area",values=c("black","grey40"))  +
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
#		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
#		scale_y_log10(name="standardized glm predictions \n mean 1960-1979-log scale",
#				#limits=c(0.005,10),
#				breaks=c(0.01,0.1,1,10),
#				labels=c("1%","10%","100%","1000%"))+
#		theme_bw()+
#		theme(legend.box =NULL,
#				legend.key = element_rect(colour = NA, fill = 'white'),
#				legend.text = element_text(size = 8, colour = 'black'), 
#				legend.background = element_rect(colour = NA, fill = 'white'))
#print(figure5bw)
#save_figure("figure5bw",figure5bw,600,480)

pred <- dcast(dat_ge,year~area,value.var="p_std_1960_1979")
predmin <- dcast(dat_ge,year~area,value.var="p_std_1960_1979_min")	
predmax <- dcast(dat_ge,year~area,value.var="p_std_1960_1979_max")
synthesis <- cbind(pred,predmin[,c(2,3)],predmax[,c(2,3)])
colnames(synthesis) <- c("year","Elsewhere Europe","North Sea", "EEminCI","NSminCI","EEmaxCI","NSmaxCI")

#if (opt_calculation=="geomean") {
#	synthesis=as.data.frame(tapply(dat_ge[,"p_std_1960_1979"],
#					list(dat_ge[,"year_f"],dat_ge[,"area"]),
#					function(X) {Y=geomean(X) ;
#						return(as.numeric(Y))}))
#} else {
#	synthesis=as.data.frame(tapply(dat_ge[,"p_std_1960_1979"],
#					list(dat_ge[,"year_f"],dat_ge[,"area"]),mean,na.rm=TRUE))
#}
selection_summary$five_year_average <- synthesis %>% filter(year>CY-5) %>% dplyr::select(c(1,2,3)) %>% colMeans() %>% round(digits=3)
selection_summary$five_year_averagem3 <- synthesis %>% filter(year<=CY-2,year>CY-7) %>% dplyr::select(c(1,2,3)) %>% colMeans() %>% round(digits=3)

#xfive_year_avg_glass <- xtable(x = five_year_avg_glass,
#		label = "table_five_year_avg_glass",
#		caption = str_c("GLM estimates for glass eel series, averaged every five years"))
#print(xfive_year_avg_glass, 
#		file = str_c(tabwd,"/table_five_year_avg_glass.tex"),
#		table.placement = "htbp",
#		caption.placement = "top", 
#		NA.string = ".")

gg0 <- synthesis[,c("Elsewhere Europe","North Sea")]
colnames(gg0) <- c("EE","NS")
rownames(gg0) <- synthesis$year
gg <- split_per_decade_ge(gg0)
gg[,1:8] <- 100*round(gg[,1:8],2)
gg[,9:ncol(gg)] <- 100*round(gg[,9:ncol(gg)],3)
nothing <- latex(gg,
		rowlabel="",
		rowlabel.just="c",
		where="hptb",
		cgroup=cgroupdecade,
		n.cgroup=rep(ncol(gg0),length(cgroupdecade)),
		collabel.just=strsplit("c c c c c c c c c c c c c c c", " ")[[1]],	
		col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
		#landscape=TRUE,
		label="table_glm_glass_eel",
		caption=str_c("GLM $glass~eel \\sim year:area + site $ geometric means of predicted values for ",selection_summary$nb_series_glass_eel," glass eel series, values given in percentage of the 1960-1979 period."),	
		file= str_c(tabwd,"/table_glm_glass_eel.tex"))

write.table(synthesis,file=str_c(outputdatawd,"glm_results_glass.csv"),sep=";")

#plot(log(synthesis[synthesis$year>1979,"Elsewhere Europe"]))
trend <- synthesis[synthesis$year>1979,]
trend$EE <- trend$"Elsewhere Europe"
trend$lEE <- log(trend$EE)

trend$lNS <- log(trend$"North Sea")

#round(lm(lEE~year,data=trend)$coefficient[2],4) # -0.098
#round(lm(lNS~year,data=trend)$coefficient[2],4) # -0.098 North Sea -0129

# sgipee test for change ee ---------------------------------------------

#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
#sgipee_test_for_change_ee <- summary(test1)$coefficients[3,4]
#if (sgipee_test_for_change_ee<=0.05) {
#  test_sgipee_char_ee <- "significant"
#}else {
#  test_sgipee_char_ee <- "not significant"
#}

## test on the trend after 2011 ee ----------------------------------------------
#
#K = matrix(c(0,1,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
#summary_coefficient_after <- summary(glht(test1, linfct = K, alternative="greater"))
#confint_coefficient_after  <- confint(glht(test1, linfct = K, alternative="greater"))
#trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)

# sgipee test for change ns ---------------------------------------------

#test=lm(lNS~year+pmax(year,2011),data=trend)
#
#sgipee_test_for_change_ns <- summary(test)$coefficients[3,4]
#if (sgipee_test_for_change_ns<=0.05) {
#  test_sgipee_char_ns <- "significant"
#}else {
#  test_sgipee_char_ns <- "not significant"
#}

## test on the trend after 2011 ns ----------------------------------------------
#
#
#summary_coefficient_after <- summary(glht(test, linfct = K, alternative="greater"))
#confint_coefficient_after  <- confint(glht(test, linfct = K, alternative="greater"))
#trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
#		summary_coefficient_after$test$coefficients,
#		summary_coefficient_after$test$pvalues)

# test glm with a breakpoint ----------------------------------------------------
# this models takes numeric, not factors we assume a log trend
model_ge_area_b=glm(value_std~year:area+site+pmax(year,2011):area,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>=1980,],
		family=Gamma(link=log), maxit=300)
##summary(model_ge_area_b)
## plot(model_ge_area_b)
len <- length(coef(model_ge_area_b))
#gg <- visreg::visreg(model_ge_area_b,"year",by="area", plot=TRUE,gg=TRUE,band=FALSE)
#gg <- gg+facet_wrap(~area,scales="free_y")
#print(gg)
# last coeff are
# year:areaElsewhere Europe 
# year:areaNorth Sea 
# areaElsewhere Europe:pmax(year, 2011)   
# areaNorth Sea:pmax(year, 2011) 
#test1=lm(lEE~year+pmax(year,2011),data=trend)
#Anova(test1)
# this is the n-1 row of the summary
sgipee_test_for_change_ee <- summary(model_ge_area_b)$coefficients[len-1,4]   
sgipee_test_for_change_ns <- summary(model_ge_area_b)$coefficients[len,4]

Kee = matrix(c(rep(0,len-4),1,0,1,0), nrow = 1) # we just add the to coef trend to have the trend after 2011
# test if the coefficient alpha + beta > 0 so the slope of increase is larger than 0
# H0 alpha+beta = 0.5 / alternative alpha+beta >0
summary_coefficient_afteree <-  summary(glht(model_ge_area_b, linfct = Kee, alternative="greater",rhs=0)) 
# test if the coefficient alpha + beta > 0.05 so the slope of the increase is larger than the slope of decrease
# H0 alpha+beta = 0.5 / alternative alpha+beta >0.5
summary(glht(model_ge_area_b, linfct = Kee, alternative="less",rhs=0.05))
Kns = matrix(c(rep(0,len-4),0,1,0,1), nrow = 1) # we just add the to coef trend to have the trend after 2011
summary_coefficient_afterns <- summary(glht(model_ge_area_b, linfct = Kns, alternative="greater"))
trend_test_for_change_ee <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afteree$test$coefficients,
		summary_coefficient_afteree$test$pvalues)
trend_test_for_change_ns <- sprintf("Estimate = %.3f P-value %.4f",
		summary_coefficient_afterns$test$coefficients,
		summary_coefficient_afterns$test$pvalues)

# back to long format, save for shiny

save(dat_ge, file=str_c(outputdatawd,"dat_ge.Rdata"))
save(dat_ge, file=str_c(shinywd,"dat_ge.Rdata"))
```

```{r segmented_regression, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
if(!require(segmented)) install.packages("segmented") ; require(segmented)

dat_ge1 <- expand.grid(year=1980:2025,area=as.factor(model_ge_area_b$xlevels$area),
		site=model_ge_area_b$xlevels$site[1])

dat_ge1$p <- predict(model_ge_area_b,newdata=dat_ge1)
dat_ge1$se <- predict(model_ge_area_b,newdata=dat_ge1,se.fit=TRUE)[["se.fit"]]

#mean_1960_1979 # this is the average p for all series before 1980
# it was generated in the previous chunk
dat_ge1 <- merge(dat_ge1, mean_1960_1979, by="area")

dat_ge1$p_std_1960_1979=exp((dat_ge1$p-dat_ge1$mean))
dat_ge1$p_std_1960_1979_min=exp(dat_ge1$p-dat_ge1$mean-1.96*dat_ge1$se)
dat_ge1$p_std_1960_1979_max=exp(dat_ge1$p-dat_ge1$mean+1.96*dat_ge1$se)

figure51 <-  
		ggplot(dat_ge,aes(x=year,y=p_std_1960_1979))+
		geom_line(aes(colour=area,lty=area),lwd=1.3)+
		geom_point(aes(colour=area,fill=area,shape=area),size=3)+
		geom_line(data=dat_ge1, aes(x=year,y=p_std_1960_1979,colour=area))+
		#ggtitle("Recruitment overview glass eel series")+
		scale_colour_brewer(name="area",palette="Set1")  +
		#annotate("text",x=dat$year[length(dat$year)-2],y=datEE$p_std_1960_1979[length(datEE$p_std_1960_1979)],size=5,label=labelEE)+
		#annotate("text",x=dat$year[length(dat$year)-2],y=datNS$p_std_1960_1979[length(datNS$p_std_1960_1979)],size=5,label=labelNS)+		
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 10, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'),
				legend.position=c(.8,.9))+geom_ribbon(aes(ymin=p_std_1960_1979_min,ymax=p_std_1960_1979_max,fill=area),alpha=.3)

ggplot(dat_ge1) 

datNS <- dat_ge %>%filter(area=="North Sea") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datNS)
o1<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011,2014)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o1)
datEE <- dat_ge %>%filter(area=="Elsewhere Europe") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datEE)
o2<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011,2014)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 500, display=TRUE))
plot(o2)

datNS <- dat_ge %>%filter(area=="North Sea") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datNS)
o11 <- segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o11)
datEE <- dat_ge %>%filter(area=="Elsewhere Europe") %>% dplyr::select(year, p_std_1960_1979)
out.lm<-lm(log(p_std_1960_1979)~year,data=datEE)
o21<-segmented.lm(out.lm,seg.Z=~year,psi=list(year=c(1980,2011)), 
		control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
plot(o21)
AIC(o1, o11, o2, o21)
```

```{r model_diagnostics, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#####deprecated
# summary(model_ge_area)
# influence_plot
require(boot)
gey <- glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959&!is.na(glass_eel_yoy$value_std),]
gey$E <- resid(model_ge_area) # working residuals
gey$P=predict(model_ge_area)
plot(coefficients(model_ge_area)[grep("North Sea",names(coefficients(model_ge_area)))],type="l")
points(log(datNS$p_std_1960_1979)+4,type="l",col="red")
plot(gey$E~gey$P)

# Three ways of getting the diagnostic graph of residuals
glm.diag.plots(model_ge_area)
plot(model_ge_area,which=1)
panel.smooth(gey$P,gey$E,col="black",col.smooth="red")
library(lattice)
panel.smoother <- function(x, y) {
	panel.xyplot(x, y) # show points 
	panel.loess(x, y,col.line="red")  # show smoothed line 
	panel.abline(h=0)
}
panel.smoother2 <- function(x, y) {
	panel.xyplot(x, y) # show points 
	panel.loess(x, y,col.line="red")  # show smoothed line 
	panel.abline(h=-0.2)
}
mga_diag <- glm.diag(model_ge_area)
gey$res <- mga_diag$res
show.settings()

xyplot(res~P, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
xyplot(res~year, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother2,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
abline(h=0)
xyplot(res~P|area, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
xyplot(res~P|site, data=gey,scales=list(cex=.8, col="black"),
		panel=panel.smoother,
		xlab="Predicted", ylab="residuals", 
		main="Jacknife deviance residuals agains the fitted value")
# un rsidu / carte par annee

# pour aller chercher les stations en 3035
options(sqldf.RPostgreSQL.user = cred$user,  
			sqldf.RPostgreSQL.password = passwordwgeel,
			sqldf.RPostgreSQL.dbname = cred$dbname,
			sqldf.RPostgreSQL.host = cred$host, #getInformation("PostgreSQL host: if local ==> localhost"), 
			sqldf.RPostgreSQL.port = cred$port)
locxy_3035 <- sqldf("select ser_id,st_x(the_geom) as X, st_y(the_geom) as Y from ts.t_location_loc where loc_tyl_code='Recruit'")
gey <- merge(gey,locxy_3035,by="ser_id",all.x=TRUE,all.y=FALSE)
Gey <- gey #spatial data frame
coordinates(Gey) <- c("x","y")
# dev.size("px") to check right dimensions
#png(file=str_c(imgwd,"/resid_bretagne.png"), width=672,height= 389)

#bb <- elargit(bb,0.01,0.01)

#frequire(latticeExtra) # a + as.layer(b) pour mettre deux graphiques
# but for now I don't have missing data there
emu_c=readShapePoints(str_c(shpwd,"/","t_emuagreg_ema_point_3035.shp")) # a spatial object of class sp
# this corresponds to the center of each emu.
wisesp=readShapePoly(str_c(shpwd,"/","rbd_f1v3_3035.shp")) # a spatial object of class sp
# this is the map showing the "missing parts", to be placed behind the others
country_c=readShapePoints(str_c(shpwd,"/","t_country_coun_3035"))# a spatial object of class sp
# this is the map of coutry centers, to overlay points for each country
emusp0=readShapePoly(str_c(shpwd,"/","t_emuagreg_ema_3035")) # a spatial object of class sp
years <- 1960:2019
bb <- bbox(emusp0)
# loop to create all the graphs
for (year in years){
	#trellis.device(device="png",filename=str_c(imgwd,"/resids/",year,".png"))
	png(filename=str_c(imgwd,"/resids/",year,".png"),width=600, height=500)
	bb <- bubble(Gey[Gey@data$year==year,], "E",col=c("red","green"),main=str_c(year),
			xlab="",ylab="",
			do.sqrt = FALSE,
			sp.layout=list("sp.polygons", emusp0,    first = FALSE)
	) 		
	print(bb)
	dev.off()
}
# 
model_ge_area <- gls(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
		subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959 ,maxit=300)

lmer(value_std~year_f:area+site,data=glass_eel_yoy,family=Gamma(link=log),
		subset=glass_eel_yoy$value>0 & glass_eel_yoy$year>1959)

#library(nlme)
glass_eel_yoy$lvalue_std=log(glass_eel_yoy$value_std)
M.lm <- gls(lvalue_std~site,data=glass_eel_yoy)

vf1Fixed <- 
		
		M.gls1  <- glmmPQL(value_std~year_f:area+site,
				data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
				random = ~ 1 | site,
				weights = varIdent (form = ~ 1 | site) ,
				family=Gamma(link=log)
		)
M.gls1  <- glmmPQL(value_std~year_f:area+site,
		data=glass_eel_yoy[glass_eel_yoy$value>0 & glass_eel_yoy$year>1959,],
		random = ~ 1 | site,
		family=Gamma(link=log)
)
# prediction for lough neagh
# historical data
#glass_eel_yoy2=wger[wger$lifestage!="yellow eel" ,] #glass eel and yoy
#model_ge_area2=glm(value_std~year_f:area+site,data=glass_eel_yoy2[glass_eel_yoy2$value>0 ,],
#	family=Gamma(link=log), maxit=300)
#
#newdata <- expand.grid(year_f=levels(glass_eel_yoy2$year_f),site="Bann",area="Elsewhere Europe")
#newdata <- newdata[as.numeric(as.character(newdata$year_f))>1922,]
#newdata$P=predict(model_ge_area2,type="response",newdata=newdata)
#newdata$year <- as.numeric(as.character(newdata$year_f))
#
#plot(newdata$year,newdata$P, type="b",col="black",xlab="year",ylab="standardized value")
#gey2 <- glass_eel_yoy2[glass_eel_yoy2$site=='Bann',]
#gey2 <- gey2[order(gey2$year),]
#points(gey2$year,gey2$value_std, type="b",col="grey40",lty=2,pch=18)
#legend("topright",col=c("black","grey20"),lty=c(1,2),pch=c(1,18),legend=c("predicted for Bann","Bann (observed)"))
#write.table(gey2,file=str_c(datawd,"Bann_data.csv"),sep=";")
#write.table(newdata,file=str_c(datawd,"Bann_predictions.csv"),sep=";")
```

```{r model_for_yellow_eel, echo=FALSE, eval=TRUE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~
######################################"
#~yellow eel migrant analysis
######################################"~
# 2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~2~~~

print("Analysis for yellow eel")
area_year_older=table(older$year,older$area)
selection_summary$nb_for_yellow_eel_glm <- length(unique(older$site))
table(older$geo)
print("stations selected for analysis")
unique(older$site)
model_older=glm(value_std ~ year_f + as.factor(site),
		data = older,
		family = Gamma(link=log),
		subset = older$value >0 &
				older$year > 1949 & older$year <=CY-1,
		maxit = 300)
# parteen was removed but is no longer among the series
summary(model_older)
#plot(model_older)
anova(model_older,test="F")

dat_ye=expand.grid(year_f=model_older$xlevels$year_f,
		site=model_older$xlevels$`as.factor(site`[1])
dat_ye$year=as.numeric(as.character(dat_ye$year))

#predicting --------------------------------------------------------------------------------------------

# in the log scale
dat_ye$p=predict(model_older,newdata=dat_ye)
dat_ye$se=predict(model_older,newdata=dat_ye,se.fit = TRUE)$se.fit

#standardising prediction to 1960-1979 level -----------------------------------------------------------
# 2 options mean or geomean

#in the logscale we remove the arithmetic mean to standardise prediction relatively to
#1960-1980 
dat_ye$mean_1960_1979=mean(dat_ye[dat_ye$year>=1960&dat_ye$year<1980,"p"])
dat_ye$value_std_1960_1979=exp(dat_ye$p-dat_ye$mean_1960_1979)
dat_ye$yellow_eel_min=exp(dat_ye$p-dat_ye$mean-1.96*dat_ye$se)
dat_ye$yellow_eel_max=exp(dat_ye$p-dat_ye$mean+1.96*dat_ye$se)

# Table --------------------------------------------------------------------------------------------

yy0 <- dat_ye[,"value_std_1960_1979",drop = FALSE]
rownames(yy0) <- dat_ye$year

yy <- split_per_decade(data=yy0)
yy <- 100*round(yy,2)
nothing <- latex(yy,
		rowlabel="",
		rowlabel.just="c",
		where="hptb",
		col.just     =strsplit("c c c c c c c c c c c c c c c", " ")[[1]],
		landscape=FALSE,
		label="table_glm_yellow",
		caption=str_c("GLM $yellow~eel \\sim year + site $ geometric means of predicted values for ",selection_summary$nb_series_older, " yellow eel series, values given in percentage of the 1960-1979 period."),	
		file= str_c(tabwd,"/table_glm_yellow.tex"))

# Figures -------------------------------------------------------------------------------------------

dat_ye$time =as.Date(strptime(paste(dat_ye$year,"-01-01",sep=""),format="%Y-%m-%d"))
g <- ggplot(dat_ye,aes(x=time,y=value_std_1960_1979)) 
figure6_without_log_scale <- g+ geom_line(lwd=1, color="darkolivegreen")+ geom_point(color="khaki3")+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+	
		theme_bw()+
		geom_hline(yintercept=1,linetype=2)+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.6,fill="darkolivegreen2")+
		xlab("year")+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))#+
#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="grey20")
save_figure("figure6_without_log_scale",figure6_without_log_scale,600,480)


figure6_advice_YY<- ggplot(dat_ye,aes(x=year,y=value_std_1960_1979 * 100))  +
		scale_y_continuous("Std. GLM recruitment")+	
		geom_hline(yintercept=100,linetype=2)+
		geom_ribbon(aes(ymin=yellow_eel_min*100,ymax=yellow_eel_max*100, fill="area"), show.legend=FALSE, alpha = .3)+
		geom_line(lwd=1, aes(col="area"), show.legend=FALSE)+ 		
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
		theme_ICES_plots("Recruitment") + ggtitle("Yellow eel recruitment index")

figure6_advice_YY
save_figure("figure6_advice_YY",figure6_advice_YY,600,480, pdf = FALSE)


figure_advice <- (figure5_advice_NS +
  figure5_advice_EE) /
  (figure6_advice_YY + patchwork::plot_spacer())

save_figure("figure_advice",figure_advice,1200,800, pdf = FALSE)

figure6_without_log_scale
figure6_without_log_scale_black <- g+geom_line(lwd=1,color="white")+ 
		geom_point(color="white")+
		scale_y_continuous(expression(frac(p,bar(p)[1960-1979])))+
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.3,fill="darkolivegreen2")+
		#stat_smooth(method="lm",formula=y ~ ns(x,4),lty=2, size=0.8,alpha=0.3,col="turquoise1") +
		theme_black()
figure6_without_log_scale_black
save_figure("figure6_without_log_scale_black",figure6_without_log_scale_black,600,480)
figure6 <- g+geom_line(lwd=1,color="darkolivegreen")+geom_point(color="khaki3")+
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' (log scale)'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%")) +
		geom_ribbon(aes(ymin=yellow_eel_min,ymax=yellow_eel_max),alpha=.3,fill="darkolivegreen2")+
		xlab("year")+
		theme_bw()+
		theme(legend.box =NULL,
				legend.key = element_rect(colour = NA, fill = 'white'),
				legend.text = element_text(size = 8, colour = 'black'), 
				legend.background = element_rect(colour = NA, fill = 'white'))
#stat_smooth(method="lm",formula=y ~ ns(x,4), lty=2, size=0.8,alpha=0.3,col="grey20")
figure6
save_figure("figure6",figure6,600,480)

# Final save ----------------------------------------------------------------------------------------

write.table(synthesis,file=str_c(outputdatawd,"glm_results_yellow.csv"),sep=";")
dat_ye <- dat_ye[,c("year","p","se","mean_1960_1979","yellow_eel_min","yellow_eel_max","value_std_1960_1979")]
selection_summary$five_year_averagey <- dat_ye %>% filter(year>CY-5) %>% dplyr::select(c(year,value_std_1960_1979)) %>% colMeans() %>% round(digits=3)
selection_summary$dat_ye <- 
		dat_ye %>% 
		filter(year<=CY-2,year>CY-7) %>% 
		dplyr::select(c(year,value_std_1960_1979)) %>% 
		colMeans() %>% 
		round(digits=3)


#colnames(dat_ye)  <- c("year","geomean_p_std_1960_1979") 
save(dat_ye,file=paste0(outputdatawd,"dat_ye.Rdata")) 
save(dat_ye,file=paste0(shinywd,"dat_ye.Rdata")) 

if (file.exists(str_c(outputdatawd,"glm_results_glass_and_yellow.xlsx"))) unlink(str_c(outputdatawd,"glm_results_glass_and_yellow.xlsx"))
openxlsx::write.xlsx(x=list("Glass eel"=data.frame(
						"year"=synthesis$year,
						"EE_minCI_percent"=100*synthesis$EEminCI,
						"EE_percent"=100*synthesis$"Elsewhere Europe",
						"EE_maxCI_percent"=100*synthesis$EEmaxCI,
						"NS_minCI_percent"=100*synthesis$NSminCI,
						"NS_percent"=100*synthesis$"North Sea",
						"NS_maxCI_percent"=100*synthesis$NSmaxCI
				), "Yellow eel"= data.frame("year"=dat_ye$year,
						"Y_minCI_percent"=100*dat_ye$yellow_eel_min,
						"Y_percent"=100*dat_ye$value_std_1960_1979,
						"Y_maxCI_percent"=100*dat_ye$yellow_eel_max)),
		file=str_c(outputdatawd,"glm_results_glass_and_yellow.xlsx"),
		row.names=FALSE)

# saving yellow_eel_pred for shiny ---------------------------------------------------------------------
yellow_eel_pred <- dat_ye

save(yellow_eel_pred,file=paste0(outputdatawd,"yellow_eel_pred.Rdata"))
save(yellow_eel_pred,file=paste0(shinywd,"yellow_eel_pred.Rdata"))
```

```{r test_period, echo=FALSE, eval=FALSE, results="hide", warning = FALSE, message = FALSE, error=FALSE, fig.show='hide'}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%************************************************************************************
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

glass_eel_yoy$site <- as.factor(glass_eel_yoy$site)
# we select all series that are already included (removed -1)

load(file=str_c(shinywd,"inclusion.Rdata"))
# todo redo this too tired now
inner_join(glass_eel_yoy, 
				inclusion %>% filter(sgl_year!=-1), 
				by=(c("ser_id"="sgl_ser_id"))) %>%
		dplyr::select(sgl_year,area,site)%>%
		distinct() %>%
		mutate(number=1)%>%
		dplyr::select(-site)%>% 
		group_by(sgl_year,area)%>%
		mutate(number=sum(number))
#unique(glass_eel_yoy$ser_id)[!unique(glass_eel_yoy$ser_id)%in%inclusion$sgl_ser_id  ]
run_exclude_before <- function(the_year){
	load(file=str_c(outputdatawd,"dat_ge.Rdata"))
	dat_ge_reference <- dat_ge
	glass_eel_yoy_included <- inner_join(glass_eel_yoy, 
			inclusion %>% filter(sgl_year!=-1), 
			by=(c("ser_id"="sgl_ser_id"))) 
	if (!all(unique(glass_eel_yoy$ser_id)%in% unique(glass_eel_yoy_included$ser_id ))){
		warning("ser_id ",unique(glass_eel_yoy$ser_id)[!unique(glass_eel_yoy$ser_id)%in% 
								unique(glass_eel_yoy_included$ser_id )]," not in inclusion")
	}
	glass_eel_yoy_included <- glass_eel_yoy_included	%>% 
			dplyr::filter(sgl_year <= the_year)
	model_ge_area <- glm(value_std~year_f:area+site,
			data=glass_eel_yoy_included[glass_eel_yoy_included$value>0 & glass_eel_yoy_included$year>1959,],
			family=Gamma(link=log), maxit=300)
	dat_ge <- expand.grid(year_f=model_ge_area$xlevels$year_f,area=model_ge_area$xlevels$area,
			site=model_ge_area$xlevels$site[1])
	dat_ge$year <- as.numeric(as.character(dat_ge$year_f))
	dat_ge$p <- predict(model_ge_area, newdata=dat_ge)
	dat_ge$se <- predict(model_ge_area,newdata=dat_ge,se.fit=TRUE)[["se.fit"]]
	mean_1960_1979 <- aggregate(dat_ge[dat_ge$year<1980,"p"], 
			list(dat_ge[dat_ge$year<1980,"area"]),
			mean)
	names(mean_1960_1979) <- c("area","mean")	
	dat_ge <- merge(dat_ge,mean_1960_1979,by="area")
	dat_ge$p_std_1960_1979 <- exp(dat_ge$p-dat_ge$mean)
	dat_ge$p_std_1960_1979_min <- exp(dat_ge$p-dat_ge$mean-1.96*dat_ge$se)
	dat_ge$p_std_1960_1979_max <- exp(dat_ge$p-dat_ge$mean+1.96*dat_ge$se)
	result <- list()
	result$year <- the_year
	result$nbsite <- length(model_ge_area$xlevels$site)
	result$dat_ge <- dat_ge
	result$delta <- dat_ge_reference$p_std_1960_1979 - dat_ge$p_std_1960_1979
	return(result)
}
res <- mapply(run_exclude_before, the_year=c(2010:2020), SIMPLIFY=FALSE)
require(tidyr)

delta <- lapply(res,function(X)X[["delta"]])
delta <- as.data.frame(delta)
colnames(delta)<-2010:2020
delta$year <- dat_ge$year
delta$area <- dat_ge$area
res_delta <-delta %>% pivot_longer(cols=contains("2"), names_to="year_included",values_to="delta")

g<- ggplot(res_delta)+
		geom_line(aes(x=year,y=delta,color=year_included))+
		facet_wrap( ~area) +
		theme_bw()
figure_inclusion_1<- g
save_figure("figure_inclusion_1",figure_inclusion_1,600,480)

pred <- lapply(res,function(X)X[["dat_ge"]]$"p_std_1960_1979")
pred <- as.data.frame(pred)
colnames(pred)<-2010:2020
pred$year <- dat_ge$year
pred$area <- dat_ge$area
res_pred <-pred %>% pivot_longer(cols=contains("2"), names_to="year_included",values_to="pred")
matplot(pred,ylim=c(0,0.2))
g<-ggplot(res_pred)+geom_line(aes(x=year,y=pred,color=year_included))+ 
		facet_wrap( ~area) +
		scale_y_log10(name=expression(frac(p,bar(p)[1960-1979])~' log scale'),
				#limits=c(0.005,10),
				breaks=c(0.01,0.1,1,10),
				labels=c("1%","10%","100%","1000%"))+
		theme_bw()
figure_inclusion_2 <- g
save_figure("figure_inclusion_2",figure_inclusion_2,600,480)
```

```{r diagramme,echo=FALSE,eval=TRUE,results="hide", warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
if(!require(DiagrammeR)) install.packages("DiagrammeR") ; require(DiagrammeR)
if(!require(magrittr)) install.packages("magrittr") ; require(magrittr)
if(!require(DiagrammeRsvg)) install.packages("DiagrammeRsvg") ; require(DiagrammeRsvg)
if(!require(rsvg)) install.packages("rsvg") ; require(rsvg)

node_list <- create_node_df(n=16,		
		type=rep(c("box",
						"value"), 16
		),
		label=c(
				str_c("Series available in ", CY),
				selection_summary$nb_series_init,
				"used",
				selection_summary$nb_series_final,
				"G + GY",
				selection_summary$nb_series_glass_eel,
				"Y",
				selection_summary$nb_series_older,
				"NS",
				as.numeric(selection_summary$nb_series_glass_eel_per_area[selection_summary$nb_series_glass_eel_per_area$area=="Elsewhere Europe",2]),
				"EE",
				as.numeric(selection_summary$nb_series_glass_eel_per_area[selection_summary$nb_series_glass_eel_per_area$area=="North Sea",2]),
				"< 10 Y",
				as.numeric(selection_summary$ser_qal_id_count[selection_summary$ser_qal_id_count$ser_qal_id==0,"len"]),
				"discarded",
				as.numeric(selection_summary$ser_qal_id_count[selection_summary$ser_qal_id_count$ser_qal_id==3,"len"])
                
		),
		color=c(rep("green",12),"orange","orange","red","red"),
		style="filled",
		shape=rep(c("plaintext","circle"),8),
		value=1:16,
		fixedsize =FALSE
)

edge_list<-create_edge_df(
		from=c(1,2,3,4,5,4,7,2 ,2 ,13,15,6,6,11,9),
		to=  c(2,3,4,5,6,7,8,13,15,14,16,9,11,12,10),
		rel="a",
		label=rep(" ",15),
		color=rep("grey",15),
		length=100)



igraph1 <- create_graph( attr_theme = NULL)

igraph2 <- igraph1%>%
		add_nodes_from_table(table = node_list, 
				type_col=type,
				label_col=label) 
#igraph2 %>% get_node_df()
# Add the edges to the graph
igraph3 <-igraph2 %>%
		add_edges_from_table(
				table = edge_list,
				from_col = from,
				to_col = to,
				from_to_map = id_external
		)

render_graph(igraph3, layout="tree")

render_graph(igraph3, layout="tree") %>% 
    export_svg %>%  charToRaw %>% rsvg_png(str_c(imgwd,"series_selection.png"))

```




# Recruitment
In the `r CY` Data Call, data on recruitment up to
`r CY`, fishery landings, recreational landings, aquaculture
production, restocking, yellow eel abundance and silver eel abundance, including
biometry were requested. The call also required the provision of associated
metadata.

## Data sources

In this section, the latest trends in glass and yellow eel recruitment are
adressed. The time-series data are derived from fishery-dependent sources (i.e.
landings records) and from fishery-independent surveys across much of the
geographic range of European eel. There are three types of series:

-   glass eel (G), age 0+cohort,
-   a mixture of glass eel and yellow eel dominated by recruits from the same
    year (GY),
-   and yellow eel (Y) recruiting to continental habitats.
 
The yellow eel series might consist of yellow eel of several ages (e.g. in the Baltic with mean age up to 6). The glass eel recruitment
time-series have been grouped into two geographical areas: "continental North
Sea" (NS) and "Elsewhere Europe" (EE) (Figure \@ref(fig:figure1)). Since previous
analyses by the working group (ICES, 2010, p19; Bornarel et al. (2017)) have
shown a different trend between the two sets. This is mostly due to a more
pronounced decline of the North Sea series compared to the Elsewhere Europe area
during the 1980s.

The WGEEL has collated information on recruitment from `r selection_summary[["nb_series_init"]]`
time-series. Some time-series date back to the beginning of 20th century.

```{r figure1, fig.cap="Map of recruitment sampling stations currently used to build the GLM trend models: white dots G = glass eel; grey dots GY = glass + yellow eel; yellow triangles Y = yellow eel. Green = North Sea, Blue = Elsewhere Europe", fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"singlemap.png"))
```



##	Details on data selection and processing 

Out of the `r selection_summary[["nb_series_init"]]` series that were compiled in the Data Call,
`r selection_summary[["nb_series_final"]]` were selected and used in the analysis (Figure
\@ref(fig:figure4), Table \@ref(tab:tabsummaryselection), Annex 9, Tables 1 and
2). The selection is based on three criterion:

1.  First, if there are two or more series from the same location, i.e.they are
    not independent, only one series is kept. For instance, the longest of two
   series has been kept for the Severn (Severn EA, a total of all the glass eel
   fisheries for England and Wales) while the second series (Severn HMRC) has
   been dropped from the list, as it was considered a duplicate being based on
   the same fishery. <!--The series left out following this rule are :
   `r selection_summary$sites_summary$qal_3`
   [TODO SELECT AMONG THOSE with qal_id 3 THE DUPLICATES, you may need to read ser_qal_comment
   for more information currently  BroGY(GB), EmsBGY(DE), FarpGY(DE), FlaGY(GB), SeHMG(GB)]-->
   
2.  The second rule is to exclude a series from the analysis when it is less
    than ten years long. If there are missing years, or years excluded for data
    quality reasons, the data series will be included when the total number of
    "good" years of data meets the 10 year criterion. Within any series,
    individual annual data can be excluded from the analysis where a one-off
    problem is identified which negates the value as an index for that year,
    such as a major reduction in effort (e.g.Covid or other effort related
    restriction). <!--The series left out because they don't meet the
   10 years criteria are :  `r selection_summary$sites_summary$qal_0` -->
   
3. Finally, it was decided to discard recruitment series that were obviously
   biased by restocking (e.g. Farpener Bach in Germany). <!--The series left out
   for that reason are `r selection_summary$sites_summary$qal_3` [ TODO among those
   with qal_id 3 select  HHKGY(DE), MeusY(BE)]
The following series have been left out due to the reasons mentioned above: 
***************************************************************

[There should be nothing here :
`r selection_summary$sites_summary$qal_4`  
in the above list there may be duplicated series (not used for reasons 1, and/or 3 at the same time for example), you must delete the list of the previous items and group them here to avoid duplications,

*******************************************************************
-->

This year, the series BretGY fulfilled the criterion to be integrated. However,
it was decided to postpone its integration to an upcoming benchmark exercise to
promote the stability of the dataset.

See Annex 9, table 3 for the reasons why the series have been excluded from the
recruitment analysis.





```{r tabsummaryselection, tab.cap=str_c("Summary of the number of series that have been received (", CY, " Data Call) and incorporated (kept) for the determination of the recruitment index by area and stage. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel Area: EE = Elsewhere Europe, NS = North Sea."), warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
data.frame(`Life-stage`=c(rep("G", 3),
                          rep("GY", 3),
                          "Y",
                          "TOTAL"),
           "Area" = c(rep(c("EE","NS","Total"), 2),
                      "Total",
                      ""),
           Submitted = c(c(nrow(printstatseriesGEE),
                          nrow(printstatseriesGNS),
                          nrow(printstatseriesGEE) +nrow(printstatseriesGNS)),
                        c(nrow(printstatseriesGY |> filter(area=="EE")),
                          nrow(printstatseriesGY |> filter(area=="NS")),
                          nrow(printstatseriesGY |> filter(area=="EE")) + nrow(printstatseriesGY |> filter(area=="NS"))),
                        nrow(printstatseriesY),
                        nrow(R_stations)),
          Kept = c(c(nrow(printstatseriesGEE |> filter(kept == 1)),
                          nrow(printstatseriesGNS |> filter(kept == 1) ),
                          nrow(printstatseriesGEE|> filter(kept == 1)) +nrow(printstatseriesGNS|> filter(kept == 1))),
                        c(nrow(printstatseriesGY |> filter(area=="EE" & kept == 1)),
                          nrow(printstatseriesGY |> filter(area=="NS" & kept == 1)),
                          nrow(printstatseriesGY |> filter(area=="EE" & kept == 1)) + nrow(printstatseriesGY |> filter(area=="NS" & kept == 1))),
                        selection_summary$nb_series_older,
                        selection_summary$nb_series_final)
                        
                        
           ) |>
  flextable() |>
  merge_v(j = 1, part = "body") |>
  flextable::align(part = "all", align = "left") |>
  autofit() |>
  bold(bold = TRUE, part = "header") |>
  flextable2ICES()
```

<br>

Among the time-series based on trap indices, some have reported preliminary data 
for `r CY` as their trapping season had not finished. As
usual, the indices given for `r CY` (current year) must be
considered as provisional, especially those for yellow eel:

-   `r format(selection_summary[["nCY"]], scientific = TRUE)` time-series were updated to
    `r CY` (`r format(selection_summary[["nCYG"]], scientific = TRUE)` G,
    `r format(selection_summary[["nCYGY"]], scientific = TRUE)` GY, and `r format(selection_summary[["nCYY"]], scientific=TRUE)` Y) (Annex 9;
    Table 5).
-   On the other hand, `r format(selection_summary[["nCYm1"]],scientific=TRUE)` time-series
    (`r format(selection_summary[["nCYm1G"]],scientific=TRUE)` G, `r format(selection_summary[["nCYm1GY"]],scientific=TRUE)` GY, and
    `r format(selection_summary[["nCYm1Y"]], scientific=TRUE)` Y) were updated only to `r CY-1`
    (Annex 9; Table 6). -
-   `r format(selection_summary[["nseries_lost"]], scientific=TRUE)` time-series have been stopped or not updated
    beyond `r CY-2`.

Some have stopped reporting either because of a lack of recruits in case of the
fishery-based surveys (Ems in Germany,stopped in 2001; Vidaa in Denmark, stopped
in 1990), a lack of financial support (the Tiber in Italy, 2006) or the
introduction of quota from 2008 to 2011 that has disrupted the five
fishery-based French time-series.


```{r figure2, fig.cap=paste0("Schematic showing the recruitment series received (", CY," Data Call)  by type and region, and numbers selected for analysis. Y = Yellow eel, G = Glass eel, GY = mixed Glass and yellow eel. NS = North Sea (including Baltic) EE = Elsewhere Europe regions"), fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"series_selection.png"))
```

The number of time series available between life stage and regions does not follow an
even distribution. It is influenced by factors including variations in the behaviour
of eel, traditions of fishery and usage of eel, and the history of scientific
investigation and eel management (Figure \@ref(fig:figure3) &
\@ref(fig:figure4)). Thus, most of the glass eel series come from the Atlantic
while the yellow eel series come from the Baltic and the North Sea. 

<!--The maximum number of glass eel and young yellow eel time series was `r selection_summary[["nbmaxglasseel"]]` in `r max(as.numeric(selection_summary[["yearmaxglasseel"]]))` dropping to
`r selection_summary[["nbcurrentglasseel"]]` in `r CY`, while the number of older yellow eel peaked at`r selection_summary[["nbmaxyellow"]]` in
`r max(as.numeric(selection_summary[["yearmaxyellow"]]))`before falling to [["nbcurrentyellow"]]`in `r CY`, (Fig.  2.3)

In `r CY`, [XX DO THIS MANUALLY] new series were added to the recruitment trend
analysis: [XX] GE ([XXX]) and [XX] GY ([XXX]).
-->

```{r figure3, fig.cap=str_c("Temporal trends in the number of data points (a value provided by a given time series for a given year) that have been kept to perform the recruitment analysis per stage. The number of ", CY, " series is not final as the year has not yet ended and there are still series to be reported."), fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure2.png"))
```

```{r figure4, fig.cap=str_c("Temporal trends in the number of data points (a value provided by a given time series for a given year) that have been kept to perform the recruitment analysis per stage and area. The number of ", CY, " series is not final as the year has not yet ended and there are still series to be reported."), fig.width=16/254, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
if (file.exists(paste0(imgwd,"series_no_area.png")))
  knitr::include_graphics(paste0(imgwd,"series_no_area.png"))
```


## Trend in glass eel commercial exploitation rate

The ratio between reported commercial landings of glass eels and the recruitment
index in Elsewhere Europe provides a relative measure of exploitation rate
(Figure \@ref(fig:fishingmortality)). The analysis was restricted to the
"Elsewhere Europe" area since no commercial glass eel fisheries took place in
the North Sea area in recent years. Moreover, the analysis was restricted to the
post-2000 period for which data are more comprehensive. The exploitation rate
for glass eels has decreased after the implementation of the Eel Regulation in
2009 (Fig, 5) (data for 2009 were removed as France, which accounts for a
significant part of the landings, did not report data for that year) and
remained relatively stable since then. After a peak in 2024, the currently
estimated higher recruitment for 2025 contributes to the lowest exploitation
rate. The exploitation rate can only be estimated for glass eel : since for
yellow eel standing stock and silver eels no reliable abundance estimates are
available to allow comparison with landings

```{r fishingmortalitydata,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, results = "hide"}
pwd = passwordwgeel = password = cred$password
con = dbConnect(RPostgres::Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=passwordwgeel)
query="select sum(eel_value),eel_year,eel_emu_nameshort,eel_cou_code from datawg.t_eelstock_eel where eel_typ_id=4 and eel_qal_id=1 and eel_lfs_code in ('G','GY') and eel_year >= 2000 group by eel_year, eel_emu_nameshort,eel_cou_code "
landings=dbGetQuery(con,query) %>%
  na.omit() %>%
  mutate(area=ifelse(eel_cou_code %in% c("DK","NO","NL","DE") | eel_emu_nameshort %in% c("GB_Scot","GB_Nort","GB_Humb","GB_Angl","GB_Tham"),
                     "North Sea","Elsewhere Europe"))
emusNS <-landings %>%
  filter(area=="North Sea") %>%
  arrange(eel_emu_nameshort) %>%
  dplyr::select(eel_emu_nameshort) %>%
  unique() %>%
  dplyr::pull() %>%
  paste(collapse=", ")
emusEE <-landings %>%
  filter(area!="North Sea") %>%
  arrange(eel_emu_nameshort) %>%
  dplyr::select(eel_emu_nameshort) %>%
  unique() %>%
  dplyr::pull() %>%
  paste(collapse=", ")
                

landings <- landings %>%
  dplyr::group_by(eel_year,area) %>%
  dplyr::summarize(landings=sum(sum, na.rm=TRUE)) %>%
  dplyr::rename(year_f=eel_year) %>%
  ungroup()

rates <- left_join(dat_ge%>% mutate(year_f=as.numeric(as.character(year_f))),landings ) %>%
  filter(year_f >= 2000) %>%
  filter(area=="Elsewhere Europe") %>%
  mutate(landings=ifelse(year_f==2009, NA, landings))

dbDisconnect(con)
```





```{r fishingmortality, eval=TRUE, fig.cap="Reported G and GY commercial landings divided by recruitment index for EE (including landings reported in EMUs ES_Astu, ES_Cant, ES_Cata, ES_Minh, ES_Mino, ES_Vale, FR_Adou, FR_Arto, FR_Bret, FR_Garo, FR_Loir, FR_Sein, FR_total, GB_Dee, GB_NorW, GB_Seve, GB_SouE, GB_SouW, GB_Wale, GB_total, IT_Lazi, IT_Tosc, IT_Vene). The resulting ratio is a relative proxy of the exploitation rate that informs on trends in fishing mortality. Landings data from 2000 are not available for GB. Year 2009 was removed since France, which accounts for a significant part of the landings, did not report data for this year.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}

g <- ggplot(rates,aes(x=year_f)) +geom_ribbon(aes(ymin=landings/p_std_1960_1979_max, 
                                             ymax=landings/p_std_1960_1979_min),
                                         alpha=.3) +
  geom_line(aes(y=landings/p_std_1960_1979))+
  geom_point(aes(y=landings/p_std_1960_1979))+
  xlab("") + 
  scale_x_continuous(breaks=seq(2000, CY, 3), labels=seq(2000, CY, 3))+
  ylab("Reported landings divided by glass eel recruitment index") +
  theme_bw()


save_figure("exploitation_rates_GE",g,600,480, pdf = FALSE)
knitr::include_graphics(paste0(imgwd,"exploitation_rates_GE.png"))


```
 


## GLM based trend

The WGEEL recruitment index used in the ICES Annual Stock Advice is fitted using
a GLM with a Gamma distribution and a log link:
$glasseel \sim year:area + site$, where :

-   $glasseel$ is individual glass eel time-series including both pure G series
    and those identified as a mixture of glass and yellow eel (G+Y),
-   $site$ is the site monitored for recruitment,
-   $area$ is either the continental North Sea or Elsewhere Europe, and
-   $year$ is the year coded as a categorical value. For yellow eel time-series,
    only one total area estimate is provided: $yellow\ eel \sim year + site$.

The trend is hindcasted using the predictions from 1960 onwards for
`r selection_summary$modelge$nbsite` glass eel time-series and from 1950 onwards for
`r selection_summary$modelolder$nbsite` yellow eel time-series. Some zero values have been
excluded from the GLM analysis: `r nrow(selection_summary$modelge$value_excluded_zero)` for the glass eel
model and `r nrow(selection_summary$modelolder$value_excluded_zero)` for the yellow eel model. This treatment has
been tested and has no effect on the trend (ICES, 2017).

The predictions are given in reference to the geometric mean of the 1960-1979
period.

Analyses of provisional `r CY` data show recruitment as a
percentage of 1960-1979 levels at `r round(100*synthesis[nrow(synthesis),"North Sea"], digits =1)` % in the North Sea
and `r round(100*synthesis[nrow(synthesis),"Elsewhere Europe"], digits =1)` % in Elsewhere Europe (Figure \@ref(fig:figure5),
Table \@ref(tab:tableglmglasseel)).

```{r tableglmglasseel,echo=FALSE,eval=TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,tab.cap=str_c(" Annual WGEEL recruitment index for the continental North Sea and Elsewhere Europe. The index was estimated using a GLM (glasseel  area : year + site) fitted on ",selection_summary$nb_series_glass_eel,"  time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. Number of series, ",pull(selection_summary$nb_series_glass_eel_per_area[1,1]), "=", pull(selection_summary$nb_series_glass_eel_per_area[1,2]), ", ", pull(selection_summary$nb_series_glass_eel_per_area[2,1]),"=", pull(selection_summary$nb_series_glass_eel_per_area[2,2]),". The predictions (p) have been scaled to $\\bar{p}_{1960-1979}$.")}

columns = names(gg)
years = rep(196:202,each=2)*10
autofit(flextable(gg%>% setNames(1:ncol(gg)) %>%
  tibble::rownames_to_column(" ")) %>%
  delete_part(part = "header") %>%
  add_header_row(values=c("",years),top=FALSE) %>%
  merge_h(part="header") %>%
  add_header_row(values=c("",columns),top=FALSE) %>%
  bold(bold = TRUE, part = "header") %>%
  theme_booktabs(x, bold_header = FALSE)) |>
  flextable2ICES()
```



```{r figure5, fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.cap=str_c("WGEEL glass eel recruitment index for the continental North Sea and Elsewhere Europe series with 95% confidence intervals updated to ", CY,". The index was estimated using a GLM (glasseel  area : year + site) fitted on ",selection_summary$nb_series_glass_eel,"  time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. Number of series, ",pull(selection_summary$nb_series_glass_eel_per_area[1,1]), "=", pull(selection_summary$nb_series_glass_eel_per_area[1,2]), ", ", pull(selection_summary$nb_series_glass_eel_per_area[2,1]),"=", pull(selection_summary$nb_series_glass_eel_per_area[2,2]),". The predictions (p) have been scaled to $\\bar{p}_{1960-1979}$. Note the logarithmic scale on the y-axis.")}
knitr::include_graphics(paste0(imgwd,"figure5_ribbon.png"))
```


In Elsewhere Europe, recruitment in 2025 is higher than in recent years and
nearly comparable to levels observed in the early 2000s. This increase appears
particularly marked in the northern part of the area, especially with some Irish
series that display high residuals (Figure \@ref(fig:figuremapresidyoy)). It
should be reminded that those results are still preliminary and will be updated
next year once all time series will be made available

```{r figuremapresidyoy, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.cap=str_c("Maps of the model residuals for year", CY," in Elsewhere Europe (dots) and North Sea (triangles). A positive (red) residual indicates that the time series has a higher value than the one predicted by the model for", CY," whereas negative (blue) residuals indicate that lower values.")}
knitr::include_graphics(paste0(imgwd,"figureResidMapyoy.png"))

```

The `r CY-1` yellow eel index is at `r round(100*dat_ye[dat_ye$year==CY-1,"value_std_1960_1979"], digits=1)`%
of the 1960-1979 baseline (Figure \@ref(fig:figure6), Tables
\@ref(tab:tableglmyellow)).

```{r tableglmyellow,echo=FALSE,eval=TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,tab.cap=str_c("The yellow eel recruitment index for Europe updated to ", CY-1," . The yellow recruitment was estimated using a GLM (yelloweel  year) fitted to ",selection_summary[["nb_for_yellow_eel_glm"]]," yellow eel time-series. The predictions (p) are scaled to $\\bar{p}_{1960-1979}$.")}
autofit(flextable(yy |>
                    tibble::rownames_to_column(" "))%>%
          bold(bold = TRUE, part = "header")) |>
  flextable2ICES()
```

```{r figure6, fig.width=16/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE,fig.cap=paste("Yellow eel recruitment for Europe updated to ", CY-1,". The yellow eel recruitment was estimated using a GLM (yellow eel ~ year+site) fitted to",selection_summary[["nb_for_yellow_eel_glm"]],"yellow eel time-series. Predictions (p) are scaled to the 1960-1979 average $\\bar{p}_{1960-1979}$. Note the logarithmic scale on the y-axis.")}
knitr::include_graphics(paste0(imgwd,"figure6.png"))
```






## Conclusion
 
The status of European eel remains critical. After high levels in the late
1970s, the European eel recruitment declined dramatically in the 1980s and has
since remained low. Indices of both glass and yellow eel recruitment strongly
declined from 1980 to 2011. In 2025, the Elsewhere Europe recruitment index
reached 12.4% of the 1960-1979 geometric mean (provisional), a level not
observed since the early 2000s. However, this still represents a very low
proportion of the historical baseline and must be interpreted with caution given
the stochastic nature of recruitment.
Index values correspond to
the recruitment as a percentage of the 19601979 geometric mean. Glass eel
recruitment in the North Sea index area was
`r round(100*synthesis[nrow(synthesis),"North Sea"], digits =1)`% in `r CY`
(provisional) and
`r round(100*synthesis[nrow(synthesis)-1,"North Sea"], digits =1)`%  in `r CY-1`
(final). In the Elsewhere Europe index series it was
`r round(100*synthesis[nrow(synthesis),"Elsewhere Europe"], digits =1)`% in
`r CY` (provisional) and
`r round(100*synthesis[nrow(synthesis)-1,"Elsewhere Europe"], digits= 1)`% in
`r CY-1` (final). The yellow eel recruitment index for `r CY-1` was 
`r round(100*dat_ye[dat_ye$year==CY-1,"value_std_1960_1979"], digits=1)`%
(final) of the 19601979 geometric mean. Overall, time-series from 1980 to `r CY` confirm
that glass eel recruitment remains at critically low levels. 

***************************************************************************

## Test for change (remove)


After high levels in the late 1970s, the recruitment declined and has been very
low for all years after 2000. From ICES (2014) onward a change in the
recruitment has been detected. One of the test used to show that change in 2014
was based on SGIPEE(2011) working group. We have used a test only slightly
different from the test used in ICES 2011. The difference is that the model is
now based on individual series as source data, not only the prediction. The
model differs from that used by wgeel also as year is here treated as a
continuous value, whereas it is treated as a factor in the glm for recruitment,
and the years are restricted to decreasing part of the recruitment (after 1980).
\begin{equation} glass~eel \sim  \alpha_{site} site + \beta_{area} Y_{>=1980} +
\gamma_{area} Y_{>2011} + \epsilon, \end{equation} where glass eel is the number
of glass eel in the glass eel series, either for the Elsewhere Europe or the
North Sea time series,  $year_{year>1980}$ is a continuous value corresponding
to year after 1980, $year_{year>2011}$ is also a continuous value, $\epsilon$ is
a random error with mean 0 and standard deviation sigma, and $\alpha_{site}$,
$\beta_{area}$ and $\gamma_{area}$ are the estimated parameters. The parameters
$\gamma_{area}$ are higly significant both in the Elsewhere Europe area
(p=`r round(sgipee_test_for_change_ee,digits=1)` and for the North Sea
p=`r round(sgipee_test_for_change_ns,digits=1)` North Sea. This result confirms
that there has been a change in the recruitment slope.

\textcolor{purple}{Add a table with past coeff, current coeff, and probabilities
and diminish the text}

To test whether there is an increase in recruitment since 2011 the slope of
$\beta_{area}+\gamma_{area}$, i.e. the slope of the recent increase in
recruitment is positive, the NULL hypothesis $H0:b>0$ is tested.

****************************************************************


# Annex 9:	Recruitment additional information




```{r xstatseriesGEE, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Table 1: Short description of the ",selection_summary$nb_series_glass_eel," Glass eel in the recruitment index calculation updated to ", CY,".  EE:  Elsewhere Europe, NS: North Sea. Min and max indicate the first year and last year in the records, and missing indicated the number of missing/excluded years. Unit for the data collected is given (nr = number; index = calculated value fol-lowing a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water, F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to Water Framework Directive).")}
autofit(flextable(data = bind_rows(printstatseriesGNS, 
                                   printstatseriesGEE, 
                                   printstatseriesGY) |> 
                    left_join(R_stations |>
                                dplyr::select(all_of(c("ser_nameshort", 'ser_cou_code'))) |>
                                rename(country = ser_cou_code),
                              by = join_by(code == ser_nameshort) ) |>
                    filter(kept==1) |>
                    dplyr::select(!all_of("kept")) |>
                    arrange(`life stage`, code) |>
                    dplyr::select(!any_of(c("comment", "n+"))) |>
                    rename(missing = `n-`))%>%
          bold(bold = TRUE, part = "header")) |>
  colformat_int(j=3:4, big.mark = "") |>
  flextable2ICES()
```

<br>

```{r xstatseriesY, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, tab.cap= str_c("Table 2: Short description of the ",selection_summary$selection_summary$nb_for_yellow_eel_glm," Yellow eel  in the recruitment index calculation.  EE:  Elsewhere Europe, NS: North Sea. Min and max indicate the first year and last year in the records, and missing indicated the number of missing/excluded years. Unit for the data collected is given (nr = number; index = calculated value fol-lowing a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water, F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to Water Framework Directive).")}
autofit(flextable(data = printstatseriesY |>
                    filter(kept == 1) |>
                    arrange(code) |>
                    left_join(R_stations |>
                                dplyr::select(all_of(c("ser_nameshort", 'ser_cou_code'))) |>
                                rename(country = ser_cou_code),
                              by = join_by(code == ser_nameshort) ) |>
                  dplyr::select(!all_of(c("kept", "comment", "n+"))) |>
                    rename(missing = `n-`))%>%
          bold(bold = TRUE, part = "header")) |>
  colformat_int(j=3:4, big.mark = "")|>
  flextable2ICES()
```


```{r xstatseriesexcluded, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE, tab.cap=str_c("Table 3: Short description of the series that were excluded from the analysis.  EE:  Elsewhere Europe, NS: North Sea. Min and max indicate the first year and last year in the records, and missing indicated the number of missing/excluded years. Unit for the data collected is given (nr = number; index = calculated value fol-lowing a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water (according to the EU Water Framework Directive, WFD), F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to WFD). ")}
autofit(flextable(data = bind_rows(printstatseriesGNS, 
                                   printstatseriesGEE, 
                                   printstatseriesGY,
                                   printstatseriesY) |>
                    left_join(R_stations |>
                                dplyr::select(all_of(c("ser_nameshort", 'ser_cou_code'))) |>
                                rename(country = ser_cou_code),
                              by = join_by(code == ser_nameshort) )|>
                    mutate(comment = ifelse(kept == 0, "too short", comment)) |>
                    mutate(comment = gsub("2023 Cdric : ", "", comment)) |>
                    filter(kept!=1) |>
                    dplyr::select(!all_of("kept")) |>
                    arrange(`life stage`, code) |>
                    dplyr::select(!all_of(c("n+"))) |>
                    rename(missing = `n-`)))%>%
          bold(bold = TRUE, part = "header") |>
  flextable::valign(valign = "top", part = "body") |>
  colformat_int(j=3:4, big.mark = "") |>
  flextable2ICES()
```

<br>

```{r xseriesprob, echo=FALSE, warning = FALSE, message = FALSE, error=FALSE,echo=FALSE, tab.cap=str_c("Table 4: Short description of the data points (i.e. series x year) that have been excluded (kept = 3) or for which some warning were raised (kept = 4)  in the recruitment index calculation in " ,CY, " and ", CY-1, ".  EE:  Elsewhere Europe, NS: North Sea. Life stage: GY = glass eel and yellow eel, G = glass eel, Y = yellow eel. Unit for the data collected is given (nr = number; index = calculated value following a specified protocol, nr/m2 = number per square metre, nr/h = number per hour, kg/boat/d = kg per boat per day). Habitat: C = coastal water, F = freshwater, MO = marine water (open sea), T = transitional water with lower salinity (according to the EU Water Framework Directive, WFD).")}
series_prob <- series_prob |>
  arrange(Stage, Name)
autofit(flextable(data = series_prob |> arrange(Name) |> rename(code = Name))%>%
          bold(bold = TRUE, part = "header")) |>
  colformat_int(j=5, big.mark = "") |>
  flextable2ICES()
```
<br>


```{r tableseriesCY,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE, tab.cap=str_c("Table 5: Series updated to ",CY, ". Codes for stages are G = glass eel, GY = glass eel + yellow eel, Y = yellow eel, Area NS = North Sea, EE = Elsewhere Europe, Division = FAO marine division.")}
autofit(flextable(data = series_CY |> 
                    left_join(R_stations |>
                                dplyr::select(all_of(c("ser_nameshort", 'ser_cou_code'))) |>
                                rename(country = ser_cou_code),
                              by = join_by(Site == ser_nameshort)) |>
                    rename(code = Site) |>
                    dplyr::select(!all_of(c("Kept"))) |>
                    arrange(Stage, code))%>%
          bold(bold = TRUE, part = "header")) |>
  flextable2ICES()
```

```{r xseriesCYm1, echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,tab.cap=str_c("Table 6: Series updated to ",CY-1, " see table XXX for codes.")}
autofit(flextable(data = series_CYm1|> 
                    left_join(R_stations |>
                                dplyr::select(all_of(c("ser_nameshort", 'ser_cou_code'))) |>
                                rename(country = ser_cou_code),
                              by = join_by(Site == ser_nameshort)) |>
                    rename(code = Site) |>
                    dplyr::select(!any_of(c("Kept"))) |>
                    arrange(Stage, code))%>%
          bold(bold = TRUE, part = "header")) |>
  flextable2ICES()
```

```{r xserieslost,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,tab.cap=str_c("table_serieslost"), eval = FALSE}
autofit(flextable(data = series_lost %>%
                                        setNames(str_match(names(.), "^\\\\scshape\\{(.*?)\\}$")[,2])%>%
                    rename(code = Site) %>%
                    arrange(Stage, code)) %>%
          bold(bold = TRUE, part = "header")) |>
  colformat_int(j = 7, big.mark = "") |>
  flextable2ICES() 
```

# Annex 10:  Additional recruitment figures
```{r figure5withoutlogscale, fig.cap=str_c("WGEEL glass eel recruitment index for the continental North Sea and Elsewhere Europe series with 95% confidence intervals updated to ", CY,". The index was estimated using a GLM (glasseel  area : year + site) fitted on ",selection_summary$nb_series_glass_eel,"  time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. Number of series, ",pull(selection_summary$nb_series_glass_eel_per_area[1,1]), "=", pull(selection_summary$nb_series_glass_eel_per_area[1,2]), ", ", pull(selection_summary$nb_series_glass_eel_per_area[2,1]),"=", pull(selection_summary$nb_series_glass_eel_per_area[2,2]),". The predictions (p) are scaled to $\\bar{p}_{1960-1979}$."), fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure5_without_logscale_ribbon.png"))
```
<br>


```{r figure6withoutlogscale, fig.cap=paste("Yellow eel recruitment for Europe updated to ", CY-1,". The yellow recruitment was estimated using a GLM (yellow eel ~ year+site) fitted to",selection_summary[["nb_for_yellow_eel_glm"]],"yellow eel time-series. The predictions (p) are scaled to to the 1960-1979 average $\\bar{p}_{1960-1979}$."), fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure6_without_log_scale.png"))
```
<br>


```{r figure4annex, fig.cap=paste("Time-series of glass eel and yellow eel recruitment in Europe with",selection_summary[["sc_1979_1994_nb"]],"time-series out of the", selection_summary[["nb_series_init"]],"available to the working group. Each time-series has been scaled to its 1979-1994 average. The mean arithmetic values of the combined yellow and glass eel time-series and their bootstrap confidence interval (95%) are represented as black dots and bars. The brown line represents the mean value for yellow eel and the blue line represents the mean value for glass eel time-series. The range of these time-series is indicated by a grey shade. Note that individual time-series from Figure 6 were removed to make the mean value clearer. Also note the logarithmic scale."), fig.width=16/2.54, warning = FALSE, echo=FALSE, message = FALSE, error=FALSE}
knitr::include_graphics(paste0(imgwd,'figure4.png'))
```

<br>

```{r figure3logscale, fig.cap="Time-series of glass eel and yellow eel recruitment in European rivers with time-series having data for the 1979-1994 period. Each time-series has been scaled to its 1979-1994 average. The mean arithmetic values and their bootstrap confidence interval (95%) are represented as black dots and bars. Geometric means are presented in red.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure3.png"))
```
<br>


```{r figure3withoutlogscale, fig.cap="Time-series of glass eel and yellow eel recruitment in European rivers with time-series having data for the 1979-1994 period. Each time-series has been scaled to its 1979-1994 average. Note the logarithmic scale on the y-axis. The mean arithmetic values and their bootstrap confidence interval (95%) are represented as black dots and bars. Geometric means are presented in red.", fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure3withoutlogscale.png"))
```


<br>


```{r figureadvice, fig.cap=str_c("Annual WGEEL recruitment index for the continental North Sea (top panel) and Elsewhere Europe (center panel). The index was estimated using a GLM (glasseel  area : year + site) fitted on ",selection_summary$nb_series_glass_eel,"  time-series comprising either pure glass eel or a mixture of glass eels and yellow eels. Number of series, ",pull(selection_summary$nb_series_glass_eel_per_area[1,1]), "=", pull(selection_summary$nb_series_glass_eel_per_area[1,2]), ", ", pull(selection_summary$nb_series_glass_eel_per_area[2,1]),"=", pull(selection_summary$nb_series_glass_eel_per_area[2,2]),". The predictions p have been scaled to $\\bar{p}_{1960-1979}$. Yellow eel recruitment(bottom panel)  for Europe updated to ", CY-1,". The yellow eel recruitment was estimated using a GLM (yellow eel ~ year+site) fitted to",selection_summary[["nb_for_yellow_eel_glm"]],"yellow eel time-series $p$ and scaled to the 1960-1979 average $\\bar{p}_{1960-1979}$. Note the logarithmic scale on the y-axis."), fig.width=14/2.54, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
knitr::include_graphics(paste0(imgwd,"figure_advice.png"))
```



<!-- TAF_REMOVE -->
```{r TAF,  eval= FALSE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
source("TAFgeneration/taf_generation_script.R")
```

# Annex 8: Quality analysis
## Retrospective analysis

```{r retrospectiverun,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, results = 'hide'}
cred = read_yaml("../../credentials.yml")
con = dbConnect(RPostgres::Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=cred$password)

series=dbReadTable(con,Id(schema="datawg",table="t_series_ser"))
inclusion=dbGetQuery(con,"select min(extract (year from run_date)) as intro_year, ser_nameshort from datawg.t_modeldata_dat left join datawg.t_modelrun_run on dat_run_id=run_id left join datawg.t_series_ser on ser_id=dat_ser_id group by ser_nameshort") %>%
  mutate(intro_year=ifelse(intro_year==2018,"2018",intro_year))

#####First we draw retrospective plots with the data as they were when the model was run


#######retrospective plot model_yoy

retro_yoy_notupdated=do.call(bind_rows,lapply(2018:(CY-1),compute_retro_year)) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std")) %>%
  bind_rows(dat_ge%>%
              mutate(proj=FALSE)) %>%
  mutate(run_id=ifelse(is.na(run_id),CY,run_id)) %>%
  mutate(model="yoy",type="not updated") 


#####Now we draw retrospective plots with the data with data as they are now


#######retrospective plot model_yoy

retro_older_notupdated=do.call(bind_rows,lapply(2018:(CY-1),compute_retro_year,model="glm_older")) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std"))%>%
  bind_rows(dat_ye%>%
              dplyr::mutate(proj=FALSE) %>%
              dplyr::rename(p_std_1960_1979 = value_std_1960_1979)) %>%
  dplyr::mutate(run_id=ifelse(is.na(run_id),CY,run_id)) %>%
  mutate(model="yellow",type="not updated") 




#######retrospective plot model_yoy

retro_yoy_updated=do.call(bind_rows,
                          lapply(2018:(CY-1), compute_retro_year, update_data=TRUE)) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std")) %>%
  bind_rows(dat_ge%>%
              mutate(proj=FALSE)) %>%
  mutate(run_id=ifelse(is.na(run_id), CY, run_id)) %>%
  mutate(model="yoy",type="updated") 


#######retrospective plot model_yoy

retro_older_updated=do.call(bind_rows,
                            lapply(2018:(CY-1),compute_retro_year,model="glm_older", update_data=TRUE)) %>%
  rename_with(~paste0("p_std",gsub("p_std","_1960_1979",.x)),starts_with("p_std"))%>%
  bind_rows(dat_ye %>%
              mutate(proj=FALSE) %>%
              dplyr::rename(p_std_1960_1979 = value_std_1960_1979)) %>%
  dplyr::mutate(run_id=ifelse(is.na(run_id),CY,run_id))  %>%
  mutate(model="yellow",type="updated") 


dbDisconnect(con)
# 
# ggplot(bind_rows(retro_older_updated,
#                  retro_older_notupdated,
#                  retro_yoy_notupdated,
#                  retro_yoy_updated) %>%
#          filter(!proj) %>%
#          mutate(area=ifelse(is.na(area), "", as.character(area))),
#        aes(x=year,y=p_std_1960_1979)) + 
#   geom_line(aes(col=as.factor(run_id))) +
#   facet_wrap(~area) +
#   scale_y_log10(expression(frac(p,bar(p)[1960-1979]))) + 
#   facet_grid(type ~ model + area) +
#   scale_color_viridis_d("")+ guides(lty = "none") + 
#   xlim(CY-10,CY)
# 


retro_advice_data <- bind_rows(
                 retro_older_notupdated,
                 retro_yoy_notupdated) %>%
         filter(!proj) %>%
         mutate(area=ifelse(is.na(area), "", as.character(area))) %>%
  filter(run_id %in% (CY-4):CY) %>%
  dplyr::rename(AssessmentYear = run_id)

mohn_EE = computeMohnsRho(dataset =retro_advice_data %>%
                            filter(area == "Elsewhere Europe"),
                          value_name="p_std_1960_1979",
                          year_name="year",
                          assessment_year_name="AssessmentYear",
                          terminalyear=CY,firstyear=CY-4)


retro_EE <- ggplot(retro_advice_data %>%
         filter(area == "Elsewhere Europe"),
       aes(x=year,y=p_std_1960_1979 * 100)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=100,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("Glass eel Elsewhere Europe recruitment index")+
  theme_ICES_plots("quality_R",retro_advice_data) 


save_figure("retro_EE",retro_EE,600,480, pdf=FALSE)
save_figure("retro_EE_magnify",retro_EE + geom_magnify(from = list(xmin= CY -9,
                                                                   xmax = CY,
                                                                   ymin = 0,
                                                                   ymax = 20),
                                               to = list(xmin=CY-30,
                                                         xmax=CY,
                                                         ymin=150,
                                                         ymax=200)),600,480, pdf=FALSE)


# knitr::include_graphics(paste0(imgwd,"retro_EE.png"))
# knitr::include_graphics(paste0(imgwd,"retro_EE_magnify.png"))

mohn_NS = computeMohnsRho(dataset =retro_advice_data %>%
                            filter(area == "North Sea"),
                          value_name="p_std_1960_1979",
                          year_name="year",
                          assessment_year_name="AssessmentYear",
                          terminalyear=CY,firstyear=CY-4)



retro_NS <- ggplot(retro_advice_data %>%
         filter(area == "North Sea"),
       aes(x=year,y=p_std_1960_1979 * 100)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=100,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("Glass eel North Sea recruitment index") +
  theme_ICES_plots("quality_R",retro_advice_data) 


save_figure("retro_NS",retro_NS,600,480, pdf=FALSE)
save_figure("retro_NS_magnify",retro_NS + geom_magnify(from = list(xmin= CY -9,
                                                                   xmax = CY,
                                                                   ymin = 0,
                                                                   ymax = 2),
                                               to = list(xmin=CY-30,
                                                         xmax=CY,
                                                         ymin=170,
                                                         ymax=220)),600,480, pdf=FALSE)


# knitr::include_graphics(paste0(imgwd,"retro_NS.png"))
# knitr::include_graphics(paste0(imgwd,"retro_NS_magnify.png"))

mohn_YY = computeMohnsRho(dataset =retro_advice_data %>%
         filter(model == "yellow"),
                          value_name="p_std_1960_1979",
                          year_name="year",
                          assessment_year_name="AssessmentYear",
                          terminalyear=CY,firstyear=CY-4)


retro_YY <- ggplot(retro_advice_data %>%
         filter(model == "yellow")%>%
  filter(year < AssessmentYear),
       aes(x=year,y=p_std_1960_1979 * 100)) + 
  geom_line(aes(col=as.factor(AssessmentYear))) +
#  facet_wrap(~area) +
   guides(lty = "none") + 
  	ylab(expression(frac(p,bar(p)[1960-1979])))+	
		geom_hline(yintercept=100,linetype=2)+
		geom_hline(yintercept=0,linetype=1,color = "grey30",size = 0.6)+
  ggtitle("Yellow eel recruitment index") +
  theme_ICES_plots("quality_R",retro_advice_data) 


save_figure("retro_YY",retro_YY,600,480, pdf=FALSE)
save_figure("retro_YY_magnify",retro_YY + geom_magnify(from = list(xmin= CY -9,
                                                                   xmax = CY,
                                                                   ymin = 0,
                                                                   ymax = 25),
                                               to = list(xmin=CY-30,
                                                         xmax=CY,
                                                         ymin=300,
                                                         ymax=400)),600,480, pdf=FALSE)


# knitr::include_graphics(paste0(imgwd,"retro_YY.png"))
# knitr::include_graphics(paste0(imgwd,"retro_YY_magnify.png"))

retro <- ((retro_EE + geom_magnify(from = list(xmin= CY -9,
                                                                   xmax = CY,
                                                                   ymin = 0,
                                                                   ymax = 20),
                                               to = list(xmin=CY-30,
                                                         xmax=CY,
                                                         ymin=140,
                                                         ymax=190))) +
  (retro_NS + geom_magnify(from = list(xmin= CY -9,
                                                                   xmax = CY,
                                                                   ymin = 0,
                                                                   ymax = 2),
                                               to = list(xmin=CY-30,
                                                         xmax=CY,
                                                         ymin=170,
                                                         ymax=220)))) /
  (((retro_YY + geom_magnify(from = list(xmin= CY -9,
                                                                   xmax = CY,
                                                                   ymin = 0,
                                                                   ymax = 25),
                                               to = list(xmin=CY-30,
                                                         xmax=CY,
                                                         ymin=300,
                                                         ymax=400)))) +
  patchwork::plot_spacer()) / guide_area() + plot_layout(axis_titles = "collect", 
                             guides = "collect",
                             heights =c(1,1,0.1), widths = c(1,1))
  

save(mohn_YY, mohn_NS, mohn_EE,file=paste0(outputdatawd,"mohn.Rdata"))
save_figure("retro_patchwork",retro,1200,800, pdf=FALSE)


```


<br>

A retrospective analysis assesses whether the outcomes of an assessment are sensitive to the inclusion of a new year of data. 

Figure \@ref(fig:retrospective) shows the variations of the GLM have varied through time. Several causes explain such variations:

- when the model is run in a given year, the latest values of many time series are not available yet (they are only provided the following year). As such, the estimate for the terminal year is based on a provisional dataset.
- some values are revised every year, particularly the ones for the terminal year
- the GLM is recalculated integrating the new times series every year following time series selection rules.




The Mohn's rho index is largely used to assess the robustness of ICES assessments to thee addition of new annual data (Mohn 1999; ICES 2023b).  Traditionally, the Mohns rho index is fitted
after iteratively fitting the model to truncated datasets where the data for the most recent years
are sequentially removed. A Monhs rho of 0 indicates that the assessment is unaffected by the
addition of new years, while a positive (conversely negative) rho indicates that the assessment
tends to provide a positively (conversely negatively) biased assessment. Given that the eel assessment is based on a GLM with year treated as a factor, the respective year effect is estimated almost independently and removing the terminal year has almost no effect on the estimation of the previous year. As such, this would mechanically (and artificially) lead to Mohns rho close to 0. Therefore, we carried out the Monhs rho analysis based on the dataset effectively used
for each assessment year, to quantify the potential variability due to latter data revision of new
times series integration. It was computed for each of the recruitment index using the assessment of WGEEL `r CY-4` to `r CY`:

- Elsewhere Europe: `r paste0(round(mohn_EE),"%")`
- North Sea: `r paste0(round(mohn_NS),"%")`
- Yellow eel: `r paste0(round(mohn_YY),"%")`

The Elsewhere Europe is more stable than the two other indices. This is likely related to the higher number of time series included in the index that buffers potential revision of data points or inclusion of new time series. The Mohn's rho index of North Sea and Yellow eel are greater than 20%. However, this is likely related to:

- the lower number of time series included in the two corresponding GLM, making the results more sensitive to latter revisions or integration of new time series,
- to the low values of the North-Sea index (Mohn's rho is a relative index and North Sea recruitment is below 1%, so even a revision from 1.5 to 1% implies a change of 50%
- to the natural stochasticity of recruitment.

Despite these high Mohns rho indices, the retrospective diagrams do not display specific pat-
terns (i.e. a situation in which assessment are systematically above or below the previous assessments) and the trends are very consistent between assessment years, indicating that the assessment is robust (Figure \@ref(fig:retrospective)).


The yellow eel series (Figure \@ref(fig:retrospective), lower panel) produces slightly more variation than the glass eel
series (Figure \@ref(fig:retrospective), upper and central panels). This is possibly due to a lower number of sites leading to undue influence of incomplete reporting in the current year. Moreover, because Yellow eel recruitment corresponds to 2-3 age classes, this series is more susceptible of being affected by local environmental conditions, along with density pressures, than the arrival of glass eel (0+), and this may increase the level of inter-annual variability beyond that observed for the glass eel
class of the year.


```{r retrospective,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.cap="Retrospective analysis of the assessment model. Each line corresponds to an assessment for a given year. For Yellow eels, contrary to the other two indices, the assessment year Y only provides estimates until year Y-1 due to data availability when the assessment takes place."}

knitr::include_graphics(paste0(imgwd,"retro_patchwork.png"))

```

<br>


## Sensitivity to individual time series
To check the influence of each time series in the models, the GLMs were fitted while removing each time series one at a time. The effect of removing the time series was quantified through the sum of square of the difference of the predictions of the the model with all time series and the model without the corresponding time series (Figure \@ref(fig:discrepancy)). Unsurprisingly, the longest time series have the largest influence on the model results (e.g. AlbuG or EbroG), but the results are also sensitive to series that were introduced more recently (e.g. MolY or StraGY). This type of analysis might be relevant in the future before integrating any new time series.

```{r discrepancy,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE, fig.cap="Influence of each time series on the final index. The influence is quantified as the sum of square difference between a model with all data and a model without the corresponding time series. The colour indicates the year when the time series was used in the assessment for the first time."}
compute_discrepancy=function(si, model = model_ge_area, years = 2010:2024){
  if ("area" %in% colnames(model$model))
    current_area <- R_stations$area[R_stations$ser_nameshort==si]
         pred_without=predict_model(update(model,data=model$data %>%
                  filter(site!=si & value_std >0))) %>%
           filter(year %in% years)
         pred_with=predict_model(model) %>%
           filter(year %in% years) 
         if ("area" %in% colnames(model$model)){
           pred_with <-
             pred_with %>%
             filter(area == current_area)
           pred_without <-
             pred_without %>%
             filter(area == current_area)
             
         }
         sum((pred_with$p_std-pred_without$p_std)^2)
}
   

sites = unique(na.omit(model_ge_area$data$site))
disc_yoy=data.frame(sites=sites,diff=sapply(sites,compute_discrepancy), area=R_stations$area[match(sites, R_stations$ser_nameshort)]) %>%
  arrange((diff))  %>%
  left_join(inclusion,by=c("sites"="ser_nameshort")) %>%
  mutate(sites=factor(sites,levels=as.character(sites)))
# discrepancy_yoy <-  ggplot(disc_yoy %>%
#          arrange(desc(diff)),
#        aes(x=sites,y=diff,fill=intro_year))+
#   geom_bar(stat="identity")+
#   coord_flip() + facet_wrap(~area)+
#   scale_fill_viridis_d("inclusion in assessment") + 
#   xlab("Sum of squares") +
#   ylab("Time series") +
#   theme_bw()
# 
sites = unique(na.omit(model_older$data$site))
disc_older=data.frame(sites=sites,diff=sapply(sites,compute_discrepancy,model=model_older)) %>%
  arrange((diff)) %>%
  left_join(inclusion,by=c("sites"="ser_nameshort")) %>%
  mutate(sites=factor(sites,levels=as.character(sites))) 


discrepancy_yy <- ggplot(bind_rows(disc_yoy,disc_older %>% mutate(area="yellow")) %>% arrange(desc(diff)) %>% mutate(intro_year=ifelse(is.na(intro_year),CY,intro_year)),aes(x=sites,y=diff,fill=intro_year))+
  facet_wrap(~area,scales="free") +
  geom_bar(stat="identity")+
  coord_flip()+
  scale_fill_viridis_d("inclusion in assessment") + 
  xlab("Sum of squares") +
  ylab("Time series") +
  theme_bw()

save_figure("discrepancy", discrepancy_yy,
            600,480)


knitr::include_graphics(paste0(imgwd,"discrepancy.png"))

```
<br>


## Residuals plots
The residual plots per series are used to detect potential patterns in time series or possible outliers.

```{r resdiualsyoy,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
datares <- data.frame(obs = names(residuals(model_ge_area)),
                      res = residuals(model_ge_area)) %>%
  right_join(model_ge_area$data %>%
               tibble::rownames_to_column("obs"))

for (i in na.omit(unique(datares$site))){
  print(ggplot(datares %>% filter(site == i),
         aes(x = year, y = res, fill=ifelse(abs(res)<=3,"TRUE","FALSE")))+
    geom_bar(stat = "identity", show.legend=FALSE) + 
    facet_wrap(~site, ncol = 2) +
    ggtitle(i) + 
    scale_fill_manual(values=c("FALSE"='red',"TRUE"="grey")) +
    theme_bw() + 
    geom_hline(aes(yintercept=-3), lty = 2) +
    geom_hline(aes(yintercept = 3), lty = 2))
}
```


```{r resdiualsolder,  eval= TRUE, warning = FALSE, message = FALSE, error=FALSE, echo=FALSE}
datares <- data.frame(obs = names(residuals(model_older)),
                      res = residuals(model_older)) %>%
  right_join(model_older$data %>%
               tibble::rownames_to_column("obs"))

for (i in na.omit(unique(datares$site))){
  print(ggplot(datares %>% filter(site == i),
         aes(x = year, y = res, fill=ifelse(abs(res)<=3,"TRUE","FALSE")))+
    geom_bar(stat = "identity", show.legend=FALSE) + 
    facet_wrap(~site, ncol = 2) +
    ggtitle(i) + 
    scale_fill_manual(values=c("FALSE"='red',"TRUE"="grey")) +
    theme_bw() + 
    geom_hline(aes(yintercept=-3), lty = 2) +
    geom_hline(aes(yintercept=3), lty = 2))
}
```
<!-- END_TAF_REMOVE -->

