# Name : global.R
# Date : 03/07/2018
# Author: cedric.briand
# DON'T FORGET TO SET THE qualify_code for eel_qal_id (this will be use to discard duplicates)
###############################################################################

#########################
# loads shiny packages 
########################
# the shiny is launched from shiny_data_integration/shiny
# debug tool
#setwd("C:\\workspace\\wg_WGEEL\\R\\shiny_data_integration\\shiny_di")
source("load_library.R")
source("utilities.R")
load_package("shiny")
load_package("crosstalk")
load_package("assertthat")
load_package("skimr")
load_package("shinydashboardPlus")
load_package("shinyBS")

load_package("leaflet.extras")
load_package("sf")
load_package("crosstalk")
# load_package("shinythemes")
load_package("DT")
load_package("readxl")
load_package("stringr")
load_package("htmltools")
load_package("spsComps")
load_package("writexl")
load_package("shinybusy")
load_package("rlang")
load_package("spsUtil")
load_package("shiny")
load_package("shinyalert")

#-----------------
# Data correction table
#-----------------

load_package("pool")
load_package("DBI")
# load_package("RPostgreSQL") # this one works with sqldf
load_package("RPostgres")
load_package("dplyr")
load_package("tidyr")
load_package("glue")
load_package("shinyjs")
load_package("shinydashboard")
load_package("shinyWidgets")
#load_package("sqldf")
load_package("leaflet")
load_package("shinytoastr")
load_package("tibble")
load_package("purrr") 
options(shiny.sanitize.errors = FALSE)
options(shiny.maxRequestSize=30*1024^2) # 30 MO
#----------------------
# Graphics
#----------------------
load_package("viridis")
load_package("ggplot2")
load_package("plotly")

jscode <- "shinyjs.closeWindow = function() { window.close(); }"


#source("database_connection.R")

load(file=str_c(getwd(),"/common/data/init_data.Rdata"))
# liste des champs permettant de charger l'interface


# below dbListFields from R postgres doesn't work, so I'm extracting the colnames from 
# the table to be edited there



source("loading_functions.R")
source("check_utilities.R")
source("database_data.R") #function extract_data
source("database_reference.R") # function extract_ref
load("common/data/ccm.rdata")

source("importstep0.R")
source("importstep1.R")
source("importstep2.R")
source("newparticipants.R")
source("plotduplicates.R")
source("plotseries.R")
source("importtsstep0.R")
source("importtsstep1.R")
source("importtsstep2.R")
source("importdcfstep0.R")
source("importdcfstep1.R")
source("importdcfstep2.R")
source("writenewindmetricModule.R")
source("writeupdatedindmetricModule.R")
source("writenewgroupmetricModule.R")
source("writeupdatedgroupmetricModule.R")
source("writedeletedgroupmetricModule.R")
source("writedeletedindmetricModule.R")
source("dataWriterModule.R")

# Local shiny files ---------------------------------------------------------------------------------

source("database_tools.R")
source("graphs.R")
source("tableEdit.R")

#pool <<- pool::dbPool(drv = RPostgres::Postgres(),
#    dbname="wgeel",
#    host=host,
#    port=port,
#    user= userwgeel,
#    password= passwordwgeel,
#    bigint="integer",
#    minSize = 0,
#    maxSize = 2)
onStop(function() {
			poolClose(pool)
		}) # important!
# VERY IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -------------------------------------------------
##########################
# CHANGE THIS LINE AT THE NEXT DATACALL AND WHEN TEST IS FINISHED
# BEFORE WGEEL sqldf('delete from datawg.t_eelstock_eel where eel_datasource='test')
# BEFORE WGEEL sqldf('delete from datawg.t_eelstock_eel where eel_datasource='test')
########################
qualify_code<-25 # change this code here and in tr_quality_qal for next wgeel
the_eel_datasource <- "dc_2025"  # change this after tests #dc_2023
current_year <- 2025





###################################"
#DATABASE CONNECTION INFO
##################################"
cred=yaml::read_yaml("./credentials_write.yml")
if (file.exists("credentials_password.yml")){
  cred_password = yaml::read_yaml("./credentials_password.yml")
  cred = c(cred, cred_password)
}
port <- cred$port
host <- cred$host
userwgeel <-cred$user


scrollY= "300px" #size of DT table per default
path <- tempdir()


########### create a dictionnary of columns with types
dictionary=c(
  ###########columns in group_metrics sampling	
  "gr_id"="numeric",
  "sai_name"="text",
  "sai_emu_nameshort"="text",
  "gr_year"="numeric",
  "grsa_lfs_code"="text",	
  "gr_number"="numeric",
  "lengthmm"="numeric",
  "weightg"="numeric",
  "ageyear" = "numeric",
  "female_proportion"="numeric", 
  "differentiated_proportion" = "numeric",
  "m_mean_lengthmm"= "numeric",
  "m_mean_weightg"= "numeric",
  "m_mean_ageyear"= "numeric",
  "f_mean_lengthmm"= "numeric",
  "f_mean_weightg"= "numeric",
  "f_mean_age"= "numeric",
  "g_in_gy_proportion"= "numeric",
  "s_in_ys_proportion"= "numeric",
  "anguillicola_proportion"= "numeric",
  "anguillicola_intensity"= "numeric",
  "muscle_lipid_fatmeter_perc"= "numeric",
  "muscle_lipid_gravimeter_perc"= "numeric",
  "sum_6_pcb"= "numeric",
  "teq"= "numeric",
  "evex_proportion"= "numeric",
  "hva_proportion"= "numeric",
  "pb"= "numeric",
  "hg"= "numeric",
  "cd"= "numeric",
  "gr_comment"="text",
  "gr_lastupdate" = "date",
  "gr_dts_datasource"="text",
  "fi_id_cou"="text",
  "fi_idcou"="text",
  ####columns in fish individual metrics samplings	
  "fi_id"="numeric",
  "sai_name"="text",
  "sai_emu_nameshort"="text",
  "fi_date"="date",
  "fi_year"="numeric",
  "fi_lfs_code"="text",
  "fisa_x_4326"="numeric",
  "fisa_y_4326"="numeric",
  "fisa_lfs_code"="text",
  "fi_comment"="text",
  "lengthmm"="numeric",
  "weightg"="numeric",
  "ageyear"="numeric",
  "eye_diam_meanmm"="numeric",
  "pectoral_lengthmm"="numeric",
  "is_female_(1=female,0=male)"="numeric",
  "is_differentiated_(1=differentiated,0_undifferentiated)"="numeric",
  "anguillicola_presence_(1=present,0=absent)"="numeric",
  "anguillicola_intensity"="numeric",
  "muscle_lipid_fatmeter_perc"="numeric",
  "muscle_lipid_gravimeter_perc"="numeric",
  "sum_6_pcb"="numeric",
  "teq"="numeric",
  "evex_presence_(1=present,0=absent)"="numeric",
  "hva_presence_(1=present,0=absent)"="numeric",
  "pb"="numeric",
  "hg"="numeric",
  "cd"="numeric",
  "fi_lastupdate"="date",
  "fi_dts_datasource"="text",
  # series group and indiv
  "grser_ser_id"="numeric",
  "fiser_ser_id"="numeric",
  "fiser_year"="numeric", # TODO remove 2023
  "ser_nameshort"="text",
  # dataseries
  "das_id"="numeric",
  "das_ser_id"="numeric",
  "das_value"="numeric",
  "das_year"="numeric",
  "das_comment"="text",
  "das_effort"="numeric",
  "das_qal_id"="numeric",
  "das_qal_comment"="text",
  "das_dts_datasource"="text",
  "method_sex_(1=visual,0=use_length)"= "numeric",
  "method_anguillicola_(1=stereomicroscope,0=visual_obs)"= "numeric",
  
  ###annex 4 -8
  "eel_id" = "numeric",
  "eel_id"= "numeric",
  "eel_typ_name"="text",
  "eel_year"= "numeric",
  "eel_value"= "numeric",
  "eel_value_number"= "numeric",
  "eel_value_kg"= "numeric",
  "eel_missvaluequal"	="text",
  "eel_emu_nameshort"	="text",
  "eel_cou_code"	="text",
  "eel_lfs_code"="text",
  "eel_hty_code"="text",
  "eel_area_division"="text",
  "eel_qal_id"= "numeric",
  "eel_qal_comment"="text",
  "eel_comment"="text",
  
  ######Others
  "sheetorigin"="text",
  "eel_datasource"="text",
  "perc_mo"="numeric",
  "perc_c"="numeric",
  "perc_t"="numeric",
  "perc_f"="numeric",
  "eel_typ_id"="numeric",
  "meg_dts_datasource"="text",
  "id"="numeric",
  "keep_new_value"="text",
  "meg_mty_id"="numeric",
  "meg_id"="numeric",
  "mei_dts_datasource"="text",
  "fisa_sai_id"="numeric",
  "sai_area_division"="text",
  "sai_hty_code"="text",
  "sai_samplingobjective"="text",
  "sai_protocol"="text",
  "sai_qal_id"="numeric",
  "sai_comment"="text",
  "sai_lastupdate"="date",
  "sai_dts_datasource"="text",
  "sai_cou_code"="text",
  "ser_namelong"="text",
  "ser_typ_id"="numeric",
  "ser_effort_uni_code"="text",
  "ser_comment"="text",
  'ser_uni_code'='text',
  "ser_lfs_code"="text",
  "ser_hty_code"="text",
  "ser_locationdescription"="text",
  "ser_emu_nameshort"="text",
  "ser_cou_code"="text",
  "ser_area_division"="text",
  "ser_tblcodeid"="numeric",
  "ser_x"="numeric",
  "ser_y"="numeric",
  "ser_sam_id"="numeric",
  'ser_sam_gear'="numeric",
  "ser_distanceseakm"="numeric",
  "ser_method"="text",
  "ser_restocking"="logical",
  'ser_dts_datasource'="text",
  "sai_samplingstrategy"="text",
  "sai_qal_comment"="text",
  "grsa_sai_id"="numeric",
  "meg_value"="numeric",
  "mei_value"="numeric",
  "mty_name"="text",
  "mei_mty_id"="numeric",
  "ser_ccm_wso_id"="text",
  "ser_qal_comment"="text",
  "ser_qal_id"="numeric"
  
  
  
)
dictionary = c(dictionary,
               dictionary %>% setNames(paste0(names(dictionary), ".base")),
               dictionary %>% setNames(paste0(names(dictionary), ".xls")))


#since contaminant data are not kept every year, we have a list of variables
#that should be ignored when contaminant are not collected
contaminant_names <- c(
    "muscle_lipid_fatmeter_perc",
    "muscle_lipid_gravimeter_perc",
    "sum_6_pcb",
    "teq",
    "pb",
    "hg",
    "cd",
    "teq")

dataTypeConvert=function(mydata, columns, col_types){
  tryCatch({
        mydata <- mydata %>%
            mutate(across(any_of(columns[col_types == "date"]) , ~as.Date(.x)),
                across(any_of(columns[col_types=="text"]), ~as.character(.x)),
                across(any_of(columns[col_types=="numeric"]), ~as.numeric(.x)),
                across(any_of(columns[col_types=="logical"]), ~as.logical(.x)))
      }, error = function(e) {
        showNotification(paste(sheet,"Error when casting data", e), type="warning",duration=NULL) 		
      })
  mydata
}




#####
shinyCatch=
    function (expr, position = "bottom-right", blocking_level = "none",
        shiny = TRUE, prefix = "SPS", trace_back = spsUtil::spsOption("traceback")) {
  assertthat::assert_that(is.logical(shiny))
  assertthat::assert_that(all(is.character(prefix), length(prefix) == 1))
  prefix <- paste0(prefix, if (prefix == "")
            " "
          else "-")
  shiny <- all(!is.null(crosstalk::getDefaultReactiveDomain()), shiny)
  if (shiny)
    spsComps:::dependServer("toastr")
  toastr_actions <- list(message = function(m) {
        spsUtil::msg(m$message, paste0(prefix, "INFO"), "blue")
        if (shiny) shinytoastr::toastr_info(message = spsUtil::remove_ANSI(m$message),
              position = position, closeButton = TRUE, timeOut = 3000,
              preventDuplicates = TRUE)
      }, warning = function(m) {
        spsUtil::msg(m$message, paste0(prefix, "WARNING"), "orange")
        if (shiny) shinytoastr::toastr_warning(message = spsUtil::remove_ANSI(m$message),
              position = position, closeButton = TRUE, timeOut = 5000,
              preventDuplicates = TRUE)
      }, error = function(m) {
        if (inherits(m,"rlang_error")){
          spsUtil::msg(rlang::cnd_message(m), paste0(prefix, "ERROR"), "red")
          if (shiny) shinytoastr::toastr_error(message = spsUtil::remove_ANSI(rlang::cnd_message(m)),
                position = position, closeButton = TRUE, timeOut = 0,
                preventDuplicates = TRUE, title = "There is an error",
                hideDuration = 300)
        } else{
          spsUtil::msg(m$message, paste0(prefix, "ERROR"), "red")
          if (shiny) shinytoastr::toastr_error(message = spsUtil::remove_ANSI(m$message),
                position = position, closeButton = TRUE, timeOut = 0,
                preventDuplicates = TRUE, title = "There is an error",
                hideDuration = 300)
        }
      })
  switch(tolower(blocking_level), error = tryCatch(base::suppressMessages(suppressWarnings(base::withCallingHandlers(expr,
                      message = function(m) toastr_actions$message(m), warning = function(m) toastr_actions$warning(m),
                      error = function(m) if (trace_back) spsComps:::printTraceback(sys.calls())))),
          error = function(m) {
            toastr_actions$error(m)
            shiny:::reactiveStop(class = "validation")
          }), warning = tryCatch(base::suppressMessages(withCallingHandlers(expr,
                  message = function(m) toastr_actions$message(m), error = function(m) if (trace_back) spsComps:::printTraceback(sys.calls()))),
          warning = function(m) {
            toastr_actions$warning(m)
            shiny:::reactiveStop(class = "validation")
          }, error = function(m) {
            if (!is.empty(m$message)) toastr_actions$error(m)
            shiny:::reactiveStop(class = "validation")
          }), message = tryCatch(base::withCallingHandlers(expr, error = function(m) if (trace_back) spsComps:::printTraceback(sys.calls())),
          message = function(m) {
            toastr_actions$message(m)
            reactiveStop(class = "validation")
          }, warning = function(m) {
            toastr_actions$warning(m)
            reactiveStop(class = "validation")
          }, error = function(m) {
            if (!is.empty(m$message)) toastr_actions$error(m)
            shiny::reactiveStop(class = "validation")
          }), tryCatch(base::suppressMessages(base::suppressWarnings(base::withCallingHandlers(expr,
                      message = function(m) toastr_actions$message(m), warning = function(m) toastr_actions$warning(m),
                      error = function(m) if (trace_back) printTraceback(sys.calls())))),
          error = function(m) {
            toastr_actions$error(m)
            return(NULL)
          }))
}


