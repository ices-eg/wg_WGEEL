#S_ts[is.infinite(S_ts)] <- -15
S_Ts
S_ts
apply(S_ts,1,scale)
rowmeans(apply(S_ts,1,scale))
rowmean(apply(S_ts,1,scale))
rowMean(apply(S_ts,1,scale))
rowMeans(apply(S_ts,1,scale))
rowMeans(apply(S_ts,1,scale),rm.na=TRUE)
rowMeans(apply(S_ts,1,scale),na.rm =TRUE)
rowMeans(apply(S_ts,1,scale))
apply(S_ts,1,scale)
# Indexes giving how serie ids relate to habitat type, restocking and ecoregions
subpop_fct <- d.cpue %>%
select("ser_nameshort","ser_hty_code","ser_restocking","ecoregion") %>%
unique()
# add size of river to tested hypotheses
RS <- read.csv2("data/Silver_Series_RiverSize.csv")
RS <- RS %>% select(ser_namesh,SubjectiveSize)
subpop_fct <- subpop_fct %>% left_join(RS,by=join_by(ser_nameshort==ser_namesh))
# Wide format of silver eel data
S_data <- d.cpue %>%
select("das_year","ser_nameshort","cpue") %>%
complete(das_year,ser_nameshort) %>% # add na´s to non existing years
pivot_wider(names_from=ser_nameshort,values_from = cpue) # wide format
# Rearrange data for fitting MARSS model
Years <- S_data$das_year
S_ts <- S_data[,names(S_data)!="das_year"]
S_ts <- t(S_ts) # transpose matrix
S_ts <- S_ts[subpop_fct$ser_nameshort,]
S_ts
apply(S_ts,1,scale)
apply(S_ts,2,scale)
rowMeans(apply(S_ts,2,scale))
rowMeans(apply(S_ts,2,scale),rm.na=TRUE)
rowMeans(apply(S_ts,2,scale),na.rm =TRUE)
rowMeans(apply(S_ts,1,scale),na.rm =TRUE)
apply(S_ts, 1,function(df) (df-mean(df))/sd(df))
S_ts
apply(S_ts, 1,function(df) (df-mean(df,rm.na=TRUE))/sd(df,rm.na=TRUE))
apply(S_ts, 1,function(df) (df-mean(df,na.rm=TRUE))/sd(df,na.rm=TRUE))
S_ts <- t(apply(S_ts, 1,function(df) (df-mean(df,na.rm=TRUE))/sd(df,na.rm=TRUE)))
colMeans(S_ts)
colMeans(S_ts,rm.na=TRUE)
colMeans(S_ts,na.rm =TRUE)
rowMeans(S_ts,na.rm =TRUE)
S_ts <- t(apply(S_ts, 1,function(df) (df-mean(df,na.rm=TRUE))/sd(df,na.rm=TRUE)))
n_series <- nrow(S_ts)
# H1: panmictic population
Z1 <- factor(rep("pan", n_series))
# H2: Habitat type
Z2 <- factor(subpop_fct$ser_hty_code)
# H3: Restocking
Z3 <- factor(subpop_fct$ser_restocking)
# H4: Ecoregion
Z4 <- factor(subpop_fct$ecoregion)
# H5: North Sea vs. Elsewhere europe
Z5 <- factor(ifelse(subpop_fct$ecoregion %in% c("Greater North Sea"), "North Sea", "Elsewhere Europe"))
# H6: Catchment size
Z6 <- factor(subpop_fct$SubjectiveSize)
# all models
Z.models <- list(Z1, Z2, Z3, Z4, Z5, Z6)
names(Z.models) <-
c("panmictic", "Habitat type", "Restocking", "Ecoregion", "North Sea vs. elsewhere europe", "Catchment size")
# test with different Q models(i.e. different process errors)
Q.models <- c("diagonal and equal", "diagonal and unequal")
# Model parameters(the same across  all models)
U.model <- "unequal"
R.model <- "diagonal and equal"
A.model <- "zero"
B.model <- "identity"
x0.model <- "unequal"
V0.model <- "zero"
model.constant <- list(
U = U.model, R = R.model, A = A.model,
x0 = x0.model, V0 = V0.model, tinitx = 0
)
out.tab <- NULL
fits <- list()
for (i in 1:length(Z.models)) {
for (Q.model in Q.models) {
fit.model <- c(list(Z = Z.models[[i]], Q = Q.model), model.constant)
fit <- MARSS(S_ts,
model = fit.model,
silent = TRUE, control = list(maxit = 2000)
)
out <- data.frame(
H = names(Z.models)[i], Q = Q.model, U = U.model,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(Z.models[[i]])),
num.iter = fit$numIter, converged = !fit$convergence,
stringsAsFactors = FALSE
)
out.tab <- rbind(out.tab, out)
fits <- c(fits, list(fit))
if (i == 1) next # one m for panmictic so only run 1 Q
}
}
source("../../utilities/load_library.R")
knitr::opts_chunk$set(echo = TRUE,warning=FALSE,message=FALSE,
fig.width=14.9/2.54,
dpi=300,
fig.height=10/2.54)
load_library("RPostgres")
load_library("dplyr")
load_library("tidyr")
load_library("readxl")
load_library("yaml")
load_library("flextable")
load_library("ggplot2")
cred=read_yaml("../../../credentials.yml")
con_wgeel = dbConnect(Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=cred$password)
query='SELECT
das_id,
das_value,
das_effort,
das_year,
das_comment,
ser_id,
cou_order,
ser_nameshort,
ser_area_division,
ser_qal_id,
ser_hty_code,
ser_emu_nameshort,
ser_uni_code,
ser_cou_code,
ser_comment,
sam_samplingtype,
ser_sam_id, ser_distanceseakm, ser_method, ser_sam_gear, ser_restocking,
das_qal_id,
das_last_update,
f_subarea,
lfs_code,
lfs_name
from datawg.t_dataseries_das
join datawg.t_series_ser on das_ser_id=ser_id
left join ref.tr_samplingtype_sam on ser_sam_id=sam_id
left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
left join ref.tr_faoareas on ser_area_division=f_division
left join ref.tr_country_cou on cou_code=ser_cou_code
where ser_typ_id in (2,3) and das_value is not null and  (ser_qal_id IS NULL OR ser_qal_id IN (0,1,2,4)) and (das_qal_id IS NULL OR das_qal_id IN (1,2,4))'
mydata = dbGetQuery(con_wgeel,query) # Get yellow and silver eel time series from WGEEL database
dbDisconnect(con_wgeel) #disconnect from WGEEL database
d.ecoregion = read.csv2("data/points_with_ecoregions_forRob.csv") %>% #Load data on ecoregion of dataseries
rename(ecoregion = new_Ecoreg)
####################
### Get data in right format
data <- mydata %>%
filter(lfs_code == "S") %>% #Filter data down to silver eel timeseries
arrange(ser_nameshort, das_year) %>% # Sort data for better overview
left_join(d.ecoregion %>% select(ser_id, ecoregion, distance_to_ecoregion)) # Add ecoregion info
####################
### Assign type of effort data available and any relevant notes
d.effort = data %>%
select(ser_nameshort) %>%
unique() %>%
mutate(effort = case_when(
ser_nameshort %in% c("BreS",  "KilS",   "SeNS",     "StrS",  "DaugS",  "LilS" ) ~ "provided",
ser_nameshort %in% c("BI1S",  "BI4S", "BRWS",  "DoijS", "HVWS",  "IjsS", "KotkS", "LoiS", "MinS",  "MonS",  "NiWS", "NkaS",  "NZKS", "OriS",  "PanS",  "PobeS", "PogoS", "PolsS", "SosS",  "TibeS", "ZMaS", "NSIS" ) ~ "index",
ser_nameshort %in% c("BaBS",  "BidS",  "BurS",  "EamtS", "FowS", "FreS", "GiBS",  "ImsaS", "KavlS", "LevS",  "NalS",  "NorwS", "ShiS",  "VaakS",  "WepeS") ~ "constant",
ser_nameshort %in% c("RibS", "SouS", "VilS", "WarS") ~ "model estimate",
ser_nameshort %in% c("AlauS", "AlCS",  "CurlS", "KertS", "KreS",  "LakS",  "RieS",  "RubS",  "SiesS", "ZeiS" ) ~ "unknown"
),
notes = case_when(
ser_nameshort %in% c("AlauS",  "CurlS",  "KertS",  "KreS", "LakS",  "RieS",  "RubS",  "SiesS",  "ZeiS") ~ "Next year double check for available effort data on all similar Lithuanian series, and check if only silver eel are reported",
ser_nameshort %in% c("AlCS") ~ "A mean of a subsample of commercial catches, no effort known",
ser_nameshort %in% c("NorwS",  "WepeS") ~ "Recent years reported as 0, but actually no information available"
)
)
if(any(is.na(d.effort$effort))){
stop("qualitative effort information from the following series is missing: ",
paste(d.effort$ser_nameshort[which(is.na(d.effort$effort))], collapse = ", "),
". Manually insert this into the d.effort dataframe before proceeding.")
}
### Filter data down to relevant silver eel series
# Filter data according to time series length, and the availability of effort data
# If no data on effort is known, then the series cannot be used to analyse trends in abundance/CPUE.
# Sometimes, no effort data is given because all silver eel passing through a river are sampled. This data is kept here,
# perhaps advise in next year's data call to set such effort equal to 1 in the das_effort column
min.length = 10 #minimum time-series length, delete series with fewer number of years
#Overview table to be used in the subgroup text to show which series were kept and which were discarded
t.filterchoice <- data %>%
count(ser_nameshort, ser_method) %>% #filter data down to series name and method, while counting time series length
left_join(d.effort %>% select(ser_nameshort, effort, notes)) %>% #Add information on effort type/availability
mutate(filtered = case_when(
n < min.length ~ "Dropped", # Set a variable specifying if the column should be filtered out based on time-series length
effort == "unknown" ~ "Dropped", # Drop series with unknown effort
ser_nameshort %in% c("NorwS", "WepeS") ~ "Dropped", #These two series have had trouble reporting in recent years, data for those years not reliable, drop until issue is resolved.
TRUE ~ "Kept"
),
reason.dropped = case_when(
n < min.length ~ paste("Number of years fewer than",min.length, sep = " "),
effort == "unknown" ~ "No effort given",
ser_nameshort %in% c("NorwS", "WepeS") ~ "Inconsistencies in data",
TRUE ~ ""
)
)
### NOTE: LevS reports no effort (assumed constant effort), but lists multiple years with deviations in sampling times, and thus different effort. Choose what to do with those.
# Apply the filter to the data, calculate CPUE, process data to output format
d.cpue <- data %>%
left_join(t.filterchoice %>% select(ser_nameshort, effort, filtered)) %>% #add filter choice
filter(filtered != "Dropped") %>% #filter out selected series
mutate(cpue = case_when( # Calculate CPUE based on data type
effort == "index" ~ das_value,
effort == "model estimate" ~ das_value,
effort == "constant" ~ das_value,
effort == "provided" ~ das_value/das_effort
)
) %>% #calculate cpue if effort data is given, otherwise assume that das_value is already CPUE
select(das_id, das_year, cpue, das_value, das_effort, ser_id, ser_nameshort, ser_hty_code, ser_emu_nameshort, ser_cou_code, ser_distanceseakm, ser_restocking, ecoregion, distance_to_ecoregion, das_qal_id, ser_qal_id)
dbDisconnect(con_wgeel)
query='SELECT
das_id,
das_value,
das_effort,
das_year,
das_comment,
ser_id,
cou_order,
ser_nameshort,
ser_area_division,
ser_qal_id,
ser_hty_code,
ser_emu_nameshort,
ser_uni_code,
ser_cou_code,
ser_comment,
sam_samplingtype,
ser_sam_id, ser_distanceseakm, ser_method, ser_sam_gear, ser_restocking,
das_qal_id,
das_last_update,
f_subarea,
lfs_code,
lfs_name
from datawg.t_dataseries_das
join datawg.t_series_ser on das_ser_id=ser_id
left join ref.tr_samplingtype_sam on ser_sam_id=sam_id
left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
left join ref.tr_faoareas on ser_area_division=f_division
left join ref.tr_country_cou on cou_code=ser_cou_code
where ser_typ_id in (2,3) and das_value is not null and  (ser_qal_id IS NULL OR ser_qal_id IN (0,1,2,4)) and (das_qal_id IS NULL OR das_qal_id IN (1,2,4))'
mydata = dbGetQuery(con_wgeel,query) # Get yellow and silver eel time series from WGEEL database
source("../../utilities/load_library.R")
knitr::opts_chunk$set(echo = TRUE,warning=FALSE,message=FALSE,
fig.width=14.9/2.54,
dpi=300,
fig.height=10/2.54)
load_library("RPostgres")
load_library("dplyr")
load_library("tidyr")
load_library("readxl")
load_library("yaml")
load_library("flextable")
load_library("ggplot2")
cred=read_yaml("../../../credentials.yml")
con_wgeel = dbConnect(Postgres(), dbname=cred$dbname,host=cred$host,port=cred$port,user=cred$user, password=cred$password)
query='SELECT
das_id,
das_value,
das_effort,
das_year,
das_comment,
ser_id,
cou_order,
ser_nameshort,
ser_area_division,
ser_qal_id,
ser_hty_code,
ser_emu_nameshort,
ser_uni_code,
ser_cou_code,
ser_comment,
sam_samplingtype,
ser_sam_id, ser_distanceseakm, ser_method, ser_sam_gear, ser_restocking,
das_qal_id,
das_last_update,
f_subarea,
lfs_code,
lfs_name
from datawg.t_dataseries_das
join datawg.t_series_ser on das_ser_id=ser_id
left join ref.tr_samplingtype_sam on ser_sam_id=sam_id
left join ref.tr_lifestage_lfs on ser_lfs_code=lfs_code
left join ref.tr_faoareas on ser_area_division=f_division
left join ref.tr_country_cou on cou_code=ser_cou_code
where ser_typ_id in (2,3) and das_value is not null and  (ser_qal_id IS NULL OR ser_qal_id IN (0,1,2,4)) and (das_qal_id IS NULL OR das_qal_id IN (1,2,4))'
mydata = dbGetQuery(con_wgeel,query) # Get yellow and silver eel time series from WGEEL database
dbDisconnect(con_wgeel) #disconnect from WGEEL database
d.ecoregion = read.csv2("data/points_with_ecoregions_forRob.csv") %>% #Load data on ecoregion of dataseries
rename(ecoregion = new_Ecoreg)
####################
### Get data in right format
data <- mydata %>%
filter(lfs_code == "S") %>% #Filter data down to silver eel timeseries
arrange(ser_nameshort, das_year) %>% # Sort data for better overview
left_join(d.ecoregion %>% select(ser_id, ecoregion, distance_to_ecoregion)) # Add ecoregion info
####################
### Assign type of effort data available and any relevant notes
d.effort = data %>%
select(ser_nameshort) %>%
unique() %>%
mutate(effort = case_when(
ser_nameshort %in% c("BreS",  "KilS",   "SeNS",     "StrS",  "DaugS",  "LilS" ) ~ "provided",
ser_nameshort %in% c("BI1S",  "BI4S", "BRWS",  "DoijS", "HVWS",  "IjsS", "KotkS", "LoiS", "MinS",  "MonS",  "NiWS", "NkaS",  "NZKS", "OriS",  "PanS",  "PobeS", "PogoS", "PolsS", "SosS",  "TibeS", "ZMaS", "NSIS" ) ~ "index",
ser_nameshort %in% c("BaBS",  "BidS",  "BurS",  "EamtS", "FowS", "FreS", "GiBS",  "ImsaS", "KavlS", "LevS",  "NalS",  "NorwS", "ShiS",  "VaakS",  "WepeS") ~ "constant",
ser_nameshort %in% c("RibS", "SouS", "VilS", "WarS") ~ "model estimate",
ser_nameshort %in% c("AlauS", "AlCS",  "CurlS", "KertS", "KreS",  "LakS",  "RieS",  "RubS",  "SiesS", "ZeiS" ) ~ "unknown"
),
notes = case_when(
ser_nameshort %in% c("AlauS",  "CurlS",  "KertS",  "KreS", "LakS",  "RieS",  "RubS",  "SiesS",  "ZeiS") ~ "Next year double check for available effort data on all similar Lithuanian series, and check if only silver eel are reported",
ser_nameshort %in% c("AlCS") ~ "A mean of a subsample of commercial catches, no effort known",
ser_nameshort %in% c("NorwS",  "WepeS") ~ "Recent years reported as 0, but actually no information available"
)
)
if(any(is.na(d.effort$effort))){
stop("qualitative effort information from the following series is missing: ",
paste(d.effort$ser_nameshort[which(is.na(d.effort$effort))], collapse = ", "),
". Manually insert this into the d.effort dataframe before proceeding.")
}
### Filter data down to relevant silver eel series
# Filter data according to time series length, and the availability of effort data
# If no data on effort is known, then the series cannot be used to analyse trends in abundance/CPUE.
# Sometimes, no effort data is given because all silver eel passing through a river are sampled. This data is kept here,
# perhaps advise in next year's data call to set such effort equal to 1 in the das_effort column
min.length = 10 #minimum time-series length, delete series with fewer number of years
#Overview table to be used in the subgroup text to show which series were kept and which were discarded
t.filterchoice <- data %>%
count(ser_nameshort, ser_method) %>% #filter data down to series name and method, while counting time series length
left_join(d.effort %>% select(ser_nameshort, effort, notes)) %>% #Add information on effort type/availability
mutate(filtered = case_when(
n < min.length ~ "Dropped", # Set a variable specifying if the column should be filtered out based on time-series length
effort == "unknown" ~ "Dropped", # Drop series with unknown effort
ser_nameshort %in% c("NorwS", "WepeS") ~ "Dropped", #These two series have had trouble reporting in recent years, data for those years not reliable, drop until issue is resolved.
TRUE ~ "Kept"
),
reason.dropped = case_when(
n < min.length ~ paste("Number of years fewer than",min.length, sep = " "),
effort == "unknown" ~ "No effort given",
ser_nameshort %in% c("NorwS", "WepeS") ~ "Inconsistencies in data",
TRUE ~ ""
)
)
### NOTE: LevS reports no effort (assumed constant effort), but lists multiple years with deviations in sampling times, and thus different effort. Choose what to do with those.
# Apply the filter to the data, calculate CPUE, process data to output format
d.cpue <- data %>%
left_join(t.filterchoice %>% select(ser_nameshort, effort, filtered)) %>% #add filter choice
filter(filtered != "Dropped") %>% #filter out selected series
mutate(cpue = case_when( # Calculate CPUE based on data type
effort == "index" ~ das_value,
effort == "model estimate" ~ das_value,
effort == "constant" ~ das_value,
effort == "provided" ~ das_value/das_effort
)
) %>% #calculate cpue if effort data is given, otherwise assume that das_value is already CPUE
select(das_id, das_year, cpue, das_value, das_effort, ser_id, ser_nameshort, ser_hty_code, ser_emu_nameshort, ser_cou_code, ser_distanceseakm, ser_restocking, ecoregion, distance_to_ecoregion, das_qal_id, ser_qal_id)
dbDisconnect(con_wgeel)
source("../../utilities/load_library.R")
load_library("MARSS")
load_library("gridExtra")
load_library("xtable")
load_library("getPass")
load_library("RPostgres")
load_library("sf")
load_library("flextable")
load_library("broom")
load_library("eulerr")
load_library("dplyr")
load_library("knitr")
load_library("ggplot2")
load_library("ggmap")
load_library("tidyverse")
load_library("rnaturalearth")
load_library("parallel")
load_library("kableExtra")
load_library("mgcv")
load_library("ggmap")
load_library("ggrepel")
load_library("grid")
load_library("flextable")
load_library("yaml")
# Indexes giving how serie ids relate to habitat type, restocking and ecoregions
subpop_fct <- d.cpue %>%
select("ser_nameshort","ser_hty_code","ser_restocking","ecoregion") %>%
unique()
# add size of river to tested hypotheses
RS <- read.csv2("data/Silver_Series_RiverSize.csv")
RS <- RS %>% select(ser_namesh,SubjectiveSize)
subpop_fct <- subpop_fct %>% left_join(RS,by=join_by(ser_nameshort==ser_namesh))
# Wide format of silver eel data
S_data <- d.cpue %>%
select("das_year","ser_nameshort","cpue") %>%
complete(das_year,ser_nameshort) %>% # add na´s to non existing years
pivot_wider(names_from=ser_nameshort,values_from = cpue) # wide format
# Rearrange data for fitting MARSS model
Years <- S_data$das_year
S_ts <- S_data[,names(S_data)!="das_year"]
S_ts <- t(S_ts) # transpose matrix
S_ts <- S_ts[subpop_fct$ser_nameshort,] # rearrange row order(same as subpop_fct)
#S_ts <- log(S_ts) # log data
#S_ts[is.infinite(S_ts)] <- -15
# z-score data
S_ts <- t(apply(S_ts, 1,function(df) (df-mean(df,na.rm=TRUE))/sd(df,na.rm=TRUE)))
n_series <- nrow(S_ts)
# H1: panmictic population
Z1 <- factor(rep("pan", n_series))
# H2: Habitat type
Z2 <- factor(subpop_fct$ser_hty_code)
# H3: Restocking
Z3 <- factor(subpop_fct$ser_restocking)
# H4: Ecoregion
Z4 <- factor(subpop_fct$ecoregion)
# H5: North Sea vs. Elsewhere europe
Z5 <- factor(ifelse(subpop_fct$ecoregion %in% c("Greater North Sea"), "North Sea", "Elsewhere Europe"))
# H6: Catchment size
Z6 <- factor(subpop_fct$SubjectiveSize)
# all models
Z.models <- list(Z1, Z2, Z3, Z4, Z5, Z6)
names(Z.models) <-
c("panmictic", "Habitat type", "Restocking", "Ecoregion", "North Sea vs. elsewhere europe", "Catchment size")
# test with different Q models(i.e. different process errors)
Q.models <- c("diagonal and equal", "diagonal and unequal")
# Model parameters(the same across  all models)
U.model <- "unequal"
R.model <- "diagonal and equal"
A.model <- "zero"
B.model <- "identity"
x0.model <- "unequal"
V0.model <- "zero"
model.constant <- list(
U = U.model, R = R.model, A = A.model,
x0 = x0.model, V0 = V0.model, tinitx = 0
)
out.tab <- NULL
fits <- list()
for (i in 1:length(Z.models)) {
for (Q.model in Q.models) {
fit.model <- c(list(Z = Z.models[[i]], Q = Q.model), model.constant)
fit <- MARSS(S_ts,
model = fit.model,
silent = TRUE, control = list(maxit = 2000)
)
out <- data.frame(
H = names(Z.models)[i], Q = Q.model, U = U.model,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(Z.models[[i]])),
num.iter = fit$numIter, converged = !fit$convergence,
stringsAsFactors = FALSE
)
out.tab <- rbind(out.tab, out)
fits <- c(fits, list(fit))
if (i == 1) next # one m for panmictic so only run 1 Q
}
}
?MARSS
out.tab <- NULL
fits <- list()
for (i in 1:length(Z.models)) {
for (Q.model in Q.models) {
fit.model <- c(list(Z = Z.models[[i]], Q = Q.model), model.constant)
fit <- MARSS(S_ts,
model = fit.model,
method = "BFGS",
silent = TRUE, control = list(maxit = 2000)
)
out <- data.frame(
H = names(Z.models)[i], Q = Q.model, U = U.model,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(Z.models[[i]])),
num.iter = fit$numIter, converged = !fit$convergence,
stringsAsFactors = FALSE
)
out.tab <- rbind(out.tab, out)
fits <- c(fits, list(fit))
if (i == 1) next # one m for panmictic so only run 1 Q
}
}
flextable(out.tab)
Xt <- predict(best_model,type="xtT",interval = "confidence")
Xt <- Xt$pred
Xt$t <- Years # add data on years
Xt <- Xt %>%
rename(Year=t, subpopulation=.rownames, xt=estimate)
# plot subpopulation trends
ggplot(Xt,aes(group=subpopulation, y=xt, x=Year,color=subpopulation)) +
geom_line() +
geom_line(aes(y=`Lo 95`),linetype="dashed") +
geom_line(aes(y=`Hi 95`),linetype="dashed")
best_model <- fits[[which.min(out.tab$AICc)]]
Xt <- predict(best_model,type="xtT",interval = "confidence")
Xt <- Xt$pred
Xt$t <- Years # add data on years
Xt <- Xt %>%
rename(Year=t, subpopulation=.rownames, xt=estimate)
# plot subpopulation trends
ggplot(Xt,aes(group=subpopulation, y=xt, x=Year,color=subpopulation)) +
geom_line() +
geom_line(aes(y=`Lo 95`),linetype="dashed") +
geom_line(aes(y=`Hi 95`),linetype="dashed")
Yt <- predict(best_model,type="ytT",interval = "confidence")
Yt <- Yt$pred
Yt$t <- Years
Yt <- Yt %>% rename(Year=t, site=.rownames, yt=estimate)
# plot subpopulation trends
ggplot(Yt,aes(y=yt, x=Year)) +
geom_line() +
geom_line(aes(y=`Lo 95`),linetype="dashed") +
geom_line(aes(y=`Hi 95`),linetype="dashed") +
geom_point(aes(y=y)) +
facet_wrap(vars(site),scales="free_y")
Yt
?predict
